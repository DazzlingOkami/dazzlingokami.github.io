[{"title":"FreeRTOS上实现swap机制","url":"/2022/08/11/FreeRTOS%E4%B8%8A%E5%AE%9E%E7%8E%B0swap%E6%9C%BA%E5%88%B6/","content":"为什么需要引入SWAP机制在小容量SRAM的单片机上使用RTOS是一种很尴尬的事情，因为每个任务都需要分配独立的线程栈，栈空间少则512字节，复杂任务的栈空间则达到了几千字节的大小，这对于仅有8k字节SRAM的单片机来说显得压力太大了，两三个任务就导致内存不足。\n使用协程方案在在小容量单片机上是一个不错的方案，但是协程相比于实时操作系统具有很多的缺点。比如任务实时性不足、在用法上不灵活等。\n根据现代操作系统的SWAP机制，我在FreeRTOS操作系统上也实现了任务栈的swap机制，通过外部存储设备扩展单片机内的可用栈空间大小，可显著降低片内SRAM空间的消耗。同时该方案对任务来说是无感的，也就是说它和普通任务一样在用法上没有区别，可以按照传统的RTOS任务进行设计，这对于任务的移植来说能够降低复杂性。\n方案介绍使用SWAP机制一个重要前提是需要一个大容量的片外存储设备来进行内存交换。比如说片外的PSRAM，通过SPI总线访问的那种。一个基本的设想是先分配一段实际的物理空间，这将作为所有线程的栈空间，线程A在使用完这段空间后，切换到线程B时，先将线程A的栈空间数据存放到外部分配的SWAP空间上，同时将线程B保存在外部SWAP空间上的栈数据恢复到共享的栈空间上。通过预留在FreeRTOS内的HOOK接口很容易就能实现这些功能，且对FreeRTOS的原有代码没有明显的入侵。\n具体实现的要点\n1.任务创建为了指定任务运行时实际的栈空间地址，使得栈空间数据可控，需要使用xTaskCreateStatic()接口创建任务。此外，创建任务时会对栈空间数据进行必要的初始化操作，所有创建任务时的上下文栈空间不能处于共享栈空间上，否则会出现数据冲突。任务的删除也需要特别设计，任务删除仅仅需要删除分配的TCB块空间，栈空间不会收，但是需要释放外部分配的SWAP空间。\n\n2.任务切换时栈空间存储将当前任务的栈空间存储到SWAP空间时，没有必要将整个栈空间都进行存储，因为栈的使用是线性连续的，通常使用栈底的部分数据，所以仅需保存部分数据到SWAP空间即可，这样可以提升线程的切换速度。在任务切换时还需要做适当的判断，避免无效的栈空间交换。我们仅仅需要在从一个共享栈任务切换到另一个共享栈任务时需要触发SWAP机制，其它情况都不需要进行内存交换。例如，Tiemr线程的栈时独立分配的，那么从timer切换到共享栈任务A在切换到timer过程中，显然都是不需要进行栈交换的。可以使用traceTASK_SWITCHED_IN()作为内存交换点。\n\n3.SWAP存储作为栈的交换存储空间，读写速度是非常关键的，将一次栈切换的时间控制在1ms以内时非常有必要的。所有内存交换的机制应当尽量设计的简单可靠，避免使用文件等复杂的存储过程。存储空间的大小和访问方式也很关键，最好是字符设备，块设备的读写在这里是低效的。存储空间应当能够覆盖所有共享的内存数据以及管理这些数据的额外数据开销。\n\n\n方案测试我选择了STM32L051C8T6单片机(8k字节SRAM)配合APS6404L片外的PSRAM进行测试，PSRAM使用16Mhz的SPI总线连接。创建了Timer任务、IDLE任务和一个普通的用户任务，这三个任务使用了独立的栈空间分配，分别为512、512、1024字节。此外还分配了3个栈空间共享的任务，栈空间大小均为1024字节。在这种情况下，所有任务运行起来后FreeRTOS的heap剩余空间仍然超过了1k。额外创建一个栈空间共享的任务开销约100字节左右。\n缺陷\n无法在栈共享任务上创建一个新的栈共享任务，这个在实现要点1上已经解释了。\n任务栈内的局部变量数据无法传递到栈外，这是特别关键的。通常栈内的数据通过邮箱等传递到其它线程后，通过阻塞的方式等待响应，所以该栈内的局部变量数据传递到其它线程后依然有效。但是对于栈共享的任务来说是无法实现的。\n栈共享的任务实时性无法得到保障，因为它在线程唤醒时需要进行栈空间的恢复操作，任务响应时间肯定比栈独立的任务要长。所有对于需要快速响应的任务任然可以使用一般的任务创建方式创建任务，因为从栈共享任务切换到一般任务是不需要触发SWAP机制的。\n\n"},{"title":"FreeRTOS中协程支持低功耗吗","url":"/2022/09/06/FreeRTOS%E4%B8%AD%E5%8D%8F%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BD%8E%E5%8A%9F%E8%80%97%E5%90%97/","content":"FreeRTOS协程FreeRTOS除了支持多线程外，还支持另外一种多任务机制-协程(coroutine)。它和线程不一样，每个协程不需要独立的运行空间，它依靠编程语法技巧在逻辑上实现了多任务的机制。它避免的一般RTOS带来的栈切换开销，仅仅依靠极小的开销就能保存任务的中间状态并在适当的时刻快速恢复任务。简单来说就是任务需要切换时先记录当前执行的位置并返回，重新进入该任务时根据保存的位置恢复任务执行，所以它不支持任务间抢占，所以任务的实时性也比较有限，但是它多任务时的低开销特性在许多场景下具有比较明显的优势。\nFreeRTOS使用C语言提供的switch-case语法作为实现协程的关键，switch-case能够进行非常灵活的跳转，这个真的超乎一般人对switch用法的理解(点名达夫设备)。此外由于多个协程任务共享同一个栈空间，所以协程中无法使用生命周期比较长的局部变量，即定义的局部变量在使用的整个生命周期内不能进行协程的任务调度，一旦发生任务调度，则局部变量的数据就有可能丢失，所以在设计协程时通常使用全局变量来避免使用栈空间内的局部变量数据。\n在设计协程任务时需要根据一定的代码模板来设计，因为协程的核心是由语法来实现的，所以代码无法设计的足够的灵活，存在许多的设计和用法限制。\n低功耗特性协程意味着任务过程简单，在现实应用场景下，简单任务和低功耗特性通常一起出现，那使用FreeRTOS的协程支持低功耗吗？根据FreeRTOS的参考文档来看，官方并没有提及协程+低功耗的用法，但是这两个特性正好是FreeRTOS都支持的，这两个特性能够独立正常工作。那合并到一起呢？\n冲突官方推荐的协程调度方案是这样的：\nvoid vApplicationIdleHook( void )&#123;    for( ;; )    &#123;        vCoRoutineSchedule();    &#125;&#125;\n使用IDLE任务的hook来进行协程的调度。那进一步看看该hook在Idle任务中的执行位置：\n// ...#if ( configUSE_IDLE_HOOK == 1 )&#123;    extern void vApplicationIdleHook( void );    /* Call the user defined function from within the idle task.  This     * allows the application designer to add background functionality     * without the overhead of a separate task.     * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,     * CALL A FUNCTION THAT MIGHT BLOCK. */    vApplicationIdleHook();&#125;#endif /* configUSE_IDLE_HOOK *//* This conditional compilation should use inequality to 0, not equality * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when * user defined low power mode  implementations require * configUSE_TICKLESS_IDLE to be set to a value other than 1. */#if ( configUSE_TICKLESS_IDLE != 0 )&#123;    TickType_t xExpectedIdleTime;    /* It is not desirable to suspend then resume the scheduler on     * each iteration of the idle task.  Therefore, a preliminary     * test of the expected idle time is performed without the     * scheduler suspended.  The result here is not necessarily     * valid. */    xExpectedIdleTime = prvGetExpectedIdleTime();    // ...&#125;#endif /* configUSE_TICKLESS_IDLE */\n到这里应该发现问题了吧。vApplicationIdleHook比TICKLESS处理要先执行，而协程的调度实现是一个死循环，这意味着idle任务没有时机来进行TICKLESS处理，导致系统无法进入低功耗状态。\n这里解释一下vCoRoutineSchedule()为什么需要放到一个无限循环中，这是该协程框架决定的，该调度函数需要一直执行，该函数并不返回一些调度状态，导致我们无法决定协程调度的时机，为了协程的正常运行，所以协程就必须要一直进行调度。而最终的结果就是使用协程后，FreeRTOS的低功耗特性就失效了。\n曙光分析到这里的时候，我突然有一个疑惑，FreeRTOS已经设计了非常完善的配置机制，为什么它没有考虑到这两个功能的用法冲突，进而在配置上进行处理呢。比如说开启协程后就禁止使用低功耗特性。这是不是意味着有什么方法能够突破这个限制，所以官方故意在配置上留下了同时启用两种功能的可能性。\n我重新开始梳理了FreeRTOS的协程和低功耗实现方案，发现现有的设计是无法实现的。将协程调度放入到单独的线程中是最接近的一个实现方案：\nvoid CoRoutineTask(void *p)&#123;    for(;;)&#123;        vCoRoutineSchedule();        // vTaskDelay(?);    &#125;&#125;\n该任务的优先级如何确定呢？协程中的延时是否需要？延时多长？只要优先级比idle任务高且存在任意时间的延时，低功耗的tickless就可执行。但是难点是无法确定延时时间。\n协程没有实现计算下一次协程调度的时机函数。对于任务来说，prvGetExpectedIdleTime()函数能够计算出下一次进行任务调度的期望时间。所以我们也需要一个这样的函数，计算下一次进行协程调度的期望时间。实现了这个函数将是在协程下实现低功耗的希望。\n下一次协程调度到底需要多长时间检索这些数据就能知道答案：\n\n1.等待任务列表(pxDelayedCoRoutineList)\n2.就绪任务列表(pxReadyCoRoutineLists)\n3.即将就绪任务列表(xPendingReadyCoRoutineList)\n\n最后一个是很容易忽视的，在进行协程间通信时，任务并不是直接切换到就绪任务列表中，而是添加到了待就绪任务列表(这是为了保证就绪任务列表不在中断中进行修改)。所以在检索任务时该列表中的任务可以看作时任务已经就绪了。\n当就绪任务列表非空或者即将就绪任务列表非空意味着协程需要立即调度。当等待任务列表中的任务已经超时了也要立即调度。否则就根据等待任务列表中等待时间最少的任务来计算下一次协程调度的时间。此外，还需要注意所有列表为空的情况，这可以认为下一次调度的时间为无限长。\nTickType_t xGetExpectedIdleTime( void )&#123;    CRCB_t * pxCRCB;    UBaseType_t uxPriority;    TickType_t xIdleTime;    if( listLIST_IS_EMPTY( &amp;xPendingReadyCoRoutineList ) == pdFALSE )    &#123;        xIdleTime = 0u;    &#125;    else    &#123;        xIdleTime = portMAX_DELAY;        for( uxPriority = 0; uxPriority &lt; configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )        &#123;            if( listLIST_IS_EMPTY( &amp;( pxReadyCoRoutineLists[ uxPriority ] ) ) == pdFALSE )            &#123;                xIdleTime = 0u;                break;            &#125;        &#125;        if(xIdleTime &gt; 0u)        &#123;            if( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )            &#123;                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );                if(xCoRoutineTickCount &lt; listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )))                &#123;                    xIdleTime = listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )) - xCoRoutineTickCount;                &#125;                else                &#123;                    xIdleTime = 0u;                &#125;            &#125;            else            &#123;                mtCOVERAGE_TEST_MARKER();            &#125;        &#125;    &#125;    return xIdleTime;&#125;\n\n在代码风格上参考了FreeRTOS相类似的代码风格。这里检查了所有优先级的就绪任务列表(从高优先级到低优先级应该会更快)，可以考虑仅仅检查uxTopCoRoutineReadyPriority优先级的列表，这样在优先级较多的时候可以执行的更快。\n协程运行在可休眠的线程中能够计算协程的调度时机后，我们就能将协程放入到一个可休眠的线程中，而不是在阻塞的无限循环中执行。\nvoid vCoScheduleTask( void )&#123;    // ...    for( ;; )    &#123;        vCoRoutineSchedule();        uint32_t idle_time = xGetExpectedIdleTime();        if(idle_time &gt; 0)        &#123;            vTaskDelay(idle_time);        &#125;    &#125;&#125;\n该线程的优先级比Idle线程略高。这样在保证正常的协程调度的情况下，系统也能够正常的运行idle线程，保证tickless中的prvGetExpectedIdleTime()函数能够计算出合理的系统线程调度休眠时间，进而实现了协程和低功耗特性的共存。\n最后xGetExpectedIdleTime()函数需要直接实现在croutine.c和.h文件中，所以会对FreeRTOS代码源文件进行修改，但是这没有对现存的代码进行进行逻辑上的更改，所以这样的修改是可控的。\n上面还有一点未提及，如果在中断中同协程进行通信，协程还能够响应吗？需要如何修改才能实现在中断中同协程通信且不影响现有的低功耗特性？其实只需要做简单的修改即可，欢迎讨论。\n"},{"title":"Macro returning the number of arguments it is given in C?","url":"/2022/11/12/Macro%20returning%20the%20number%20of%20arguments%20it%20is%20given%20in%20C/","content":"一个简单的实现能否使用一个简单的宏在C语言中计算不定参数的数量，例如这样:\nfoo(1) -&gt; 1foo(cat, dog) -&gt; 2foo(red, green, blue) -&gt; 3\n一个比较简单的实现是这样的：\n#define PP_NARG(...) (sizeof((const void*[])&#123;__VA_ARGS__&#125;)/sizeof(void*))\n当参数为空时可能在某些编译器下不能正常的工作，但是稍微修改一下就行了。\n#define PP_NARG(...) (sizeof((int[])&#123;0, ##__VA_ARGS__&#125;)/sizeof(int) - 1)#pragma GCC diagnostic ignored &quot;-Wint-conversion&quot; /* Ignore warning */\n\n这里使用了sizeof()关键字，就意味着它不是在预处理阶段计算不定参数的长度。同时要求参数必须为有意义的符号。这就限制了它的使用场景，比如说将不定参数的个数作为数组定义时的长度。\n另外一种有趣的写法这是我从网上找到的一种写法，它能够处理1~64个不定产生的情况，没有依赖于编译器的关键字，仅仅靠预处理就完成了参数的计数。\n#ifndef JLSS_ID_NARG_H#define JLSS_ID_NARG_H/*** http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5?pli=1****    Newsgroups: comp.std.c**    From: Laurent Deniau &lt;laurent.deniau@cern.ch&gt;**    Date: Mon, 16 Jan 2006 18:43:40 +0100**    Subject: __VA_NARG__****    A year ago, I was asking here for an equivalent of __VA_NARG__ which**    would return the number of arguments contained in __VA_ARGS__ before its**    expansion. In fact my problem at that time (detecting for a third**    argument) was solved by the solution of P. Mensonides. But I was still**    thinking that the standard should have provided such a facilities rather**    easy to compute for cpp.****    This morning I had to face again the same problem, that is knowing the**    number of arguments contained in __VA_ARGS__ before its expansion (after**    its expansion can always be achieved if you can do it before). I found a**    simple non-iterative solution which may be of interest here as an answer**    to who will ask in the future for a kind of __VA_NARG__ in the standard**    and I post it for archiving. May be some more elegant-efficient solution**    exists?****    Returns NARG, the number of arguments contained in __VA_ARGS__ before**    expansion as far as NARG is &gt;0 and &lt;64 (cpp limits):****    #define PP_NARG( ...) PP_NARG_(__VA_ARGS__,PP_RSEQ_N())**    #define PP_NARG_(...) PP_ARG_N(__VA_ARGS__)**    #define PP_ARG_N(_1,_2,_3,_4,_5,_6,_7,_8,_9,[..],_61,_62,_63,N,...) N**    #define PP_RSEQ_N() 63,62,61,60,[..],9,8,7,6,5,4,3,2,1,0****    [..] stands for the continuation of the sequence omitted here for**    lisibility.****    PP_NARG(A) -&gt; 1**    PP_NARG(A,B) -&gt; 2**    PP_NARG(A,B,C) -&gt; 3**    PP_NARG(A,B,C,D) -&gt; 4**    PP_NARG(A,B,C,D,E) -&gt; 5**    PP_NARG(A1,A2,[..],A62,A63) -&gt; 63**** ======****    Newsgroups: comp.std.c**    From: Roland Illig &lt;roland.il...@gmx.de&gt;**    Date: Fri, 20 Jan 2006 12:58:41 +0100**    Subject: Re: __VA_NARG__****    Laurent Deniau wrote:**    &gt; This morning I had to face again the same problem, that is knowing the**    &gt; number of arguments contained in __VA_ARGS__ before its expansion (after**    &gt; its expansion can always be achieved if you can do it before). I found a**    &gt; simple non-iterative solution which may be of interest here as an answer**    &gt; to who will ask in the future for a kind of __VA_NARG__ in the standard**    &gt; and I post it for archiving. May be some more elegant-efficient solution**    &gt; exists?****    Thanks for this idea. I really like it.****    For those that only want to copy and paste it, here is the expanded version:**** // Some test cases** PP_NARG(A) -&gt; 1** PP_NARG(A,B) -&gt; 2** PP_NARG(A,B,C) -&gt; 3** PP_NARG(A,B,C,D) -&gt; 4** PP_NARG(A,B,C,D,E) -&gt; 5** PP_NARG(1,2,3,4,5,6,7,8,9,0,    //  1..10**         1,2,3,4,5,6,7,8,9,0,    // 11..20**         1,2,3,4,5,6,7,8,9,0,    // 21..30**         1,2,3,4,5,6,7,8,9,0,    // 31..40**         1,2,3,4,5,6,7,8,9,0,    // 41..50**         1,2,3,4,5,6,7,8,9,0,    // 51..60**         1,2,3) -&gt; 63****Note: using PP_NARG() without arguments would violate 6.10.3p4 of ISO C99.*//* The PP_NARG macro returns the number of arguments that have been** passed to it.*/#define PP_NARG(...) \\    PP_NARG_(__VA_ARGS__,PP_RSEQ_N())#define PP_NARG_(...) \\    PP_ARG_N(__VA_ARGS__)#define PP_ARG_N( \\     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\    _61,_62,_63,  N, ...) N#define PP_RSEQ_N() \\    63,62,61,60,                   \\    59,58,57,56,55,54,53,52,51,50, \\    49,48,47,46,45,44,43,42,41,40, \\    39,38,37,36,35,34,33,32,31,30, \\    29,28,27,26,25,24,23,22,21,20, \\    19,18,17,16,15,14,13,12,11,10, \\     9, 8, 7, 6, 5, 4, 3, 2, 1, 0#endif /* JLSS_ID_NARG_H */\n注释中也提到，当参数为空时需要编译器的特殊支持。但是我发现做适当的修改就能够避免这种尴尬的局面。\n#define PP_NARG(...)   (PP_NARG_(0, ##__VA_ARGS__, PP_RSEQ_N()) - 1)\n只要参数不超过64个，它都能很好的工作，而且在预处理阶段就能计算出参数的个数。\n总结我参考了大量其他人的写法，其中的基本原理大都是基于这两种思想。在C++中我还看到其它的解法，但是我目前还没有想到在C++中需要统计不定参数个数的地方。\n#include &lt;tuple&gt;#define MACRO(...) \\    std::cout &lt;&lt;&quot;num args:&quot; \\    &lt;&lt; std::tuple_size&lt;decltype(std::make_tuple(__VA_ARGS__))&gt;::value \\    &lt;&lt; std::endl;/* Another way */#define VA_COUNT(...) detail::va_count(__VA_ARGS__)namespace detail&#123;    template&lt;typename ...Args&gt;    constexpr std::size_t va_count(Args&amp;&amp;...) &#123; return sizeof...(Args); &#125;&#125;\n\n应用能够计算不定参数个数对于实现函数静态优化有一定意义，在代码中判断参数个数调用不同的函数实现，相当于实现了函数多态的一种特性。\n"},{"title":"Recommended C style and coding rules","url":"/2021/01/21/Recommended%20C%20style%20and%20coding%20rules/","content":"This document describes C code style used by Tilen MAJERLE in his projects and libraries.\nTable of Contents\nThe single most important rule\nRecommended C style and coding rules\nGeneral rules\nComments\nFunctions\nVariables\nStructures, enumerations, typedefs\nCompound statements\nSwitch statement\n\n\nMacros and preprocessor directives\nDocumentation\nHeader/source files\nArtistic Style configuration\nEclipse formatter\n\nThe single most important ruleLet’s start with the quote from GNOME developer site.\n\nThe single most important rule when writing code is this: check the surrounding code and try to imitate it.\nAs a maintainer it is dismaying to receive a patch that is obviously in a different coding style to the surrounding code. This is disrespectful, like someone tromping into a spotlessly-clean house with muddy shoes.\nSo, whatever this document recommends, if there is already written code and you are patching it, keep its current style consistent even if it is not your favorite style.\n\nGeneral rulesHere are listed most obvious and important general rules. Please check them carefully before you continue with other chapters.\n\nUse C99 standard\n\nDo not use tabs, use spaces instead\n\nUse 4 spaces per indent level\n\nUse 1 space between keyword and opening bracket\n\nDo not use space between function name and opening bracket\nint32_t a = sum(4, 3);              /* OK */int32_t a = sum (4, 3);             /* Wrong */\n\nNever use __ or _ prefix for variables/functions/macros/types. This is reserved for C language itself\n\nPrefer prv_ name prefix for strictly module-private functions\n\n\nUse only lowercase characters for variables/functions/macros/types with optional underscore _ char\n\nOpening curly bracket is always at the same line as keyword (for, while, do, switch, if, …)\nsize_t i;for (i = 0; i &lt; 5; ++i) &#123;           /* OK */&#125;for (i = 0; i &lt; 5; ++i)&#123;            /* Wrong */&#125;for (i = 0; i &lt; 5; ++i)             /* Wrong */&#123;&#125;\n\nUse single space before and after comparison and assignment operators\nint32_t a;a = 3 + 4;              /* OK */for (a = 0; a &lt; 5; ++a) /* OK */a=3+4;                  /* Wrong */a = 3+4;                /* Wrong */for (a=0;a&lt;5;++a)       /* Wrong */\n\nUse single space after every comma\nfunc_name(5, 4);        /* OK */func_name(4,3);         /* Wrong */\n\nDo not initialize static and global variables to 0 (or NULL), let compiler do it for you\nstatic int32_t a;       /* OK */static int32_t b = 4;   /* OK */static int32_t a = 0;   /* Wrong */voidmy_func(void) &#123;    static int32_t* ptr;/* OK */    static char abc = 0;/* Wrong */&#125;\n\nDeclare all local variables of the same type in the same line\nvoidmy_func(void) &#123;    char a;             /* OK */    char a, b;          /* OK */    char b;             /* Wrong, variable with char type already exists */&#125;\n\nDeclare local variables in order\n\nCustom structures and enumerations\nInteger types, wider unsigned type first\nSingle/Double floating pointintmy_func(void) &#123;    /* 1 */    my_struct_t my;     /* First custom structures */    my_struct_ptr_t* p; /* Pointers too */    /* 2 */    uint32_t a;    int32_t b;    uint16_t c;    int16_t g;    char h;    /* ... */    /* 3 */    double d;    float f;&#125;\n\n\n\nAlways declare local variables at the beginning of the block, before first executable statement\n\nDeclare counter variables in for loop\n/* OK */for (size_t i = 0; i &lt; 10; ++i)/* OK, if you need counter variable later */size_t i;for (i = 0; i &lt; 10; ++i) &#123;    if (...) &#123;        break;    &#125;&#125;if (i == 10) &#123;&#125;/* Wrong */size_t i;for (i = 0; i &lt; 10; ++i) ...\n\nAvoid variable assignment with function call in declaration, except for single variables\nvoida(void) &#123;    /* Avoid function calls when declaring variable */    int32_t a, b = sum(1, 2);    /* Use this */    int32_t a, b;    b = sum(1, 2);    /* This is ok */    uint8_t a = 3, b = 4;&#125;\n\nExcept char, float or double, always use types declared in stdint.h library, eg. uint8_t for unsigned 8-bit, etc.\n\nDo not use stdbool.h library. Use 1 or 0 for true or false respectively\n/* OK */uint8_t status;status = 0;/* Wrong */#include &lt;stdbool.h&gt;bool status = true;\n\nNever compare against true, eg. if (check_func() == 1), use if (check_func()) &#123; ... &#125;\n\nAlways compare pointers against NULL value\nvoid* ptr;/* ... *//* OK, compare against NULL */if (ptr == NULL || ptr != NULL) &#123;&#125;/* Wrong */if (ptr || !ptr) &#123;&#125;\n\nAlways use pre-increment (and decrement respectively) instead of post-increment (and decrement respectively)\nint32_t a = 0;...a++;            /* Wrong */++a;            /* OK */for (size_t j = 0; j &lt; 10; ++j) &#123;&#125;  /* OK */\n\nAlways use size_t for length or size variables\n\nAlways use const for pointer if function should not modify memory pointed to by pointer\n\nAlways use const for function parameter or variable, if it should not be modified\n/* When d could be modified, data pointed to by d could not be modified */voidmy_func(const void* d) &#123;&#125;/* When d and data pointed to by d both could not be modified */voidmy_func(const void* const d) &#123;&#125;/* Not required, it is advised */voidmy_func(const size_t len) &#123;&#125;/* When d should not be modified inside function, only data pointed to by d could be modified */voidmy_func(void* const d) &#123;&#125;\n\nWhen function may accept pointer of any type, always use void *, do not use uint8_t *\n\nFunction must take care of proper casting in implementation/* * To send data, function should not modify memory pointed to by `data` variable * thus `const` keyword is important * * To send generic data (or to write them to file) * any type may be passed for data, * thus use `void *` *//* OK example */voidsend_data(const void* data, size_t len) &#123; /* OK */    /* Do not cast `void *` or `const void *` */    const uint8_t* d = data;/* Function handles proper type for internal usage */&#125;voidsend_data(const void* data, int len) &#123;    /* Wrong, not not use int */&#125;\n\n\n\nAlways use brackets with sizeof operator\n\nNever use Variable Length Array (VLA). Use dynamic memory allocation instead with standard C malloc and free functions or if library/project provides custom memory allocation, use its implementation\n\nTake a look at LwMEM, custom memory management library/* OK */#include &lt;stdlib.h&gt;voidmy_func(size_t size) &#123;    int32_t* arr;    arr = malloc(sizeof(*arr) * n); /* OK, Allocate memory */    arr = malloc(sizeof *arr * n);  /* Wrong, brackets for sizeof operator are missing */    if (arr == NULL) &#123;        /* FAIL, no memory */    &#125;    free(arr);  /* Free memory after usage */&#125;/* Wrong */voidmy_func(size_t size) &#123;    int32_t arr[size];  /* Wrong, do not use VLA */&#125;\n\n\n\nAlways compare variable against zero, except if it is treated as boolean type\n\nNever compare boolean-treated variables against zero or one. Use NOT (!) instead\nsize_t length = 5;  /* Counter variable */uint8_t is_ok = 0;  /* Boolean-treated variable */if (length)         /* Wrong, length is not treated as boolean */if (length &gt; 0)     /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (length == 0)    /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (is_ok)          /* OK, variable is treated as boolean */if (!is_ok)         /* OK, -||- */if (is_ok == 1)     /* Wrong, never compare boolean variable against 1! */if (is_ok == 0)     /* Wrong, use ! for negative check */\n\nAlways use /* comment */ for comments, even for single-line comment\n\nAlways include check for C++ with extern keyword in header file\n\nEvery function must include doxygen-enabled comment, even if function is static\n\nUse English names/text for functions, variables, comments\n\nUse lowercase characters for variables\n\nUse underscore if variable contains multiple names, eg. force_redraw. Do not use forceRedraw\n\nNever cast function returning void *, eg. uint8_t* ptr = (uint8_t *)func_returning_void_ptr(); as void * is safely promoted to any other pointer type\n\nUse uint8_t* ptr = func_returning_void_ptr(); instead\n\n\nAlways use &lt; and &gt; for C Standard Library include files, eg. #include &lt;stdlib.h&gt;\n\nAlways use &quot;&quot; for custom libraries, eg. #include &quot;my_library.h&quot;\n\nWhen casting to pointer type, always align asterisk to type, eg. uint8_t* t = (uint8_t*)var_width_diff_type\n\nAlways respect code style already used in project or library\n\n\nComments\nComments starting with // are not allowed. Always use /* comment */, even for single-line comment\n//This is comment (wrong)/* This is comment (ok) */\n\nFor multi-line comments use space+asterisk for every line\n/* * This is multi-line comments, * written in 2 lines (ok) *//** * Wrong, use double-asterisk only for doxygen documentation *//** Single line comment without space before asterisk (wrong)*//* * Single line comment in multi-line configuration (wrong) *//* Single line comment (ok) */\n\nUse 12 indents (12 * 4 spaces) offset when commenting. If statement is larger than 12 indents, make comment 4-spaces aligned (examples below) to next available indent\nvoidmy_func(void) &#123;    char a, b;    a = call_func_returning_char_a(a);          /* This is comment with 12*4 spaces indent from beginning of line */    b = call_func_returning_char_a_but_func_name_is_very_long(a);   /* This is comment, aligned to 4-spaces indent */&#125;\n\n\n\nFunctions\nEvery function which may have access from outside its module, must include function prototype (or declaration)\n\nFunction name must be lowercase, optionally separated with underscore _ character\n/* OK */void my_func(void);void myfunc(void);/* Wrong */void MYFunc(void);void myFunc();\n\nWhen function returns pointer, align asterisk to return type\n/* OK */const char* my_func(void);my_struct_t* my_func(int32_t a, int32_t b);/* Wrong */const char *my_func(void);my_struct_t * my_func(void);\nAlign all function prototypes (with the same/similar functionality) for better readability\n/* OK, function names aligned */void        set(int32_t a);my_type_t   get(void);my_ptr_t*   get_ptr(void);/* Wrong */void set(int32_t a);const char * get(void);\n\nFunction implementation must include return type and optional other keywords in separate line\n/* OK */int32_tfoo(void) &#123;    return 0;&#125;/* OK */static const char*get_string(void) &#123;    return &quot;Hello world!\\r\\n&quot;;&#125;/* Wrong */int32_t foo(void) &#123;    return 0;&#125;\n\nWhen function returns pointer, asterisk character must be aligned to return type (char*)\n/* OK */const char*foo(void) &#123;    return &quot;test&quot;;&#125;/* Wrong */const char*foo(void) &#123;    return &quot;test&quot;;&#125;\n\n\n\nVariables\nMake variable name all lowercase with optional underscore _ character\n/* OK */int32_t a;int32_t my_var;int32_t myvar;/* Wrong */int32_t A;int32_t myVar;int32_t MYVar;\n\nGroup local variables together by type\nvoidfoo(void) &#123;    int32_t a, b;   /* OK */    char a;    char b;         /* Wrong, char type already exists */&#125;\n\nDo not declare variable after first executable statement\nvoidfoo(void) &#123;    int32_t a;    a = bar();    int32_t b;      /* Wrong, there is already executable statement */&#125;\n\nYou may declare new variables inside next indent level\nint32_t a, b;a = foo();if (a) &#123;    int32_t c, d;   /* OK, c and d are in if-statement scope */    c = foo();    int32_t e;      /* Wrong, there was already executable statement inside block */&#125;\n\nDeclare pointer variables with asterisk aligned to type\n/* OK */char* a;/* Wrong */char *a;char * a;\n\nWhen declaring multiple pointer variables, you may declare them with asterisk aligned to variable name\n/* OK */char *p, *n;\n\n\n\nStructures, enumerations, typedefs\nStructure or enumeration name must be lowercase with optional underscore _ character between words\nStructure or enumeration may contain typedef keyword\nAll structure members must be lowercase\nAll enumeration members must be uppercase\nStructure/enumeration must follow doxygen documentation syntax\n\nWhen structure is declared, it may use one of 3 different options:\n\nWhen structure is declared with name only, it must not contain _t suffix after its name.struct struct_name &#123;    char* a;    char b;&#125;;\nWhen structure is declared with typedef only, it has to contain _t suffix after its name.typedef struct &#123;    char* a;    char b;&#125; struct_name_t;\nWhen structure is declared with name and typedef, it must not contain _t for basic name and it has to contain _t suffix after its name for typedef part.typedef struct struct_name &#123;    char* a;    char b;    char c;&#125; struct_name_t;\n\n\n\nExamples of bad declarations and their suggested corrections\n/* a and b must be separated to 2 lines *//* Name of structure with typedef must include _t suffix */typedef struct &#123;    int32_t a, b;&#125; a;/* Corrected version */typedef struct &#123;    int32_t a;    int32_t b;&#125; a_t;/* Wrong name, it must not include _t suffix */struct name_t &#123;    int32_t a;    int32_t b;&#125;;/* Wrong parameters, must be all uppercase */typedef enum &#123;    MY_ENUM_TESTA,    my_enum_testb,&#125; my_enum_t;\n\n\nWhen initializing structure on declaration, use C99 initialization style\n/* OK */a_t a = &#123;    .a = 4,    .b = 5,&#125;;/* Wrong */a_t a = &#123;1, 2&#125;;\n\nWhen new typedef is introduced for function handles, use _fn suffix\n/* Function accepts 2 parameters and returns uint8_t *//* Name of typedef has `_fn` suffix */typedef uint8_t (*my_func_typedef_fn)(uint8_t p1, const char* p2);\n\n\n\nCompound statements\nEvery compound statement must include opening and closing curly bracket, even if it includes only 1 nested statement\n\nEvery compound statement must include single indent; when nesting statements, include 1 indent size for each nest\n/* OK */if (c) &#123;    do_a();&#125; else &#123;    do_b();&#125;/* Wrong */if (c)    do_a();else    do_b();/* Wrong */if (c) do_a();else do_b();\n\nIn case of if or if-else-if statement, else must be in the same line as closing bracket of first statement\n/* OK */if (a) &#123;&#125; else if (b) &#123;&#125; else &#123;&#125;/* Wrong */if (a) &#123;&#125;else &#123;&#125;/* Wrong */if (a) &#123;&#125;else&#123;&#125;\n\nIn case of do-while statement, while part must be in the same line as closing bracket of do part\n/* OK */do &#123;    int32_t a;    a = do_a();    do_b(a);&#125; while (check());/* Wrong */do&#123;/* ... */&#125; while (check());/* Wrong */do &#123;/* ... */&#125;while (check());\n\nIndentation is required for every opening bracket\nif (a) &#123;    do_a();&#125; else &#123;    do_b();    if (c) &#123;        do_c();    &#125;&#125;\n\nNever do compound statement without curly bracket, even in case of single statement. Examples below show bad practices\nif (a) do_b();else do_c();if (a) do_a(); else do_b();\n\nEmpty while, do-while or for loops must include brackets\n/* OK */while (is_register_bit_set()) &#123;&#125;/* Wrong */while (is_register_bit_set());while (is_register_bit_set()) &#123; &#125;while (is_register_bit_set()) &#123;&#125;\n\nIf while (or for, do-while, etc) is empty (it can be the case in embedded programming), use empty single-line brackets\n/* Wait for bit to be set in embedded hardware unituint32_t* addr = HW_PERIPH_REGISTER_ADDR;/* Wait bit 13 to be ready */while (*addr &amp; (1 &lt;&lt; 13)) &#123;&#125;        /* OK, empty loop contains no spaces inside curly brackets */while (*addr &amp; (1 &lt;&lt; 13)) &#123; &#125;       /* Wrong */while (*addr &amp; (1 &lt;&lt; 13)) &#123;         /* Wrong */&#125;while (*addr &amp; (1 &lt;&lt; 13));          /* Wrong, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */\nAlways prefer using loops in this order: for, do-while, while\n\nAvoid incrementing variables inside loop block if possible, see examples\n\n\n/* Not recommended */int32_t a = 0;while (a &lt; 10) &#123;    .    ..    ...    ++a;&#125;/* Better */for (size_t a = 0; a &lt; 10; ++a) &#123;&#125;/* Better, if inc may not happen in every cycle */for (size_t a = 0; a &lt; 10; ) &#123;    if (...) &#123;        ++a;    &#125;&#125;\n\nSwitch statement\nAdd single indent for every case statement\n\nUse additional single indent for break statement in each case or default\n/* OK, every case has single indent *//* OK, every break has additional indent */switch (check()) &#123;    case 0:        do_a();        break;    case 1:        do_b();        break;    default:        break;&#125;/* Wrong, case indent missing */switch (check()) &#123;case 0:    do_a();    break;case 1:    do_b();    break;default:    break;&#125;/* Wrong */switch (check()) &#123;    case 0:        do_a();    break;      /* Wrong, break must have indent as it is under case */    case 1:    do_b();     /* Wrong, indent under case is missing */    break;    default:        break;&#125;\n\nAlways include default statement\n/* OK */switch (var) &#123;    case 0:        do_job();        break;    default: break;&#125;/* Wrong, default is missing */switch (var) &#123;    case 0:        do_job();        break;&#125;\n\nIf local variables are required, use curly brackets and put break statement inside.\n\nPut opening curly bracket in the same line as case statementswitch (a) &#123;    /* OK */    case 0: &#123;        int32_t a, b;        char c;        a = 5;        /* ... */        break;    &#125;    /* Wrong */    case 1:    &#123;        int32_t a;        break;    &#125;    /* Wrong, break shall be inside */    case 2: &#123;        int32_t a;    &#125;    break;&#125;\n\n\n\n\n\nMacros and preprocessor directives\nAlways use macros instead of literal constants, specially for numbers\n\nAll macros must be fully uppercase, with optional underscore _ character, except if they are clearly marked as function which may be in the future replaced with regular function syntax\n/* OK */#define MY_MACRO(x)         ((x) * (x))/* Wrong */#define square(x)           ((x) * (x))\n\nAlways protect input parameters with parentheses\n/* OK */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))/* Wrong */#define MIN(x, y)           x &lt; y ? x : y\n\nAlways protect final macro evaluation with parenthesis\n/* Wrong */#define MIN(x, y)           (x) &lt; (y) ? (x) : (y)#define SUM(x, y)           (x) + (y)/* Imagine result of this equation using wrong SUM implementation */int32_t x = 5 * SUM(3, 4);  /* Expected result is 5 * 7 = 35 */int32_t x = 5 * (3) + (4);  /* It is evaluated to this, final result = 19 which is not what we expect *//* Correct implementation */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))#define SUM(x, y)           ((x) + (y))\n\nWhen macro uses multiple statements, protect it using do-while (0) statement\ntypedef struct &#123;    int32_t px, py;&#125; point_t;point_t p;                  /* Define new point *//* Wrong implementation *//* Define macro to set point */#define SET_POINT(p, x, y)  (p)-&gt;px = (x); (p)-&gt;py = (y)    /* 2 statements. Last one should not implement semicolon */SET_POINT(&amp;p, 3, 4);        /* Set point to position 3, 4. This evaluates to... */(&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); /* ... to this. In this example this is not a problem. *//* Consider this ugly code, however it is valid by C standard (not recommended) */if (a)                      /* If a is true */    if (b)                  /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    else        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 *//* Evaluates to code below. Do you see the problem? */if (a)    if (b)        (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6);/* Or if we rewrite it a little */if (a)    if (b)        (&amp;p)-&gt;px = (3);        (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5);        (&amp;p)-&gt;py = (6);/* * Ask yourself a question: To which `if` statement `else` keyword belongs? * * Based on first part of code, answer is straight-forward. To inner `if` statement when we check `b` condition * Actual answer: Compilation error as `else` belongs nowhere *//* Better and correct implementation of macro */#define SET_POINT(p, x, y)  do &#123; (p)-&gt;px = (x); (p)-&gt;py = (y); &#125; while (0)    /* 2 statements. No semicolon after while loop *//* Or even better */#define SET_POINT(p, x, y)  do &#123;    \\   /* Backslash indicates statement continues in new line */    (p)-&gt;px = (x);                  \\    (p)-&gt;py = (y);                  \\&#125; while (0)                             /* 2 statements. No semicolon after while loop *//* Now original code evaluates to */if (a)    if (b)        do &#123; (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); &#125; while (0);    else        do &#123; (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); &#125; while (0);/* Every part of `if` or `else` contains only `1` inner statement (do-while), hence this is valid evaluation *//* To make code perfect, use brackets for every if-ifelse-else statements */if (a) &#123;                    /* If a is true */    if (b) &#123;                /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    &#125; else &#123;        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 */    &#125;&#125;\n\nAlways write macro documentation as regular function with additional hideinitializer doxygen keyword\n#define MY_MACRO(x)         ((x) * 2)\n\nAvoid using #ifdef or #ifndef. Use defined() or !defined() instead\n#ifdef XYZ/* do something */#endif /* XYZ */\n\nAlways document if/elif/else/endif statements\n/* OK */#if defined(XYZ)/* Do if XYZ defined */#else /* defined(XYZ) *//* Do if XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)/* Do if XYZ defined */#else/* Do if XYZ not defined */#endif\n\nDo not indent sub statements inside #if statement\n/* OK */#if defined(XYZ)#if defined(ABC)/* do when ABC defined */#endif /* defined(ABC) */#else /* defined(XYZ) *//* Do when XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)    #if defined(ABC)        /* do when ABC defined */    #endif /* defined(ABC) */#else /* defined(XYZ) */    /* Do when XYZ not defined */#endif /* !defined(XYZ) */\n\n\n\nDocumentationDocumented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly.\n\nUse doxygen-enabled documentation style for variables, functions and structures/enumerations\n\nAlways use \\ for doxygen, do not use @\n\nAlways use 5x4 spaces (5 tabs) offset from beginning of line for text\n/** * \\brief           Holds pointer to first entry in linked list *                  Beginning of this text is 5 tabs (20 spaces) from beginning of line */statictype_t* list;\n\nEvery structure/enumeration member must include documentation\n\nUse 12x4 spaces offset for beginning of comment\n/** * \\brief           This is point struct * \\note            This structure is used to calculate all point *                      related stuff */typedef struct &#123;    int32_t x;                                  /*!&lt; Point X coordinate */    int32_t y;                                  /*!&lt; Point Y coordinate */    int32_t size;                               /*!&lt; Point size.                                                    Since comment is very big,                                                    you may go to next line */&#125; point_t;/** * \\brief           Point color enumeration */typedef enum &#123;    COLOR_RED,                                  /*!&lt; Red color. This comment has 12x4                                                    spaces offset from beginning of line */    COLOR_GREEN,                                /*!&lt; Green color */    COLOR_BLUE,                                 /*!&lt; Blue color */&#125; point_color_t;\n\nDocumentation for functions must be written in function implementation (source file usually)\n\nFunction must include brief and all parameters documentation\n\nEvery parameter must be noted if it is in or out for input and output respectively\n\nFunction must include return parameter if it returns something. This does not apply for void functions\n\nFunction can include other doxygen keywords, such as note or warning\n\nUse colon : between parameter name and its description\n/** * \\brief           Sum `2` numbers * \\param[in]       a: First number * \\param[in]       b: Second number * \\return          Sum of input values */int32_tsum(int32_t a, int32_t b) &#123;    return a + b;&#125;/** * \\brief           Sum `2` numbers and write it to pointer * \\note            This function does not return value, it stores it to pointer instead * \\param[in]       a: First number * \\param[in]       b: Second number * \\param[out]      result: Output variable used to save result */voidvoid_sum(int32_t a, int32_t b, int32_t* result) &#123;    *result = a + b;&#125;\n\nIf function returns member of enumeration, use ref keyword to specify which one\n/** * \\brief           My enumeration */typedef enum &#123;    MY_ERR,                                     /*!&lt; Error value */    MY_OK                                       /*!&lt; OK value */&#125; my_enum_t;/** * \\brief           Check some value * \\return          \\ref MY_OK on success, member of \\ref my_enum_t otherwise */my_enum_tcheck_value(void) &#123;    return MY_OK;&#125;\n\nUse notation (`NULL` =&gt; NULL) for constants or numbers\n/** * \\brief           Get data from input array * \\param[in]       in: Input data * \\return          Pointer to output data on success, `NULL` otherwise */const void *get_data(const void* in) &#123;    return in;&#125;\n\nDocumentation for macros must include hideinitializer doxygen command\n/** * \\brief           Get minimal value between `x` and `y` * \\param[in]       x: First value * \\param[in]       y: Second value * \\return          Minimal value between `x` and `y` * \\hideinitializer */#define MIN(x, y)       ((x) &lt; (y) ? (x) : (y))\n\n\n\nHeader/source files\nLeave single empty line at the end of file\n\nEvery file must include doxygen annotation for file and brief description followed by empty line (when using doxygen)\n/** * \\file            template.h * \\brief           Template include file */                    /* Here is empty line */\n\nEvery file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen)\n\nUse the same license as already used by project/library\n/** * \\file            template.h * \\brief           Template include file *//* * Copyright (c) year FirstName LASTNAME * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the &quot;Software&quot;), to deal in the Software without restriction, * including without limitation the rights to use, copy, modify, merge, * publish, distribute, sublicense, and/or sell copies of the Software, * and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. * * This file is part of library_name. * * Author:          FirstName LASTNAME &lt;optional_email@example.com&gt; */\n\nHeader file must include guard #ifndef\n\nHeader file must include C++ check\n\nInclude external header files outside C++ check\n\nInclude external header files with STL C files first followed by application custom files\n\nHeader file must include only every other header file in order to compile correctly, but not more (.c should include the rest if required)\n\nHeader file must only expose module public variables/types/functions\n\nUse extern for global module variables in header file, define them in source file later\n/* file.h ... */#ifndef ...extern int32_t my_variable; /* This is global variable declaration in header */#endif/* file.c ... */int32_t my_variable;        /* Actually defined in source */\nNever include .c files in another .c file\n\n.c file should first include corresponding .h file, later others, unless otherwise explicitly necessary\n\nDo not include module private declarations in header file\n\nHeader file example (no license for sake of an example)\n/* License comes here */#ifndef TEMPLATE_HDR_H#define TEMPLATE_HDR_H/* Include headers */#ifdef __cplusplusextern &quot;C&quot; &#123;#endif /* __cplusplus *//* File content here */#ifdef __cplusplus&#125;#endif /* __cplusplus */#endif /* TEMPLATE_HDR_H */\n\n\n\nArtistic style configurationAStyle is a great piece of software that canhelp with formatting the code based on input configuration.\nThis repository contains astyle-code-format.cfg file which can be used with AStyle software.\nastyle --options=&quot;astyle-code-format.cfg&quot; &quot;input_path/*.c,*.h&quot; &quot;input_path2/*.c,*.h&quot;\n\nEclipse formatterRepository contains eclipse-ext-kr-format.xml file that can be used witheclipse-based toolchains to set formatter options.\nIt is based on K&amp;R formatter with modifications to respect above rules.You can import it within eclipse settings, Preferences -&gt; LANGUAGE -&gt; Code Style -&gt; Formatter tab.\n"},{"title":"PT协程的一个小扩展","url":"/2023/08/28/PT%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%89%A9%E5%B1%95/","content":"在之前的文章中介绍了使用链表来更加优雅的使用PT协程。我最近发现了当初实现的一个错误，现在已经修复了。\n这里不是为了讨论之前的实现，而是介绍一个更有意思的东西。我在之前的实现基础上，实现了一个更加优雅的函数来利用协程，这应该是一种异步编程的技巧，或者说这是C语言的花活😂。\nShow code!\n/** * Declare a pt thread in a simple way. *  * Example usage: * @code&#123;c&#125; * PT_THREAD_DECL(thread1, &#123; *     while(1)&#123; *         printf(&quot;hello pt!\\r\\n&quot;); *         OS_TASK_DELAY(pt, 100); *     &#125; * &#125;); *  * // OS_TASK_RUN(thread1); * @endcode */#define PT_THREAD_DECL(name, body) \\    PT_THREAD(name(struct pt *pt))&#123;PT_BEGIN(pt);PT_YIELD(pt);body;PT_END(pt);&#125;/**  * Asynchronous execution. Only used in threads, similar to OS_TASK_DELAY() function. *  * Example usage: * @code&#123;c&#125; * PT_THREAD_DECL(invok_test, &#123; *     static int cnt; *  *     cnt = 0; *  *     PT_INVOK(&#123; *         static int i; *         for(i = 0; i &lt; 10; i++)&#123; *             printf(&quot;async invok %d\\r\\n&quot;, i); *             cnt += i; *             OS_TASK_DELAY(pt, 1000); *         &#125; *         // Automatically exit this asynchrony at end of PT_INVOK(); *     &#125;); *  *     PT_INVOK(&#123; *         while(1)&#123; *             printf(&quot;hello invok, cnt = %d\\r\\n&quot;, cnt); *             OS_TASK_DELAY(pt, 300); *         &#125; *     &#125;); * &#125;); *  * // OS_TASK_RUN(invok_test); * @endcode */#define PT_INVOK(body)                             \\    do                                             \\    &#123;                                              \\        static pt_item_t pt_invok;                 \\        static char pt_anchor;                     \\        pt_invok.task =                            \\            containerof(pt, pt_item_t, pt)-&gt;task;  \\        list_add_head(&amp;pt_pool, &amp;(pt_invok.list)); \\        pt_anchor = 0;                             \\        LC_SET(pt_invok.pt.lc);                    \\        if (pt_anchor)                             \\        &#123;                                          \\            body;                                  \\            PT_EXIT(pt);                           \\        &#125;                                          \\        pt_anchor = 1;                             \\    &#125; while (0)\n\nPT_INVOK可以在不阻塞当前函数执行流程的情况下，从原地开辟出一个并行的执行流，有意思的一点是多个INVOK执行流之间是可以共享上层局部变量的，这就实现了多个执行流之间的通信或同步。\n这个宏扩展看起来相当的有用，它解决了编程中一个常见的问题，即在一个不能被阻塞的执行流程中执行一个耗时的操作。\nPT协程的实现本身就是一个很花哨东西，这个宏定义成功的把C语言的宏用法上升到了一个新的高度。我怀疑某些编译器根本不能处理这段代码😅。\n这里需要注意，PT_INVOK内的代码不能重入，或者说PT_INVOK内的代码还未执行完成时，不能再次在这里执行同一段PT_INVOK，这是代码的静态性导致的。如果有重入的风险，可以在外部添加一些重入保护的机制。\n"},{"title":"STM32H7性能问题优化实践","url":"/2024/03/07/STM32H7%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","content":"最近开发一个项目，采用STM32H7单片机，遇到了一个我以前没有遇到过的一个性能问题，通过分析解决该问题的过程让我对STM32高性能数据传输有更加深刻的理解。\n\n关键字：总线、DMA、FIFO\n\n\n项目背景某项目开发中需要将Linux的数据通过USB传输到单片机，数据在单片机中经过适当的处理后再将数据传输到硬件外设上。\n第一次性能瓶颈 - USBUSB的理论带宽有480MHz，使用批量传输模式可实现较高的传输速度。最开始选用的是Tinyusb协议栈，在使用了一段时间后才发现该协议栈不支持DMA，这导致在进行高带宽数据传输时导致CPU占用非常高，接近40%的CPU资源都用于协议栈传输数据。过高的CPU占用将会为后续的数据处理阶段带来较大的隐患，所以必须要解决DMA支持的问题。\n将协议栈更换为CherryUSB后，DMA的问题解决了。在CPU仅占用1%的情况下，可达到30MB/s的传输速度。\n内存带宽限制最开始我认为将USB的数据缓存放在靠近USB外设的区域，也就是AHB总线矩阵附近会有更多优势，但是我却忽略了一个带宽问题。这里的内存带宽是32bit的，在后续数据处理阶段，CPU访问这里的数据会有一定的性能瓶颈。将USB的缓存切换到AXI矩阵下，CPU的处理性能提高了一倍，且对USB的传输性能基本上没有太大的影响。\n除了带宽问题外，AHB矩阵下的Cache策略也有一定的影响，这里是关闭了DCache的。将数据缓存放到AXI-SARM后也需要面临DCache的问题。\n这里有两个选择，1：开启DCache，但是需要在适当的时候进行内存同步。2：关闭该区域的DCache，这样不需要额外的内存同步操作。分别测试了两种情况，最终开启DCache的方案性能要好得多(优50%以上)。这看起来是不太合理的，因为这里涉及到了USB的DMA，该区域的Cache特性反而是一种负担。但是关闭Cache后性能却大受影响。\n外设传输性能的优化将数据传输到外设中基本上没什么特别的选择，只有DMA能够胜任。但是在落实到具体的配置上有很多优化的地方需要注意，这都是影响性能的关键点。\n外设上的FIFO，我最开始并没有意识到外设FIFO的作用，因为这里已经使用了DMA，外设上的FIFO作用并不明显。但该FIFO能够提高总线的利用率，通过FIFO缓存数据后，可用将数据位宽进行压缩传输，目标外设为16bit时，通过将两次传输压缩为32bit进行一次传输到FIFO内，从而提高传输性能。\n此外，利用DMA上的FIFO配合突发模式能够进一步提高传输性能，这对总线性能提高非常明显，因为前面的USB数据和该外设数据会经过同一条数据总线，使用突发模式传输数据可用在适当情况下避免总线发生抢占而导致CPU或USB发生不必要的等待。总线上的访问模式优化将系统的整体性能提高了10%，效果非常的明显。\n数据处理上需要注意的地方本次开发过程中涉及到了许多的非完整宽度的数据类型，例如12bit、14bit的有符号数，在C语言中一般使用位域能够非常轻松的处理这种数据类型。但是在实践的过程中发现，使用位域赋值时会存在一定的性能问题，导致数据处理的效率降低。因为处理器每次对一个非完整宽度的数据赋值时需要先从内存中加载一部分数据，这可能导致不必要的内存IO开销，因为LDR、STR指令是拖慢系统运行的关键因素。在算法的实践中需要减少IO的访问，将一部分数据算法使用寄存器进行处理，之后再将寄存器的数据写入到内存中。\n在开发C代码过程中，可能很多人无法靠直觉想到一段C代码有多少LDR、STR指令，但在经过一定程度的练习后还是能够这种天赋的。推荐一个网站Compiler Explorer ，该网站能够将C代码转为汇编，并提供可选的编译选项，可以作为学习的平台和工具。想要编写出真正的高性能代码，掌握基本的汇编语言也是比不可少的，理解各种汇编指令的时钟周期对编写高性能代码更加重要，这里就不展开了。\n总结单片机内部数据总线在平时开发过程中并没有特别注意，因为没有直接对内核或外设产生影响，但是在面临大数据带宽、多个外设并行时，合理的配置以优化总线的利用将有助于系统整体的优化。在本次开发过程中，还研究了总线矩阵上的一下其它配置，如Qos、总线优先级等等，但由于本次开发时间有限且项目已满足设计要求，没有进一步的深入探究，在这些地方应该还有优化的空间。\n"},{"title":"SVC系统调用的编程使用方法","url":"/2021/11/06/SVC%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"SVC称为系统服务调用(SuperVisorCall)，异常类型为11，通过svc指令可用触发异常，SVC在触发异常后必须立即得到相应(触发异常后在执行异常前不能执行其它代码)，除非有更高优先级的异常在执行。\n对于可靠系统而言，可以使用SVC异常实现资源的特权访问，使系统更加安全。通过SVC系统调用编号能够实现参数传递，从而实现不同功能的系统服务。使用系统服务可以不需要知道具体服务函数的地址，这样能够隐藏更多的细节，降低软件间的耦合性。\n在ARM开发工具链下，有比较优雅的方式直接使用SVC异常，在GCC下需要配合汇编来使用。\n这里不讨论ARM处理器对于异常的处理机制，它在触发SVC指令后响应的异常行为与系统中其它异常是一致的。\nSVC异常处理  .syntax unified  .thumb  .global SVC_Handler  .global SVC_VIRTUAL_CALL_0  .global SVC_VIRTUAL_CALL_1  .global SVC_VIRTUAL_CALL_2  .global SVC_VIRTUAL_CALL_3  .type SVC_Handler, %function  .type SVC_VIRTUAL_CALL_0, %function  .type SVC_VIRTUAL_CALL_1, %function  .type SVC_VIRTUAL_CALL_2, %function  .type SVC_VIRTUAL_CALL_3, %functionSVC_Handler:  tst lr, #4  ite eq  mrseq r0, msp  mrsne r0, psp  push &#123;r6, r7, lr&#125;  mov r7, r0  ldr r0, [r7, #0]     //原始R0  ldr r1, [r7, #4]  ldr r2, [r7, #8]  ldr r3, [r7, #12]  ldr r6, [r7, #24]    //svc指令相关的pc地址  ldr r6, [r6, #-2]  and r6, #0xFF  ldr r12, =g_svc_vector  ldr r6, [r12, r6, lsl #2]  blx r6  str r0, [r7, #0]  pop &#123;r6, r7, pc&#125;Default_SVC_Handler:  bx lr  .align 2g_svc_vector:  .word SVC_HANDLER_0  .word SVC_HANDLER_1  .word SVC_HANDLER_2  .word SVC_HANDLER_3    .weak      SVC_HANDLER_0  .thumb_set SVC_HANDLER_0, Default_SVC_Handler  .weak      SVC_HANDLER_1  .thumb_set SVC_HANDLER_1, Default_SVC_Handler  .weak      SVC_HANDLER_2  .thumb_set SVC_HANDLER_2, Default_SVC_Handler  .weak      SVC_HANDLER_3  .thumb_set SVC_HANDLER_3, Default_SVC_HandlerSVC_VIRTUAL_CALL_0:    svc 0    bx lrSVC_VIRTUAL_CALL_1:    svc 1    bx lrSVC_VIRTUAL_CALL_2:    svc 2    bx lrSVC_VIRTUAL_CALL_3:    svc 3    bx lr\n\nSVC_Handler函数是异常处理函数，进入函数，判断LR寄存器来分析进入异常前的环境，获取到对应的sp地址。通过sp寄存器就能访问到栈空间，在栈中可以获取到r0-r3，这个就是执行svc时传进来的参数，通常这4个寄存器不会被修改，除非发生了更高优先级的异常。通过在栈中获取到执行svc的pc指针，得到svc指令的二进制码，低8位存储了指令附加的异常id，使用该id在内部通过查表的方式定位具体需要执行的函数入口，执行指定的函数后，我们将r0也就是返回值存储到栈空间中，这样返回到用户态后，用户就能获得执行目标函数后返回结果。\n为了方便定义用户系统调用函数，设计了这样的一个宏。\n#define SVC_CALL_DEF(id, func, ret_t, ...) \\extern ret_t SVC_VIRTUAL_CALL_##id(__VA_ARGS__); \\ret_t SVC_HANDLER_##id(__VA_ARGS__)\n其中id表示该函数绑定到svc的那一个系统调用上，func表示函数名称，ret_t和后面的参数分别表示函数的返回值和形参列表，如果无形参则填入void。通过 SVC_VIRTUAL_CALL_id()来执行系统调用。\n这是一个简单的例子：\nSVC_CALL_DEF(1, test_svc_add, int, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = SVC_VIRTUAL_CALL_1(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n\n进阶写法前面的定义方法和调用方法与传统的C语言函数定义和函数调用存在区别，所以在使用上存在不方便的地方，按照下面的写法更加合理，且函数调用与C语言是一致的，减低了代码移植上的一致性问题。\n#ifndef __SVC_HANDER_H#define __SVC_HANDER_H#if defined(__GNUC__)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__); \\    __asm__(        \\        &quot;.thumb\\n&quot;  \\        &quot;.global &quot; #name &quot;\\n&quot; \\        &quot;.type &quot; #name &quot;, %function\\n&quot; \\        #name &quot;:\\n&quot; \\        &quot;svc &quot; #id &quot;\\n&quot; \\        &quot;bx lr\\n&quot;); \\    ret_t SVC_HANDLER_##id(__VA_ARGS__)#elif defined(__CC_ARM)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t __svc(id) name(__VA_ARGS__)#else#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__)    // #warning &quot;not support SVC function!&quot;#endif#endif\n\n有了这个宏定义后，定义一个svc函数以及函数的调用写法将变为：\nDEF_SVC_FUNC(2, int, add_func, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = add_func(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n这样的写法能够兼容不同的编译器，且不用提前定义SVC_VIRTUAL_CALL_0函数。\n"},{"title":"FreeRTOS内核窥探","url":"/2024/01/06/FreeRTOS%E5%86%85%E6%A0%B8%E7%AA%A5%E6%8E%A2/","content":"\n在多任务环境下调试代码需要一定的代码调试经验，尤其是涉及到异步的任务流程时，单步执行可能无法跟踪到需要的执行流程。如果代码全速运行时虽然可以通过日志来梳理执行流程，但是涉及到FreeRTOS内核中的内容时，一般的日志显得比较鸡肋了。比如说我想检查某个时刻所有任务的运行状态，包括任务是运行还是阻塞、阻塞的延时有多久、阻塞在某个信号量上等等，或者更进一步检查任务的调用栈等等。如果能够实现这些功能来窥视FreeRTOS的运行过程，这显然能够帮助我们更加清晰的了解代码的运行过程，方便解决一些棘手的问题。\n\n获取当前系统所有任务的详细信息FreeRTOS提供了uxTaskGetSystemState()方法，可以获取所有任务的一些简单信息，主要包括任务的TCB句柄、任务名称、运行状态、优先级、栈起始地址已经栈空间的最大使用量。这些信息是FreeRTOS直接暴露出来的信息，但是这些信息并不能够方便我们了解任务的运行过程，尤其是任务的细节状态。\n我们想要获取的关键详细信息包括任务当前的SP指针，即实时的栈地址。还需要获取任务的阻塞时长，主要是对于处于阻塞状态的任务来说的。最关键的是需要获取任务阻塞的事件是什么，一般在RTOS中会使用很多的信号量、邮箱等同步机制，如果系统假死后能够看到每个任务的阻塞情况，那么可以最大程度的方便我们定位故障点。\n非常遗憾的是以上这些信息都不能显式的从某个内核接口中获取，同时FreeRTOS执行非常严格数据隐藏策略，外部的应用代码是无法直接访问FreeRTOS内核的数据以及数据结构。但是FreeRTOS为开发人员预留了一组虚拟数据结构的定义，该虚拟数据结构的形式同FreeRTOS中实际的数据结构是一致的，FreeRTOS的初衷是通过这些虚拟结构来计算内核数据结构的大小，但是我们在这里通过这些数据结构的索引就能够突破内核的数据隐藏策略来间接访问内核数据。\n虚拟数据结构的定义都是形如“struct xSTATIC_xxx”的定义，都位于FeeRTOS.h文件中。获取任务的SP指针现在就很容易了，SP指针的值位于TCB数据结构的第一项，虽然不能直接使用TCB的数据结构，但是struct xSTATIC_TCB的结构同它是一致的，所以我们访问任务SP指针的方法是这样的：\nvoid * pvGetTaskMSP(TaskHandle_t xTask)&#123;    return ((StaticTask_t*)(xTask))-&gt;pxDummy1;&#125;\n\n任务需要阻塞多长的时间？这个问题稍微复杂一点，首先这个问题仅仅针对处于阻塞状态的任务，尤其是有限时长阻塞状态的任务。看看vTaskDelay()中的实现，当一个任务需要阻塞时，就将其放入到等待任务列表中，通过函数prvAddCurrentTaskToDelayedList()实现的。首先将当前时刻和需要延时的时长进行计算得到唤醒的时刻，将该时间点记录到任务的xStateListItem变量内部，同时该函数将xStateListItem变量作为一个列表项插入到了pxDelayedTaskList链表的中，这是一个有序的插入过程，即根据任务唤醒时间在链表上进行排序，到这里都比较好理解。通过任务TCB的xStateListItem就能够得到任务延时的时间。但是这里最关键的一点来了，如果任务时无限时长阻塞呢？这种情况是将变得比较麻烦，内核的实现是将其放入到了挂起任务列表(xSuspendedTaskList)中了，我们无法直接访问到xSuspendedTaskList，怎么确定任务是否处于无限阻塞状态呢？\n到这里我确实没有比较好的办法，我选择直接修改内核代码，将处于挂起任务的xStateListItem值设为最大值以标记该任务没有明确的唤醒时间，这里需要思考有没有更简单的方法。\nif( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )&#123;    /* Add the task to the suspended task list instead of a delayed task     * list to ensure it is not woken by a timing event.  It will block     * indefinitely. */    listINSERT_END( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );    listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), 0xffffffff );&#125;\n\n任务等待的事件是什么？不是所有在阻塞的任务都在等待事件，如果任务只是一般的延时，这就表明任务没有等待任何事件。任务的事件机制是依靠TCB中xEventListItem来实现的，比如说等一个任务等待一个队列(queue)，任务就将该TCB中的xEventListItem加入到该队列内部相关的一个链表上。FreeRTOS中的队列(queue)用来实现消息队列、邮箱、信号量等，queue内部有两个链表，一个等待接收链表、一个等待发送链表，这是FreeRTOS内核允许发送数据阻塞导致的，所以队列内部需要两个链表来维护任务的阻塞关系，但实际上这两个队列大多数情况是仅使用其中一个。\n通过xEventListItem中的pxContainer可以反向定位到任务所关联的链表，但是问题来了，queue上有两个链表，我们怎么确定任务所属的链表到底是哪一个呢？因为不能确定的话就不能反向索引到queue的指针，如果假设任务所述链表是queue内的第一个链表，通过containerof方法就能够定位到queue的地址，但万一是另一个链表呢？\n队列中预留了一个有意思的成员uxQueueNumber，它并没有实际的功能，但通过它我们就能够将队列打上特殊标记，进而检索出队列的地址，找到了任务等待的队列地址，这样就确定了任务到达在等待什么事件了。\n#define QUEUE_TRACK_FLAG (0xab123456)void vQueueFlagSet(void* queue)&#123;    vQueueSetQueueNumber((QueueHandle_t)queue, QUEUE_TRACK_FLAG);&#125;void *pvGetTaskEvent(TaskHandle_t xTask, int *type)&#123;    List_t * const pxList = ((StaticTask_t*)(xTask))-&gt;xDummy3[1].pvDummy3[3];    if(pxList == NULL)&#123;        *type = 0;  // no event        return NULL;    &#125;    StaticQueue_t *queue = containerof(pxList, StaticQueue_t, xDummy3[0]);    if(uxQueueGetQueueNumber((QueueHandle_t)queue) == QUEUE_TRACK_FLAG)&#123;        *type = 1;        return queue; // wait tx    &#125;    queue = containerof(pxList, StaticQueue_t, xDummy3[1]);    if(uxQueueGetQueueNumber((QueueHandle_t)queue) == QUEUE_TRACK_FLAG)&#123;        *type = 2;        return queue; // wait rx    &#125;    *type = 3; // unknow    return NULL;&#125;\nvQueueFlagSet()方法需要使用queue的创建HOOK进行调用，这样内核上创建的所有queue都将被打上特殊标记以方便我们跟踪。\n分析队列事件上面得到的仅仅是队列的地址，队列的详细信息其实也能够获取到，包括该队列的类型(一般队列、互斥量、计数信号量、二进制信号量)、等待该队列事件的其它所以任务列表以及该队列内部数据量、数据尺寸的信息等待。方法任然是通过内核上的虚拟数据结构来间接访问。\n利用SP指针回溯调用栈最前面我们获取到了任务的SP地址，这是任务在丢失CPU执行权限后由内核任务调度器更新的最新的SP地址，所以它不是简单的SP指针，因为栈内还有任务调度时保存的数据。\n分析调用栈除了需要实际的sp指针外，还需要最近一次的PC指针、LR指针。内核调度器在最后时刻将R4-R11寄存器、R14寄存器存入了栈内，如果还有浮点数，这还保存了S16-S31这16个浮点数寄存器。\n简单来说，可以简化为两个结构体\ntypedef struct&#123;    uint32_t r4[8];    uint32_t r14;    uint32_t s16[16];    uint32_t r0[4];    uint32_t r12;    uint32_t lr;    uint32_t pc;    uint32_t xPSR;    uint32_t s0[16];    uint32_t fpscr;&#125; rtos_cm7_msp_fp_t;typedef struct&#123;    uint32_t r4[8];    uint32_t r14;    uint32_t r0[4];    uint32_t r12;    uint32_t lr;    uint32_t pc;    uint32_t xPSR;&#125; rtos_cm7_msp_t;\n\n如果存在浮点数则使用rtos_cm7_msp_fp_t，如果不存在浮点数则使用rtos_cm7_msp_t，是否使用浮点数可以使用r14进行判断，这里的r14就是FreeRTOS进行到任务调度时的异常中断中的LR寄存器。有了这个数据结构，再配合栈分析机制就能够非常方便的得到任务的调用栈了。\n总结通过以上的方法，我们就能够非常方便的分析出FreeRTOS运行时的细节信息了，配合日志系统或者shell功能在适当的时候检索出这些信息对分析实时运行过程比较方便。此外，UCOSII等操作系统也能实现类似的操作。\n"},{"title":"Exception Failure - Breaking the STM32F1 Read-Out Protection","url":"/2022/03/28/Exception%20Failure%20-%20Breaking%20the%20STM32F1%20Read-Out%20Protection/","content":"Marc Schink &amp; Johannes Obermaier Tuesday, 17 March 2020\n\nThe firmware of microcontrollers usually contains valuable data such as intellectual property and, in some cases, even cryptographic material. In order to protect the confidentiality of these assets, most microcontrollers feature some kind of firmware read-out protection. This security feature shall prevent adversaries with physical access to a device from reading out the internal flash memory. Nevertheless, security researchers as well as hobbyists showed repeatedly that these security features can be circumvented. In this research article, we examine the flash read-out protection (RDP) of the STM32F1 series from STMicroelectronics. We discuss a novelly discovered vulnerability whose exploitation would be the first non-invasive way to circumvent the feature. The issue results from an insufficient access restriction: flash data reads via the debug interface are blocked but the CPU’s exception handling process is still able to read from flash memory via the ICode bus. We explain in detail why and how this vulnerability exposes major parts of the internal memory, thereby affecting device security.\n\n\n\n\n\nIntroductionFor the protection of intellectual property and other sensitive data such as cryptographic material, securing the internal flash memory of a microcontroller is of utmost importance. If an attacker gains access to the firmware, they can clone the product, alter its functionality or extract security credentials. Thus, the hardening of microcontroller plays a major role in today’s embedded system security — not only for high-security devices but also for commercial microcontrollers.\nThe deactivation of the debug interface is one usual way to prevent adversaries from gaining access to the flash memory, however, the implementation differs between microcontrollers. For example, the debug interface of the STM32F0 series can be entirely switched off. In contrast, the STM32F1 series does not directly support this, but relies on another approach. One of its main security features is the flash memory read-out protection (RDP). This security feature blocks all data accesses to the flash memory via the debug interface once a debug probe is attached to the microcontroller. This means that an attacker is able to attach a debug probe to the microcontroller but cannot read out the flash memory content.\nHowever, research has shown for some microcontrollers that this protection mechanism is flawed. For the STM32F0 series, for instance, Johannes Obermaier and Stefan Tatschner presented an attack in Shedding too much Light on a Microcontroller’s Firmware Protection that is able to extract protected data from flash memory. Some researchers assumed that this vulnerability might also affect other series such as the STM32F1. However, one of the authors contradicted that the STM32F1 microcontroller family exhibits the same vulnerability in the debug interface. Until now, the flash read-out protection mechanism of the STM32F1 series was considered as being secure and there was no evidence that it can be circumvented. In this article, we discuss a vulnerability (CVE-2020-8004) that leads to the first non-invasive attack against the flash protection mechanism of the STM32F1 family.\nDiscovering the VulnerabilityThe STM32F1 series does not provide a feature to permanently disable the debug interface. For that reason, an attacker with physical access to the debug interface is always able to gain debug access to the microcontroller. However, the integrated flash read-out protection prevents any data access to the flash memory once a debug probe is attached to the microcontroller.\nIn order to examine the flash read-out protection feature, we use an STM32 Nucleo-64 development board with an STM32F103RB microcontroller. The read-out protection of the microcontroller is enabled which means that the flash memory is not accessible via the debug interface. The microcontroller is attached via the SWD debug interface to an external SEGGER J-Link debug probe, as depicted in Figure 1.\n\n\n Figure 1: STM32 Nucleo-64 development board with attached SEGGER J-Link debug probe.\n\n\nWe begin our examination by establishing a debug connection to the target microcontroller. For that, we start OpenOCD with the following command:\nopenocd -f interface/jlink.cfg -c &quot;transport select swd&quot; -f target/stm32f1x.cfg\n\nAfter that, we open a Telnet session on OpenOCD such that we can control the microcontroller. Finally, we perform a device reset with the command and get the following output in our Telnet session:reset halt\ntarget halted due to debug-request, current mode: ThreadxPSR: 0x01000000 pc: 0x08000268 msp: 0x20005000\n\nAt a first glance, there is nothing special with this output. However, when you take a closer look at the second line, especially one value should pop into your eyes: the program counter (PC) value is a valid address located in flash memory. This is of major importance because a reset is a special kind of exception. Every time an exception is generated, the processor loads the corresponding exception entry address from the vector table into the PC. This procedure is sometimes referred to as vector fetch. After a device reset, the vector table is located in flash memory. Hence, this observation implies that the processor fetches the reset vector from flash memory even though the read-out protection is enabled.0x08000268\nBut why is the exception entry process able to read the reset vector from flash memory? The STM32F1 reference manual provides a hint:\n\nThe Cortex®-M3 CPU always fetches the reset vector on the ICode bus, which implies to have the boot space available only in the code area (typically, Flash memory).\n\nThe reset vector is fetched via the ICode bus and thus handled like instruction fetches which are allowed despite the activated read-out protection. The read-out protection seems to take care of data accesses via the data bus (DCode bus) only and hence the reset vector can still be fetched over the ICode bus. The Cortex-M3 Technical Reference Manual provides additional information regarding vector fetches in general:\n\nThe vector fetch is performed over either the System bus or the ICode bus depending on where the vector table is located […]\n\nIn summary, the flash read-out protection of the STM32F1 does not block memory accesses via the ICode bus. Once an exception takes place, the corresponding entry address stored in flash memory is fetched through the ICode bus and thereby exposes the memory content through the PC.\nExploitationOur observation shows that once an exception takes place, the vector fetch exposes protected flash memory content through the PC. In this section, we discuss how this behaviour can be exploited to bypass the read-out protection of the STM32F1.\nWe already mentioned the vector table: it contains the initialization value of the main stack pointer (MSP) followed by an entry address for every exception. The vector table for microcontrollers based on the ARMv7-M architecture is shown in Table 1. The table lists the exceptions with their memory offset relative to the beginning of the vector table. The first 16 exceptions of the vector table are mandatory and specified by the ARMv7-M architecture. All other exceptions are so called external interrupts, they are optional and device specific.\n\n\n\n\n\nException number\nException\nOffset\n\n\n\n-\nMain stack pointer (MSP) initialization value\n0x0\n\n\n1\nReset\n0x4\n\n\n2\nNMI\n0x8\n\n\n3\nHardFault\n0xc\n\n\n4\nMemManage\n0x10\n\n\n5\nBusFault\n0x14\n\n\n6\nUsageFault\n0x18\n\n\n7-10\nReserved\n0x1c\n\n\n11\nSVCall\n0x20\n\n\n12\nDebugMonitor\n0x24\n\n\n13\nReserved\n0x28\n\n\n14\nPendSV\n0x2c\n\n\n15\nSysTick\n0x30\n\n\n16\nExternal Interrupt 0\n0x34\n\n\n…\n…\n…\n\n\n\n\nTable 1: Vector table for microcontrollers implementing the ARMv7-M architecture.\n\n\nThe basic exploitation idea is to deliberately generate exceptions such that the corresponding vector table entry is fetched from flash memory and exposed through the PC. However, Table 1 shows that some entries are reserved and are not mapped to an exception, namely the entries 7 to 10 and 13. Also needless to say, the initialization value for the MSP is not mapped to an exception. For that reason, the corresponding table entries cannot be extracted via this approach. We ignore this for the moment and address these limitations in more detail later in this article.\nVector Table OffsetAt this point, the following question may arise: why should I care about the confidentiality of the vector table content?\nIndeed, the content of the vector table is usually not confidential as it only contains the exception entry addresses. But note that the ARMv7-M architecture specifies a Vector Table Offset Register (VTOR) that determines the location of the vector table inside the address space. This feature is usually used to relocate the vector table when there are multiple applications on the microcontroller, for example, a bootloader and a main application. With that, both applications can have their own vector table and exception handlers. The crucial point here is again, that we have debug access to the entire device except for the flash memory. With help of the VTOR, we are able to relocate the vector table within the flash memory region and extract large amount of its data.\nIn order to use the vector table relocation, we split the flash memory into equally sized blocks of 32 words, as depicted in Figure 2. The block size is related to the vector table size and, as required by the ARMv7-M specification, must be a power of 2. For example, the STM32F103 has 59 exceptions and therefore the actual vector table size is 64. However, this means that we do not have enough exceptions to access all its table entries. For that reason, we use the largest possible vector table that fits in 59 which is 32.\n\n\nFigure 2: Relocation of the vector table within the flash memory. Inaccessible table entries are highlighted.\n\n\nThe seven highlighted memory words in Figure 2 cannot be extracted. The first two words are the initialization value for the MSP and the reset vector. The other words correspond to the reserved entries of the vector table. The MSP initialization value and the reset vector are special and can only be extracted when the vector table is located at the beginning the of the flash memory, its default location. The reason is that a device reset is necessary to extract these value, however, this also resets the VTOR and relocates the vector table to the beginning of the flash memory region.\nThese limitations can be reduced by using exceptions that exceed the vector table size. In this case, exceptions with a number greater than 31. According to section 4.4.4 of the STM32F1 programming manual, the vector table location must be aligned to the actual vector table size, 64 in case of the STM32F103. But what happens when our vector table is unaligned and we generate exceptions with numbers greater than the vector table size? It turns out that these exceptions are mapped to the beginning of the vector table. Figure 3 illustrates this wrap-around behaviour for an unaligned vector table with 32 entries. On the left-hand side, the regular vector table with its inaccessible entries highlighted is depicted. On the right-hand side, the figure shows how the wrap-around behaviour makes the inaccessible parts of the vector table accessible. The highlighted vector table entries are now accessible by exceptions that exceed the vector table size.\n\n\nFigure 3: Wrap-around behaviour of an unaligned vector table. Inaccessible entries (red) become accessible (blue) when an exception exceeds the table size.\n\n\nNote that in Figure 3, the focus is on the inaccessible parts of the vector table. The other entries can also be extracted via the wrap-around behaviour, however, this is not necessary since they can be extracted regularly. With the help of the wrap-around, we are now able to extract vector table entries that were reserved or inaccessible before. Even the first two entries which were only extractable when the vector table is located at the beginning of the flash memory region. The only limitation that remains is that we can use this approach only for unaligned vector tables. Nevertheless, we reduced the number of inaccessible memory words by a factor of two. Note that this approach is one way to make use of the additional external interrupts. We use this way because it is very convenient to implement.\nNow, we have almost everything we need to extract nearly arbitrary parts of the flash memory. In the next section, we describe the last missing piece: how to generate exceptions on purpose.\nException GenerationTo generate each individual exception for firmware extraction, we continue as follows. We need three steps to trigger an exception:\n\nPerform a device reset such that the microcontroller is in a defined state and to recover it from possible faults and lockups.\nConfigure the microcontroller such that the indented exception is pending.\nPerform a single step to make the pending exception active.\n\nThe Non-Maskable Interrupt (NMI), PendSV and SysTick exception can easily made pending by setting the corresponding bits , and respectively. These bits can be found in the Interrupt Control and State Register (ICSR). The same holds for the DebugMonitor exception which can be made pending by setting the bit in the Debug Exception and Monitor Control Register (DEMCR).NMIPENDSETPENDSVSETPENDSTSETMON_PEND\nFor example, the following OpenOCD commands makes the PendSV exception pending:\nmww 0xe000ed04 0x10000000\n\nSince the processor is in debug mode and halted, we need to give it the chance to execute the exception. For that, we use the command to execute only a single instruction. In order to avoid side-effects by the executed instruction, we execute a single instruction placed in SRAM at address .stepnop0x20000000\nmwh 0x20000000 0xbf00reg pc 0x20000000\n\nNote that it is necessary to disable interrupt masking. This feature is enabled by default and can be deactivated with the following command:\ncortex_m maskisr off\n\nThis command changes the single-stepping behaviour and controls the bit in the Debug Halting Control and Status Register (DHCSR). This bit determines whether PendSV, SysTick and all external interrupts shall be masked. By default, is set to auto which means that a command first allows pending interrupt handlers to execute and then steps over the desired instruction.C_MASKINTSmaskisrstep\nNote\nThe command is not available for so called high-level adapters (HLA) in OpenOCD. For that reason, we do not use the integrated ST-LINK debug probe of the Nucleo-64 development board.maskisr\nOnce an exception is generated, you may experience that there is a mismatch between the exception entry address in the vector table and the PC value. The least-significant bit (LSB) may be incorrect. The reason is that the LSB of the exception entry address is not loaded into the PC but used as Thumb state of the processor. Since the Thumb state is encoded in the Execution Program State Register (EPSR), we are able to recover the entire exception entry address by combining the PC and the Thumb state bit.\nWe have all building blocks required to extract vector table entries. In the following, we elaborate how to generate the remaining exceptions. For simplicity, we omit the first and last step of the exception generation process throughout the remainder of this article.\nBusFaultA BusFault exception occurs, for example, when a memory instruction accesses an invalid memory region. Hence, we can generate a BusFault by executing a load instruction that performs a read access on an invalid memory region.\nFor that, we place an into the SRAM at address and configure the base register and the PC accordingly:ldr r0, [r1, #0]0x20000000r1\nmwh 0x20000000 0x0868reg r1 0xf0000000reg pc 0x20000000\n\nThe address stored in is part of the vendor-specific memory region. In case of the STM32F1, this address is not mapped in the memory space. Therefore, every memory operation on this address is illegal and thus suitable to generate a BusFault exception. All other addresses that are not mapped work as well.0xf0000000r1\nBefore we are able to generate a BusFault exception, we need to enable it by setting the bit in the System Handler Control and State Register (SHCSR):BUSFAULTENA\nmww 0xe000ed24 0x20000\n\nThis step is necessary because otherwise priority escalation would take place and the processor would generate a HardFault exception instead of a BusFault.\nMemManageThe MemManage exception is generated whenever a memory protection fault occurs. Among others, this happens when the processor attempts to execute code in a memory region that is marked as eXecute Never (XN).\nIn order to cause a memory protection violation, we configure the processor such that it attempts to execute code on a memory region marked as XN. In our case, we chose the first address of the system memory address space which is at the address .0xe0000000\nreg pc 0xe0000000\n\nAs for the BusFault exception, the MemManage exception needs to be enabled. We do this by setting the bit in the SHCSR:MEMFAULTENA\nmww 0xe000ed24 0x10000\n\nUsageFaultUsageFault exceptions can occur for a variety of reasons. One reason is, for example, when an unaligned memory load or store operation is performed.\nHowever, the straightforward way is to execute an undefined instruction such as . We place this instruction in SRAM at address and configure the PC accordingly:0xffff0x20000000\nmwh 0x20000000 0xffffreg pc 0x20000000\n\nAs for the other exceptions, the UsageFault exception needs to be enabled. This can be done by setting the bit in the SHCSR:USGFAULTENA\nmww 0xe000ed24 0x40000\n\nHardFaultA HardFault is a generic fault that is generated whenever a fault cannot be handled by any other exception.\nThere are different means to generate a HardFault exception manually. A straightforward way is to generate one of the previously mentioned exceptions without enabling it. As explained before, this causes a priority escalation and the HardFault exception gets generated.\nSVCallA Supervisor Call (SVCall) is used by software to call the operating system. This exception is generated whenever the processor executes an instruction.svc\nWe generate this exception by placing an instruction in SRAM and execute it with a single step.svc #0\nmwh 0x20000000 0xdf00reg pc 0x20000000\n\nSince we are only interested in generating an SVCall exception, the immediate value is not important and can be arbitrarily chosen. In contrast to the former two exceptions, a supervisor call is permanently enabled.#imm\nExternal InterruptsThe Nested Vectored Interrupt Controller (NVIC) handles all the external interrupts. It provides two set of registers: one to enable external interrupts and a second one to make them pending. In order to trigger an external interrupt, we set the corresponding bits in both registers to enable the interrupt and make it pending. Every bit corresponds to an external interrupt.\nFor example, in case of the STM32F1 series, the first external interrupt is the window watchdog (WWDG) interrupt. In order to trigger this interrupt, we set the first bit in both registers:\nmww 0xe000e100 0x1mww 0xe000e200 0x1\n\nAll other external interrupts can be generated accordingly.\nThe number of external interrupts varies a lot among the different devices of the STM32F1 family. Additionally, the documentation is sometimes not accurate. For example, according to the STM32F1 reference manual, the external interrupts 43 to 49 of connectivity line devices are reserved. However, we found out that they can be generated like all the other interrupts. The importance of the available external interrupts will be seen in the next section.\nPerformanceThe amount of extractable memory content and the extraction speed are key indicators whether the identified vulnerability undermines the security of the read-out protection in field applications.\nIn order to asses the severity of this vulnerability, we implemented a Python script that generates exceptions in an automated fashion to extract firmware from a read-out protected microcontroller. We evaluated the presented attack on three different devices of the STM32F1 series. In all cases, we aimed to extract 128 KiB of flash memory from the devices. The evaluation results are listed in Table 2.\n\n\n\n\n\nDevice\nExternal interrupts\nExtraction time\n\n\n\nSTM32F100\n55\n48.8 min\n\n\nSTM32F103\n43\n48.2 min\n\n\nSTM32F107\n68\n51.0 min\n\n\nTable 2: Extraction time and coverage for three devices of the STM32F1 series.\n\n\nThe results show that the amount of flash memory that can be extracted correlates with number of external interrupts. The most data can be extracted from the STM32107 microcontroller with its 68 external interrupts. The table also shows that the extraction time slightly increases with the increasing amount of extracted data.\nWe used a SEGGER J-Link debug probe with an adapter speed of 3500 kHz for the performance evaluation. Note that the adapter speed of your debug probe is an important factor for the extraction time and might also be influenced by further factors in your setup, for example, your computer system.\nIn a nutshell, these results show that the attack is indeed practically feasible as it can be executed in reasonable time: in less than one hour.\nConclusionIn this article, we discussed a vulnerability in the flash read-out protection mechanism of the STM32F1 microcontroller series. We showed that the exploitation is non-invasive and requires only access to the microcontroller’s debug interface. Hence, this attack is clearly within the typical attacker models of flash readout protection mechanisms.\nThe presented attack has certain limitations and does not allow an attacker to read out the entire flash memory. However, depending on the device, an attacker is able to read out up to 94.5 percent of the flash memory content in less than an hour. For that reason, we consider this read-out protection mechanism as broken and we do not recommand to rely on this feature anymore. Since the STM32F1 series has no other firmware protection mechanism, the only way known to the authors to avoid exploitation and thus keep the entire flash memory content confidential is to physically prevent an attacker from gaining access to the debug interface.\nAvailabilityIn order to encourage discussions and make our research results comprehensible and replicable, we publish the source code that was developed during our research. The source code is licensed under the GPLv3+ and can be found on https://gitlab.zapb.de/zapb/stm32f1-firmware-extractor.\nCoordinated DisclosureThe publication of our findings was preceded by a coordinated vulnerability disclosure process. We informed STMicroelectronics more than 100 days prior to the publication of this article.\n\n28 November 2019: Technical details about the vulnerability and the disclosure timeline provided to STMicroelectronics.\n08 December 2019: No response from STMicroelectronics so far. Reminder with technical details and disclosure timeline.\n23 December 2019: Still no response from STMicroelectronics. Reminder without technical details.\n06 January 2020: Reminder from CERT Bund and immediate response from STMicroelectronics.\n10 January 2020: Conference call with STMicroelectronics and CERT Bund as mediator.\n15 January to 07 February 2020: Further discussions between STMicroelectronics and CERT Bund.\n01 February 2020: Public announcement of the vulnerability without technical details.\n17 March 2020: Publication of this article and supplementary materials.\n\nAbout the AuthorsMarc Schink and Johannes Obermaier are two embedded system security researchers with a background in computer science and electrical engineering. They focus especially on microcontrollers that both encounter in their everyday live. With their research and publications they aim at improving security by an open discussion about the strength of security features and wish for improvements.\n\nExcept where otherwise noted, content on this site is licensed under a Creative Commons BY-NC-SA 4.0 license.\n"},{"title":"ARM嵌入式开发中的栈回溯机制","url":"/2022/11/12/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%A0%88%E5%9B%9E%E6%BA%AF%E6%9C%BA%E5%88%B6/","content":"两种ABI规范根据编译器的实现不同，存在两种ABI机制，分别为APCS(ARM Procedure Call Standard)和AAPCS(ARM Archtecture Procedure Call Standard)。两种机制存在明显的区别，且单独APCS和AAPCS又有很多变种，这里就不详细展开叙述其本质。本文主要讨论分析栈帧相关的内容，所以这里仅仅介绍这两种ABI机制下栈帧的区别。\nAPCS规范下函数调用和栈帧相关寄存器APCS中规定了几个别名寄存器，分别是fp、ip、sp、lr、pc寄存器，它们实际对应的寄存器及含有有下表：\n\n\n\nAPCS\nReg\n意义\n\n\n\nfp\nr11\n栈帧指针寄存器\n\n\nip\nr12\n临时变量寄存器\n\n\nsp\nr13\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧函数调用入口处将pc、lr、sp、fp寄存器依次入栈。入栈前先将sp保存到ip，入栈后再将ip的值给fp，这样fp的值就是当前栈帧的起始位置。后续如果需要使用局部变量，就将sp减一个值实现在栈空间上开辟局部变量的空间。函数退出前将sp寄存器处理到堆栈平衡状态，再通过fp寄存器找到当前函数的栈帧位置，通过栈帧找到返回函数的fp寄存器和sp寄存器、lr寄存器。简要的代码如下：\n&lt;func1&gt;:mov ip, sppush &#123;fp, ip, lr, pc&#125;sub fp, ip, #4sub sp, sp, #8      ;8 字节局部变量空间;...sub sp, fp, #12ldm sp, &#123;fp, sp, pc&#125;\n\n通过分析栈帧格式我们能够知道在函数任意位置，都能够通过fp寄存器找到当前栈帧位置，而不必考虑当前使用了多少局部变量空间，栈帧中能够得到当前函数的返回地址(lr)，当前运行地址(pc)，栈地址(sp)，同时根据栈帧中上一个函数的fp寄存器再找到上一层函数的栈帧数据，这样层层回溯就实现了栈的回溯。\n如何使用APCSgcc手册上对使用APCS有相关的描述和控制选项，-mapcs-frame选项编译出来的代码就是使用APCS规范，默认情况是-mno-apcs-frame，关于这个选项的描述GCC手册原文是：\nGenerate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying -fomit-frame-pointer with this option causes the stack frames not to be generated for leaf functions. The default is -mno-apcs-frame. This option is deprecated.\n\n这里说明了使用相关选项可以保证APCS的栈帧格式，如果不适用这个选项则不保证。APCS为1993年推出的标准，在后续推出AAPCS相关版本后它已经显得太旧了。在gcc5.0之后，该选项已经被遗弃，所以新版本的编译器已经不能使用APCS调用方式进行栈回溯。\nAAPCS下函数的调用相关寄存器AAPCS相比于APCS少了几个别名寄存器。它有sp、lr、pc寄存器，对应表如下：\n\n\n\nAPCS\nReg\n意义\n\n\n\nsp\nr13(ARM)/r7(THUMB)\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧在这种调用规范下，栈的回溯要比APCS下要复杂的多，函数的调用过程中不保存栈帧的指针，而且栈帧中也没有固定的格式，所以不能通过当前的栈帧层层返回数据。所以仅仅通过堆栈数据是不能进行栈回溯的。那么这种模式下如何保证堆栈平衡，能不能通过汇编代码的堆栈平衡实现栈回溯呢？\n我们知道APCS模式下函数进入到退出时的堆栈平衡时通过保存sp寄存器和恢复sp寄存器实现的。而AAPCS模式下堆栈平衡是直接依靠pop和push平衡实现的，即不会直接修改sp来实现堆栈平衡。但如果我们能够准确知道每个函数关于栈的操作，这样也能够实现栈的跟踪。\n通过适当的编译选项，我们能够将这部信息收集到一起，这就是arm exception handler index，简称ARM.exidx，这段数据就能指导我们实现栈回溯，把这种栈回溯方式称为unwind。\nARM.exidx位置和结构不同的编译器如何编译出exidx表具有不同的方式，但是如果可执行文件中包括exidx表，那么使用readelf -S file.elf 能够看到可执行文件中存在一个名为.ARM.exidx，类型为ARM_EXIDX的段。这就表示编译器已经生产的exidx段。\n关于exidx的结构及其含义这里做一个简单介绍，详细信息可以参考ARM官方网站。exidx是一个由多个相同单元组成的表，每个单元由两个uint32_t的数据构成，结构类似于：\nstruct &#123;    uint32_t offset;    uint32_t world;&#125;\n其中offset表示目标函数到当前位置的偏移，它的最高位固定为0。而world中存放了编码数据，它表示了对栈的不同操作，通过操作它就能够知道目标函数上关于栈的操作。\nLinux中的栈回溯Linux中关于ARM架构的栈回溯就是使用的exidx表实现的，这里以linux5.3版本内核中关于unwind frame的代码进行演示。涉及的主要代码文件有arch/arm/kernel/unwind.c arch/arm/include/asm/unwind.h arch/arm/include/asm/ptrace.h stacktrace.h等。主要将unwind.c移植到我们的嵌入式平台就能够使用unwind栈回溯了。\n代码移植由于linux中存在内核空间和用户空间，两种空间下存在各种的exidx表，而通常我们的代码没有所谓的两个地址空间。所以需要将涉及到地址空间判断的全部判断为是否为代码空间段，linux对于用户空间段的exidx表是通过链表由用户手动添加的，内核段的exidx表是直接由编译符号完成的。其他的代码修改主要是涉及到Linux平台特性的。下面介绍的相关修改都是基于gcc编译器(ver&gt;5.0)实现的。\n\n1.实现两个关键的函数： #define core_kernel_text(addr)    ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)#define kernel_text_address(addr) ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)\n2.添加日志输出的相关接口，主要就是两个，其中pr_debug日志可以选择不输出。 #define pr_debug(...) printf(__VA_ARGS__)#define pr_warn(...)  printf(__VA_ARGS__)\n3.关于分支预测的代码，可能在某些arm平台下不支持分支预测，所以这里的移植就把这个特性关闭掉。 #define likely(c)   (c)#define unlikely(c) (c)\n4.字节对齐函数，用于把某个数据按多少字节对齐。 #define ALIGN(x,a) (((x)+(a)-1)&amp;~(a-1))\n5.内存操作的相关接口，这里其实并不会使用到内存相关申请，它只是在添加用户空间exidx表时才使用，而我们的嵌入式平台上是显然是用不到的。 #define kmalloc(size, flag)  malloc(size)#define kfree(ptr)           free(ptr)\n6.exidx表的位置，不同的编译器在链接脚本中关于exidx表的起始终止位置的描述可能不一样，这里需要重新定义一下。 #define __start_unwind_idx __exidx_start#define __stop_unwind_idx  __exidx_end\n7.实现获取关键寄存器的操作，主要是获取sp寄存器，如果不是在gcc编译器中，还需要实现获取lr寄存器和sp寄存器 register char * stack_ptr asm(&quot;sp&quot;);#define current_stack_pointer ((unsigned long) stack_ptr)\n8.linux中针对部分代码使用了spinlock进行保护，在我们的嵌入式平台上通常是不需要的，当然如果有必要可以进行选择性的实现类似spinlock的操作。\n9.关于代码是arm模式还是thumb模式，如果代码是thumb模式，还需要定义一个宏，他将决定fp寄存器是r7还是r11 #define CONFIG_THUMB2_KERNEL\n10.对于.h文件，主要是是保留unwind.h文件，删除其中不相干的代码，其他头文件中可能只是会引用部分数据和数据结构可以直接拷贝到unwind.h文件中。\n11.可以选择是否保留关于添加unwind_table的相关函数，这些函数通常不会使用。\n\n除了上述代码的移植外，编译时需要开启-funwind-tables选项，使编译器能够正常生产exidx段。在连接时要保证链接脚本中有存放exidx段的位置，以及预留出索引exidx段的起止符号，类似这样的链接脚本：\n.ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH.ARM : &#123;  __exidx_start = .;  *(.ARM.exidx*)  __exidx_end = .;&#125; &gt;FLASH\n\n将代码移植到ARMCC编译器中keil作为一个应用在嵌入式开发领域的一个重要软件，如果能够将这个功能应用到ARMCC编译器环境下，那这个功能将显得更加具有现实意义。前面的移植主要是在gcc编译平台下完成的，下面介绍如何将这段代码和功能移植到ARMCC编译平台下。\n\n1.编译环境相关的设置 要使编译器能够正常编译出代码exidx数据段的代码需要开启特别的选项 –exceptions –exceptions-unwind，它的意义是开启异常处理机制，因为最初exidx段设计来就是用于处理类型c++中的异常机制的。在开启了这些选项后编译出的代码就会包含exidx段，可以使用指令进行检验查看，如readelf -S main.o，其中就能够看到相关的数据段。当然不同的文件中的exidx段还没有链接到一起，要把它们链接到一起还比较麻烦。 因为ARMCC的优化策略，未使用的数据段都会在链接阶段被优化掉，而我们由不能直接使用到exidx中的数据(没有相关的符号指向这里)，所以正常情况下，即使开启的前面的编译选项，最终编译出来的文件也没有任何区别。在链接阶段添加选项–keep *(.ARM.exidx)，这个选项的意思就是在链接时保留exidx段(注意.ARM.exidx是exidx段的标准名称，前面没有提到，不同的编译器编译出来都是这个段名，且段类型都是未ARM_EXIDX)，这样链接出来的文件可以发现会比未加这个选项的文件大了些，这就新增的exidx段数据导致的。 但是这时候还是存在一个问题，编译出的文件包含了exidx段的数据，但是却没在我们想要的地方，或者说没没办法确定这段数据在哪儿。readelf -S能够看到段的结构没有增加，而ER_IROM1段的数据变多了，这就说明exidx段的数据与代码数据放入了同一个段，这显然不是我们想要的。 修改分散加载文件，在链接选项中指定使用自定义分散加载文件。我们起始可以看到原sct文件的结构为：\n LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n\n 我们在这里添加exidx段的声明后的结构为：\n LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    ER_EXIDX +0 0x00020000 &#123;        .ANY (.ARM.exidx)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n\n 经过对编译器链接器的设置，我们终于将exidx段的数据放到了期望的地方，在编译器中使用符号Image$$ER_EXIDX$$Base和Image$$ER_EXIDX$$Limit就能访问到exidx段的数据(编译器特性)。\n\n2.处理完成了编译器的相关内容，还需要修改源代码以适应ARMCC编译器，需要修改的地方主要体现在使用到了gcc内建函数的地方，以及gcc支持的一些拓展语法上，具体如何修改这里不做详细的介绍了。以上包括gcc和keil平台下的移植都经过测试，能够非常准确的回溯函数的调用链，包括在使用函数指针的地方都能进行准确的回溯，对于分析软件bug具有一定的帮助。\n\n\n技术参考本文中所设计到的内容主要来自于ARM官方的技术文档库，GCC编译手册，Linux内核源码等。可自行检索参考。\n"},{"title":"nRF52x运行蓝牙协议栈+FreeRTOS的原理","url":"/2022/05/30/nRF52x%E8%BF%90%E8%A1%8C%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88+FreeRTOS%E7%9A%84%E5%8E%9F%E7%90%86/","content":"\n之前有个研发的产品为了满足蓝牙连接的需求，选择了nRF52840这个芯片，它的蓝牙协议栈是一种类似使用动态库的方式进行调用，官方仅仅给出了协议栈的二进制包(SoftDevice)，并给出了动态调用的方法，其调用的关键就是使用ARM单片机的SVC调用，这是一种比较好的设计，我们开发软件能够非常简单的调用协议栈的程序来实现蓝牙通信相关的功能。后来产品的使用需求发生的变化，蓝牙功能已经不需要的，而是需要更加复杂的通信功能。为了保持业务功能代码的一致性，所以并没有替换芯片，但是由于通信功能更加复杂后，迫不得已需要RTOS的支援。后续就是移植FreeRTOS等一系列操作。因为该单片机是CM4内核，所以这些操作都很简单。\n\nSVC调用冲突的疑惑今天在看这两套基于nRF单片机的设计方案时，我对其中的有个细节产生了疑惑。了解FreeRTOS的开发者应该比较清楚，像CM4内核的单片机启动FreeRTOS的第一个任务时，依赖SVC调用从裸机运行切换为RTOS线程运行。而蓝牙协议栈也使用了SVC调用，那是不是意味着该单片机的蓝牙功能不能和FreeRTOS兼容，结果是否定的。因为从官方的例程中可以看到蓝牙+FreeRTOS的例程(examples\\ble_peripheral\\ble_app_hrs_freertos)。我决定弄清楚Nordic的蓝牙协议栈+FreeRTOS是如何兼容的。\n我起初认为FreeRTOS的port实现中对初始任务调用有区别一般单片机的特殊处理，但是仔细看它的port文件后又发现并没有什么特别的。\n// external\\freertos\\portable\\ARM\\nrf52\\port.c__asm void vPortSVCHandler( void )&#123;    PRESERVE8    /* Get the location of the current TCB. */    ldr r3, =pxCurrentTCB    ldr r1, [r3]    ldr r0, [r1]    /* Pop the core registers. */    ldmia r0!, &#123;r4-r11, r14&#125;    msr psp, r0    isb    mov r0, #0    msr basepri, r0    bx r14&#125;__asm void vPortStartFirstTask( void )&#123;    PRESERVE8    EXTERN __Vectors    /* Use the NVIC offset register to locate the stack. */    ldr r0, =__Vectors    ldr r0, [r0]    /* Set the msp back to the start of the stack. */    msr msp, r0    /* Globally enable interrupts. */    cpsie i    cpsie f    dsb    isb#ifdef SOFTDEVICE_PRESENT    /* Block kernel interrupts only (PendSV) before calling SVC */    mov r0, #(configKERNEL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))    msr basepri, r0#endif    /* Call SVC to start the first task. */    svc 0    ALIGN&#125;\n\n而在FreeRTOSConfig.h文件中也将该函数映射到了中断向量表中\n// examples\\ble_peripheral\\ble_app_hrs_freertos\\config\\FreeRTOSConfig.h/* Definitions that map the FreeRTOS port interrupt handlers to their CMSISstandard names - or at least those used in the unmodified vector table. */#define vPortSVCHandler                                       SVC_Handler#define xPortPendSVHandler                                    PendSV_Handler\n\n到这里我转头分析nRF的SDK代码，例如sd_ble_enable()函数就是一个SVC调用在ble.h文件中使用一个SVCALL宏定义扩展为SVC调用代码，到这里我怀疑SVCALL针对有无RTOS有两种不同的设计，后来发现是多虑了。\n检查中断向量表实在不行上代码吧，在调试环境中看看，我运行了一个仅仅包含蓝牙协议栈的程序，运行起来后发现SCB-&gt;VTOR=0\n很奇怪~\n蓝牙协议栈在ROM中的地址范围为0-0x27000，我们编写的APP地址范围为0x27000-END。因为单片机从地址0处开始运行，肯定是运行蓝牙协议栈，在协议栈内跳转到APP中，按照一般BOOT+APP的设计思想，BOOT跳转是应把中断向量表寄存器改为APP的中断向量表。这里为什么还是BOOT的中断向量表呢？难道是Bug。看来需要看看协议栈固件中发生了什么。\n其实到这里我就大概猜到这里面的门道了，我准备逆向分析蓝牙协议栈的二进制包，看看是否符合我的预期。我认为整个系统任然依赖Boot(蓝牙协议栈程序，我把它当作boot的角色)的向量表，而在Boot的中断处理函数中通过适当的判断决定执行Boot中断处理逻辑还是跳转引导到APP中的中断处理函数中来。\n分析SoftDevice固件官方提供的boot为一个HEX文件，我先转为bin文件，方便查看二进制数据，从前面的调试结果能够看到中断向量表在起始位置，那么很容易就找到SVC的入口地址了，在0x2c偏移处得到0x00000AA5，忽略最低bit1，转到0x00000AA4，开始分析SVC的函数处理流程，这里不讨论如何逆向固件，直接看结果，我把其中最关键的部分截取了出来。\n这里分析的固件从nRF5_SDK_17.0.2_d674dde中获得。不同版本的SoftDevice可以在汇编数据上有差别，大体流程应该是一致的。\n0x00000AA4 F01E0F04  TST           lr,#0x04       ;; 解析SVCid的经典代码，很多地方都看过0x00000AA8 BF0C      ITE           EQ0x00000AAA F3EF8108  MRS           r1,MSP0x00000AAE F3EF8109  MRS           r1,PSP0x00000AB2 6988      LDR           r0,[r1,#0x18]  ;; 得到执行SVC指令后的PC指针值. why offset = 0x18, see ARM manual0x00000AB4 3802      SUBS          r0,r0,#0x02    ;; 向后回退一个指令的长度，即2字节，就是SVC指令的位置0x00000AB6 7800      LDRB          r0,[r0,#0x00]  ;; 按字节取值，从低位得到SVC的id，id是作为低位包含在二进制编码中的0x00000AB8 2818      CMP           r0,#0x180x00000ABA D103      BNE           0x00000AC4   ;; SVC的ID不等于0x18跳转到0x00000AC4，这就是我们需要流程，FreeRTOS的SVCid为00x00000ABC E000      B             0x00000AC0   ;; SVC的ID等于0x18跳转到0x00000AC40x00000ABE 0000      MOVS          r0,r00x00000AC0 4A07      LDR           r2,[pc,#28]  ; @0x00000AE00x00000AC2 4710      BX            r20x00000AC4 4A07      LDR           r2,[pc,#28]  ; @0x00000AE40x00000AC6 6812      LDR           r2,[r2,#0x00] ;; 检测内存发现@0x20000000的值为0x10000x00000AC8 322C      ADDS          r2,r2,#0x2C   ;; 0x2C? 像是SVC的偏移，推测在RAM的0x1000处有一个新的中断向量表0x00000ACA 6812      LDR           r2,[r2,#0x00] ;; r2=0x0002606D0x00000ACC 4710      BX            r20x00000ACE 0000      MOVS          r0,r00x00000AE0: 00000377 .word 0x000003770x00000AE4: 20000000 .word 0x200000000x0002606C 2004      MOVS          r0,#0x04     ;; 这是另一个SVC处理函数0x0002606E 4671      MOV           r1,lr0x00026070 4208      TST           r0,r1        ;; 这是编译器生成的还是手工编写的汇编，太冗余了...0x00026072 D002      BEQ           0x0002607A0x00026074 F3EF8109  MRS           r1,PSP0x00026078 E001      B             0x0002607E0x0002607A F3EF8108  MRS           r1,MSP0x0002607E 6988      LDR           r0,[r1,#0x18]0x00026080 3802      SUBS          r0,r0,#0x020x00026082 7800      LDRB          r0,[r0,#0x00] ;; 到这里，函数重新解析了一遍SVC的ID0x00026084 2810      CMP           r0,#0x100x00026086 DB13      BLT           0x000260B0    ;; 如果ID小于0x10则跳转到 0x000260B00x00026088 2820      CMP           r0,#0x200x0002608A DB0F      BLT           0x000260AC    ;; 如果ID小于0x20则跳转到 0x000260AC0x0002608C 282C      CMP           r0,#0x2C0x0002608E DB0B      BLT           0x000260A8    ;; 如果ID小于0x2c则跳转到 0x000260A80x00026090 4A0A      LDR           r2,[pc,#40]  ; @0x000260BC0x00026092 6812      LDR           r2,[r2,#0x00]0x00026094 4B0A      LDR           r3,[pc,#40]  ; @0x000260C00x00026096 429A      CMP           r2,r30x00026098 D103      BNE           0x000260A20x0002609A 2860      CMP           r0,#0x600x0002609C DB04      BLT           0x000260A80x0002609E 4A09      LDR           r2,[pc,#36]  ; @0x000260C40x000260A0 4710      BX            r20x000260A2 2002      MOVS          r0,#0x020x000260A4 6008      STR           r0,[r1,#0x00]0x000260A6 4770      BX            lr0x000260A8 4A07      LDR           r2,[pc,#28]  ; @0x000260C80x000260AA 4710      BX            r20x000260AC 4A07      LDR           r2,[pc,#28]  ; @0x000260CC0x000260AE 4710      BX            r20x000260B0 4A07      LDR           r2,[pc,#28]  ; @0x000260D00x000260B2 6812      LDR           r2,[r2,#0x00]  ;; 在0x20000004处的值为0x27000,它是app的起始位置0x000260B4 322C      ADDS          r2,r2,#0x2C    ;; 计算出app中SVC的地址0x000260B6 6812      LDR           r2,[r2,#0x00]0x000260B8 4710      BX            r2             ;; 跳转到app中的SVC执行0x000260BC: 2000005C .word 0x2000005C0x000260C0: CAFEBABE .word 0xCAFEBABE0x000260C4: 0000139B .word 0x0000139B0x000260C8: 00024485 .word 0x000244850x000260CC: 00024E9F .word 0x00024E9F0x000260D0: 20000004 .word 0x20000004\n\n分析执行过程猜测在0x20000000和0x20000004处存放了两个中断向量表的起始地址，一个是内存中的向量表，位于0x1000；另一个就是APP的中断向量表，位于0x27000。\n结论非常明显了，当SVC的id小于0x10时就会跳转到我们编写的APP固件中的SVC处理函数中，这样就实现了FreeRTOS的port所依赖的功能。而id大于等于0x10时就执行协议栈内部的工作流程，实现了蓝牙协议栈+FreeRTOS功能的兼容。\n从这个汇编代码的执行路径来看，从触发BOOT中的SVC到跳转到APP中的SVC处理函数，全程都没有使用栈操作的指令，没有涉及pop、push、bl、bxl等。这样在APP的中断函数中就能直接返回到线程环境代码，这样的设计对APP的中断处理函数来说也更加封闭。\n官方的文档中也说明了0-0xf的id调用分配到了Application，其它的id分配为协议栈。\n类似的像PendSV_Handler中断处理函数，在协议栈内部触发后，经过5条指令就能够跳转到APP内部，还算是比较简洁的，应该不会对FreeRTOS的调度性能产生很大的影响。\n官方的SDK中id是从0x60开始使用的，而协议栈中对小于0x20、0x2c等区间的id有特殊处理，为什么需要这样处理呢？以后再看吧。\n不懂固件中为什么需要两次解析SVC的id，关键是是第二次解析时很不简洁，还多了3条指令，看起来好别扭-_-!\n"},{"title":"一个困扰我很久的问题","url":"/2023/08/30/%E4%B8%80%E4%B8%AA%E5%9B%B0%E6%89%B0%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84%E9%97%AE%E9%A2%98/","content":"大约在一年半前，我写了一篇文章介绍如何统计FreeRTOS系统中任务的实时CPU占用率的方法，其中最关键的是使用DWT计数器。我一直认为这个计数器在任意条件下都是能够正确运行的，直到我把它运用到Cortex-M7内核中。\n正常情况下Cortex-M7内核的DWT计数器能够正常工作，只是需要操作一个访问锁寄存器LAR，但是我发现各个单片机对这个锁的实现并不是一致的，某些单片机不解锁仍然能够使用DWT功能，ARM的技术手册中也没有详细描述这寄存器。LAR锁不是今天讨论的主要内容，略过。我这里主要想说说单片机睡眠模式下遇到的DWT计数异常的问题。\n当我使用FreeRTOS的低功耗模式时就发现了DWT异常的现象，当单片机进入休眠状态后，DWT的计数器并没有继续运行，这个现象我只在STM32H750这个单片机上碰到，由于我手上没有其它的CM7的单片机，所以我无法确认这个问题是不是这个单片机特有的。当出现这个问题后我就在CM4的单片机上尝试复现，但是在CM4的单片机中任务统计功能和低功耗都能很好的运行。\n我在网上检索了很多的资料，都没有相关的描述，这让我非常怀疑是软件某个地方配置不当导致的，但是我却并没有发现可疑的地方。\n当启用FreeRTOS的低功耗模式后，在tickless处理流程中，我确认DWT的CYCCNT寄存器没有继续计数，所以启用低功耗模式后，统计任务的CPU占用时间就不可靠了。\n由于能够确认在tickless中CYCCNT的计数存在缺失，所以通过FreeRTOS的HOOK能够进行一定程度的补偿来确保任务CPU统计功能大致正常工作，但是这总是存在误差的，因为依靠traceINCREASE_TICK_COUNT()纠正的时间精度不够准确。\n如果能确认这个问题是硬件导致的，我就放心了，因为我常常时不时的就在尝试完美解决这个问题，这个问题困扰我很久了。\n"},{"title":"一个极简的DAPLink","url":"/2024/06/20/%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84DAPLink/","content":"平时我的主要兴趣方向都是嵌入式软件开发方面的内容，但偶尔也做一些硬件相关的内容。我的硬件设计水平一般，仅仅是能够用嘉立创的EDA软件设计一些简单的PCB，焊接能力更是拿不出手😅。\n之前我偶然间看到一个别人设计的DAPLink，使用51单片机完成的。让我感兴趣的是，如果更换同类型的更小封装芯片，或许可以设计出一个非常小的DAPLink，所以就有了我的一个设计。\n我使用CH552E单片机加一个LDO以及其它几个电阻电容就完成了它的主要电路。一个极简的DAPLink，具有一个SWD接口和一个UART接口，只有大约USBtype-C母座的大小。如果你喜欢，它甚至可以作为你的板载调试器。\n\n我已经让它工作了很长一段时间，看起来非常好用。在某个量产项目中，我把它当作固件批量下载工具，目前还没有遇到明显的问题。\n最后，它的原理图、PCB、源代码、编译好的固件在这里：原理图PCB：立创开源-DAPLink固件、源码：https://github.com/DazzlingOkami/CH552-DAPLink\n"},{"title":"一个简单但强大的协程库-PtPlus","url":"/2024/08/20/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%BA%93-PtPlus/","content":"去年我基于Protothreads协程库实现了一些有意思的扩展功能以方便使用该协程库。相关的两篇文章可以翻看去年的博客。\n\n更优雅的使用Protothreads协程框架\nPT协程的一个小扩展\n\n\n\n最近我继续完善了相关的功能，并增加了一些新的功能。实现了低功耗支持、可超时的信号量等。\n将所有相关代码进行整理后我为其命名为PtPlus。现已经发布在GitHub上，欢迎大家使用。\n它使用标准C语言编写，几乎可以运行在所有的嵌入式平台上。\n相关的用法以及示例可以参考PtPlus。\n这里仅展示一段代码来展示该协程库的使用。\n#include &lt;stdio.h&gt;#include &quot;pt_plus.h&quot;#ifdef _WIN32#include &lt;windows.h&gt;#define sleep(ms) Sleep(ms)#endifstruct pt_sem sem;PT_THREAD(test_task_A(struct pt *pt))&#123;    PT_BEGIN(pt);    static int i;    for(i = 0; i &lt; 10; i++)&#123;        PT_TASK_DELAY(pt, 1000);        printf(&quot;send semaphore - %d\\r\\n&quot;, clock_time());        PT_SEM_SIGNAL(pt, &amp;sem);    &#125;    PT_END(pt);&#125;PT_THREAD(test_task_B(struct pt *pt))&#123;    PT_BEGIN(pt);    static int err_cnt = 0;    while(1)&#123;        int ret;        PT_SEM_WAIT_TIMEOUT(pt, &amp;sem, 2000, &amp;ret);        if(ret == 0)&#123;            printf(&quot;Obtained semaphore! - %d\\r\\n&quot;, clock_time());        &#125;else&#123;            printf(&quot;Obtain semaphore timeout - %d\\r\\n&quot;, clock_time());            err_cnt++;            if(err_cnt &gt;= 3)&#123;                PT_EXIT(pt);            &#125;        &#125;    &#125;    PT_END(pt);&#125;int main(void)&#123;    PT_SEM_INIT(&amp;sem, 0);    PT_TASK_RUN(test_task_A);    PT_TASK_RUN(test_task_B);    while(PT_TASK_NUMS() &gt; 0)&#123;        PT_TASK_SCHEDULE();        clock_time_t idle_time = PT_TASK_IDLE_TIME();        if(idle_time &gt; 0)&#123;            // Calling system delay functions            sleep(idle_time);        &#125;    &#125;    return 0;&#125;\n\n在main函数中创建了两个任务后开始进行调度。任务A每间隔1秒发出一个信号量，任务B每隔2秒等待信号量，如果等待超时则打印错误信息。任务B连续3次超时后，任务B将退出。当所有的协程任务都结束后，程序结束。\n"},{"title":"体验国产RISC-V单片机","url":"/2024/05/18/%E4%BD%93%E9%AA%8C%E5%9B%BD%E4%BA%A7RISC-V%E5%8D%95%E7%89%87%E6%9C%BA/","content":"\nRISC-V单片机并不是很新鲜的东西，但因为其市场占有率相比于ARM内核的芯片较小，所以此类芯片并不流行。在此之前，我并没有接触过RISC-V的芯片，趁着春节假期，购得一块国产单片机CH32V307，本着学习的态度，看看该芯片相比于ARM内核有何优缺点。\n\n芯片上手RISC-V芯片的指令集、指令架构同ARM芯片有着非常大的差异，不过前期还不需要接触到这个层面，从最基本的helloworld程序开始可以最快上手这个芯片，芯片厂家提供了HAL层的代码和集成开发环境，还提供了大量的example可供参考，所有让这个芯片运行起来是很容易的。\n这个芯片让人最感兴趣的有三个方面，RISC-V内核、内建10MPHY的以太网控制器、内建480MPHY的高速USB控制器。尤其是后两点，几乎所有的STM32的芯片都不支持，这对构建网络相关、USB相关的应用非常有利。\nRISC-V内核针对RISC-V内核的探索，主要是移植FreeRTOS操作系统为主。FreeRTOS官方提供了RISC-V的port层适配，其基于mtimer实现，但是该芯片的内部实现上有些差异(RISC-V生态不统一)，其砍掉了mtimer，增加了一个类似ARM单片机的systick，所以芯片厂家自己实现了一个port适配层。\n参考该适配层代码完成了操作系统的移植。在移植过程中主要遇到了以下问题：\n\n需要在链接脚本中分配独立的操作系统栈该栈仅用于线程切换的中断使用，FreeRTOS官方的port层方案中没有这方面内容。RISC-V芯片没有独立的中断栈空间，所以芯片厂商为RTOS上下文切换中断特别实现了中断栈切换机制，相对应的栈空间需要提前在链接脚本中分配。这是与ARM单片机区别较大的地方，ARM单片机可自定义线程栈和中断栈，并由芯片自动完成切换。这里需要注意链接脚本的写法，操作系统的栈空间和系统开始运行的栈空间其实可以为同一个地址空间，因为操作系统开始运行后，最开始的主栈空间将不再使用。所以这两部分空间是一致的。在xPortStartFirstTask实现中，将链接脚本分配的空间地址减小了512字节，这主要是避免和主栈空间发送冲突，但实际上这里应该是不需要的。将中断栈地址将写入到mscratch寄存器中，这是一个临时存储数据的寄存器，这里将专用于保存栈地址，通过寄存器交换指令实现sp寄存器和mscratch的交换，达到栈空间的切换目的，这样用户空间和内核调度中断的栈将相互独立。\n .stack ORIGIN(RAM) + LENGTH(RAM) - __stack_size :&#123;    PROVIDE( _heap_end = . );        . = ALIGN(4);    PROVIDE(_susrstack = . );    . = . + __stack_size;    PROVIDE( _eusrstack = .);    __freertos_irq_stack_top = .;&#125; &gt;RAM \n\n芯片运行模式该芯片具有两种运行模式，用户模式和机器模式，原则上来说芯片上电启动后芯片运行在机器模式，但是厂家提供的启动代码将芯片调整到了用户模式，在裸机开发时这可能更有利于系统安全。但是在RTOS系统中，系统为了访问CSR寄存器实现对处理器的控制，系统必须允许在特权级。所以这里需要调整启动汇编代码，根据芯片相关手册，调整mstatus寄存器使得芯片始终运行在机器模式。这部分内容与ARM单片机也有像类似的地方。ARM单片机也分为特权模式和非特权模式，目前市面上大部分操作系统都运行在特权级，包括用户级的线程。仅少部分操作系统对用户线程实现了权限管理。\n\nCall API from ISR为了系统的安全性和健壮性，FreeRTOS要求在中断中使用FromISR结尾的系统API。但是芯片官方的port实现中缺少相关的检测支持，这使得软件开发过程中可能出现一些潜在的风险无法暴露。主要是在vPortEnterCritical()接口的实现中，当第一次进入临界区，需要检测是否在中断中，因为该API仅能够在非中断上下文使用，中断上下文有其它的实现接口。芯片官方和FreeRTOS默认的port层代码如下：\n void vPortEnterCritical( void )&#123;    portDISABLE_INTERRUPTS();    uxCriticalNesting++;&#125;\n 可见缺少相关故障断言支持，这里可调整为：\n void vPortEnterCritical( void )&#123;    portDISABLE_INTERRUPTS();    uxCriticalNesting++;    if( uxCriticalNesting == 1 )    &#123;        configASSERT( ( (PFIC-&gt;GISR) &amp; 0x1ff ) == 0 );    &#125;&#125;\n 通过GISR寄存器实现中断上下文的识别和检测。\n\n低功耗模式无论是FreeRTOS官方代码还是芯片产家的port层代码中都缺少低功耗支持相关的内容，所以这部分需要自己实现，因为芯片是支持低功耗模式的。主要是需要充分理解systick运行机制以及芯片的低功耗进入及唤醒机制并配合操作系统完成低功耗运算的实现。使用WFI指令可以让处理器进入低功耗模式，当发生中断时可自动唤醒芯片，但是在FreeRTOS系统中配合systick实现的低功耗接口vPortSuppressTicksAndSleep，在WFI指令前需要关闭中断，所以导致系统无法正常唤醒。这里需要特殊处理一下，通过SCTLR寄存器将WFI指令切换为event模式，即通过事件唤醒系统。再将SEVONPEND标志置位，这样即使关闭全局中断，当系统的任意中断发生时仍然能够立即唤醒芯片。在具体实现vPortSuppressTicksAndSleep上，需要注意systick的计数方向，FreeRTOS已经将其改为向上计数，所以这里同一般STM32单片机的计数方向是相反的。先根据系统需要休眠的时间估算systick的计数值，重设systick的CMP寄存器，通过WFI让芯片休眠，芯片唤醒后检查是systick唤醒还是其它中断唤醒，如果是其它中断唤醒则需要根据systick的计数值计算刚刚休眠的时长。将systick的CMP恢复到休眠前的状态，通知RTOS内核刚刚休眠的时长，这样即完成了低功耗port的实现，在具体的实现上还需要注意systick在不同时间段的累计补偿和停机补偿。使用低功耗模式会不可避免的使得RTOS时间同实际时间发生一定的偏移，但这个偏移在长时间的累计才会比较明显，一般影响不大。但是如果将RTOS的内核时间作为日历时间使用则会导致一定的误差，这是开启低功耗模式时需要注意的问题。在我的开发板上测试，在运行相同软件应用的情况下，未开启低功耗模式运行时的电源为5V/29mA，开启低功耗模式后的电源为5V/19mA，考虑到开发板上存在一些固定功率开销，低功耗模式带来的优势还是非常明显的。\n\n\n注：开启低功耗模式运行后，网卡驱动的发送部分硬件DMA存在一定的异常问题还未解决。\n太网控制器芯片内建10M的PHY，这意味这该芯片不需要单独的网卡芯片即能够实现网络通信，使用单片芯片方案即能够完成联网应用开发。芯片厂家提供了一个网络协议栈WCHNET，该协议栈能够满足基本的网络应用开发需求，但是面对复杂应用，使用LwIP协议栈可能更加合适。\nLwIP依赖前面的操作系统，此外协议栈没有其它的移植要求。为了让协议栈正常运行起来，最关键的是实现网卡驱动。这里参考官方示例基本能够完成驱动开发，官方虽然没有针对LwIP进行适配，但是驱动层的MAC帧都是通用的，所以驱动的移植难度也不大。以太网HAL层的代码结构同STM32单片机类似，用法上没有陌生感。\n驱动移植完成后进行了简单的网络测试，使用iperf工具测试，收发带宽可达9.3M，基本上达到10M接口的传输速度上限。\nUSB控制器芯片官方提供了较丰富的测试代码，有HS、FS端口相关的代码，还有主机、从机的示例。应用类别也有CDC、网络等。运行了官方示例代码，可以确认USBHS能够很好的工作，但是在移植Tinyusb是遇到了一些问题。\nTinyUSB是第三方USB协议栈，其支持CH32V307芯片，该协议栈能够非常方便的进行USB设备描述符的编写，这是我常用的一个USB协议栈库。该协议栈也对CH32V307的HS端口进行了适配，但是在实际运行过程中出现了一些问题。在关闭协议栈调试日志的情况下，内部会出现断言错误，打开日志后，该故障消失。输出日志会影响代码的运行速度，这应该就其内部的差异。导致该问题的原因没有进一步研究，应该是驱动层或协议层代码存在一些竟态问题。所以针对该芯片USB方面的内容就没有进行更加深入的测试。检查TinyUSB官方的issus列表，可以确认针对CH32V307的适配还存在一些问题，待修复后再测试该芯片的USB性能。\n故障诊断该芯片提供了一个独立的故障中断，类似于ARM单片机的HardFault，但是该故障中断囊括了芯片运行的大部分故障，包括指令异常、内存寻址错误、内存非对齐等。特别注意RISC-V单片机不支持非对齐内存访问，在编写C代码时需要注意规避这方面的问题。\n当发生故障时，可以通过CSR寄存器列表中的mcause寄存器确定发生故障的原因。更进一步的，通过mepc寄存器还能够提供发生故障时的PC指针。这对于故障的诊断十分有利。\n中断控制器这是芯片相关的内容，并不是RISC-V通用的中断控制器。芯片可支持8级中断优先级、4组优先级分组。该芯片的特色是支持硬件压栈，即硬件上有独立的内存空间用于中断发生时通过硬件自动保持caller saved寄存器，这意味其相比于一般的单片机中断，它的响应过程可以减少许多额外的指令开销。硬件压栈最高支持3级嵌套，可以满足中断高实时性的要求。\n此外，芯片还支持4路免表中断，即不通过中断向量表，将中断函数入口地址直接绑定到指定的中断上，这将进一步提高中断的响应速度。\n需要注意的是，区别于ARM单片机中断有独立的栈，该芯片发生中断时并不会自动切换栈空间，这意味着中断栈空间将是线程栈空间的延续。在调试网卡中断时我没有意识到这一点，导致中断发生时将IDLE线程的栈空间溢出。如果不能手动将栈切换到独立空间，那么需要控制中断函数的栈空间消耗。\n其它内容芯片官方开发的HAL库在代码风格上接近STM32早期的标准库，甚至部分API名称都一致，这也是方便入手该芯片的优势。\n在以上开发测试过程中编译器一直使用-Os优化，代码运行过程中没有出现由于编译优化导致的问题。\n芯片的最高主频为144MHz，代码模板采用默认的96MHz。96MHz主频下，基于FreeRTOS系统运行Coremark基准测试，跑分可达250分(满频率运行应当为370分)，性能同ARM的CM4内核水平相当。\n2K performance run parameters for coremark.CoreMark Size    : 666Total ticks      : 15839Total time (secs): 15.839000Iterations/Sec   : 252.541196Iterations       : 4000Compiler version : GCC8.2.0Compiler flags   : -OfastMemory location  : FreeRTOS-heap4seedcrc          : 0xe9f5[0]crclist       : 0xe714[0]crcmatrix     : 0x1fd7[0]crcstate      : 0x8e3a[0]crcfinal      : 0x65c5Correct operation validated. See README.md for run and reporting rules.CoreMark 1.0 : 252.541196 / GCC8.2.0 -Ofast / FreeRTOS-heap4\n\n此外还测试了SPI、TIM等外设，性能尚可。该芯片还具有DVP、FSMC等外设，可进一步拓展该芯片的用途。\n总的来说，第一次使用RISC-V芯片，该芯片给我留下了较好的影响。我认为该国产芯片的功能已经达到了目前主流单片机的行列，但其流行程度、相关的开发生态环境、社区活跃度都还需要进一步发展。将其应用到项目开发过程中需要考虑面临故障时缺少经验的问题，国产单片机的发展任重而道远。\n"},{"title":"内存陷阱，一种内存调试方法","url":"/2022/07/25/%E5%86%85%E5%AD%98%E9%99%B7%E9%98%B1%EF%BC%8C%E4%B8%80%E7%A7%8D%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/","content":"需求场景在一个多任务系统中，当一个全局可访问的数据出现了异常，如何排查问题呢？由于在多任务环境中，各个任务并行运行，一般的单步跟踪调试很难定位问题。逐个屏蔽代码又可能会导致问题无法复现。使用内存断点是比较好的方法，但是大多数集成开发环境对该功能的支持不完美，且使用场景有限。\n下面引入一个问题代码场景，分析该问题的排查方法。\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        delay(1000);    &#125;&#125;void isr_a(void)&#123;    *p = *p + 1;&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n\n在这段程序中任务A分配了一段内存空间，并打开了一个外部中断，任务A统计中断发生的次数，每秒输出一次数据并清零。如果此时存在一个任务B，由于其它故障导致变量被分配到了同一段内存上，显然任务A统计次数的变量就会出现数据异常的现象。\n由于地址0x2000会被正常的任务A和中断A访问，同时被异常的任务B访问。集成开发环境中的内存断点无法正常区分正常的访问和非法的访问，进而导致无法准确的跟踪到问题代码。\n适时启用内存断点如果能够在代码中实时的启用和关闭内存断点，看这个问题就能解决了。大致看起来是这样的：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        disable_mem_break(0x2000);        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        enable_mem_break(0x2000);        delay(1000);    &#125;&#125;void isr_a(void)&#123;    disable_mem_break(0x2000);    *p = *p + 1;    enable_mem_break(0x2000);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当正常访问数据时就先把内存断点关闭，当数据正常访问完成后再开，这样线程B非法访问数据时就会被内存断点捕获。这样在代码中适时添加、删除断点的行为是可行的。\n内存断点的原理ARM Cortex-M3以上的内核都具有CoreDebug和DWT内核外设模块，它们的一个功能就是实现内存断点机制，通过在DWT的监视表上记录需要监视的内存地址，监视的方式(读、写)等参数，当满足条件时就会触发DebugMon_Handler异常中断。这个过程显然是代码可控制的。\ntypedef struct&#123;  __IOM uint32_t CTRL;      __IOM uint32_t CYCCNT;    __IOM uint32_t CPICNT;    __IOM uint32_t EXCCNT;    __IOM uint32_t SLEEPCNT;  __IOM uint32_t LSUCNT;    __IOM uint32_t FOLDCNT;   __IM  uint32_t PCSR;      __IOM struct&#123;    uint32_t COMP;    uint32_t MASK;    uint32_t FUNCTION;    uint32_t RESERVED;  &#125; W[4];&#125; DWT_Type;\n不同的处理器内核所具有的内存断点数量是不一样的，一般CM3、CM4、CM7只有4个，更高级的内核数量会多一些。同时监视4个地址下的内存能够满足很多分析场景。打开内存监视功能需要写入COMP、MASK、FUNCTION三个寄存器，其中COMP寄存器写入待监视的地址，FUNCTION表示监视的方式(5:read 6:write 7:read&amp;write 0表示关闭监视)，MASK表示监视的数据位宽(0:8位 1:16位 2:32位)。\n此外，还需要打开DebugMon_Handler异常中断，需要向CoreDebug模块的DEMCR寄存器第16位和24位写入1，用来打开DebugMon异常。\n代码mem_trap.h\n#ifndef _CPU_MEM_TRAP_H#define _CPU_MEM_TRAP_Htypedef enum &#123;    MEM_TRAP_DISABLE = 0,    MEM_READ_ONLY  = 5,    MEM_WRITE_ONLY = 6,    MEM_READ_WRITE = 7&#125; mem_trap_mode_t;typedef enum &#123;    MEM_8BIT,    MEM_16BIT,    MEM_32BIT&#125; mem_width_t;void mem0_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem0_watchpoint_reset(void);void mem1_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem1_watchpoint_reset(void);void mem2_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem2_watchpoint_reset(void);void mem3_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem3_watchpoint_reset(void);void mem_watchpoint_allreset(void);#endif\n\nmem_trap.c\n#include &quot;mem_trap.h&quot;#include &lt;stdio.h&gt;#if defined(DWT) &amp;&amp; defined(CoreDebug)/* Symbol conflict */#ifdef COMP1#undef COMP1#endif#ifdef COMP2#undef COMP2#endif#define DEF_MEM_WATCHPOINT(i) \\void mem##i##_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width)&#123;\\    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk |\\                        CoreDebug_DEMCR_MON_EN_Msk;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\    DWT-&gt;COMP##i = (uint32_t)addr;\\    DWT-&gt;MASK##i = (uint32_t)width;\\    DWT-&gt;FUNCTION##i = (uint32_t)mode;\\&#125;\\void mem##i##_watchpoint_reset(void)&#123;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\&#125;void mem_watchpoint_allreset(void)&#123;    DWT-&gt;FUNCTION0 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION1 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION2 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION3 = MEM_TRAP_DISABLE;&#125;DEF_MEM_WATCHPOINT(0)DEF_MEM_WATCHPOINT(1)DEF_MEM_WATCHPOINT(2)DEF_MEM_WATCHPOINT(3)__WEAK void mem_trap_log(int idx, uint32_t pc, uint32_t addr, const char *event)&#123;    printf(&quot;[%d]Trigger memory trap near by %#08x, %s at %#08x\\r\\n&quot;, \\        idx, (unsigned int)pc, event, (unsigned int)addr);&#125;void watchpoint_event_handle(uint32_t *args)&#123;    #define EVENT_PC (args[6])    const char* mem_event[4] = &#123;&quot;READ&quot;, &quot;WRITE&quot;, &quot;READ_WRITE&quot;, &quot;ERROR&quot;&#125;;    if((DWT-&gt;FUNCTION0 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(0, EVENT_PC, DWT-&gt;COMP0, mem_event[(DWT-&gt;FUNCTION0 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION1 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(1, EVENT_PC, DWT-&gt;COMP1, mem_event[(DWT-&gt;FUNCTION1 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION2 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(2, EVENT_PC, DWT-&gt;COMP2, mem_event[(DWT-&gt;FUNCTION2 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION3 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(3, EVENT_PC, DWT-&gt;COMP3, mem_event[(DWT-&gt;FUNCTION3 - 5) &amp; 0x3]);    &#125;&#125;#if defined(__CC_ARM)__asm void DebugMon_Handler(void)&#123;    extern watchpoint_event_handle        /* *INDENT-OFF* */    PRESERVE8    tst lr, #4    ite eq    mrseq r0, msp    mrsne r0, psp    push &#123;lr&#125;    bl watchpoint_event_handle    pop &#123;pc&#125;&#125;#elif defined(__GNUC__)void DebugMon_Handler(void)&#123;    __asm volatile    (        &quot;tst lr, #4                     \\n&quot;        &quot;ite eq                         \\n&quot;        &quot;mrseq r0, msp                  \\n&quot;        &quot;mrsne r0, psp                  \\n&quot;        &quot;push &#123;lr&#125;                      \\n&quot;        &quot;bl watchpoint_event_handle     \\n&quot;        &quot;pop &#123;pc&#125;                       \\n&quot;    );&#125;#endif#endif\n注：这里引用了CMSIS的内容，可以需要inlcude相关的文件。\nDebugMon异常处理函数使用汇编实现的原因是为了在代码中自动定位到触发内存监视的PC指针位置，也就是代码位置。代码的用法也比较简单，当需要保护某块代码中的数据不被异常访问，我们就使用mem0_watchpoint_reset()和mem0_watchpoint()将代码包起来。\n以最开始的那段代码为例：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        mem0_watchpoint_reset();        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);  // 开启保护        delay(1000);    &#125;&#125;void isr_a(void)&#123;    mem0_watchpoint_reset();    *p = *p + 1;    mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当任务C运行时由于内存监视器的存在且打开了对适当内存的保护，访问0x2000地址时就会触发DebugMon异常，该异常函数能够自动分析出任务B中修改数据时的PC指针位置。\n总结在代码中使用这种内存跟踪机制在解决某些内存问题时是很有效的，它对正常的数据访问没有任何影响，但是在正常的数据访问之外，我们在那个数据点上挖了一个陷阱，任何尝试访问数据的代码都会掉入到这个陷阱中并被我们捕获，所有我把这种内存调试方法成为内存陷阱。\n这里对DWT的机制以及寄存器只是一个简单的描述，如果需要了解其中的细节请查阅《ARMv7-M Architecture Reference Manual》，里面有非常详细的描述。\n"},{"title":"TLSF与FreeRTOS-heap4对比","url":"/2024/05/21/TLSF%E4%B8%8EFreeRTOS-heap4%E5%AF%B9%E6%AF%94/","content":"TLSF内存分配器的一些测试和比较FreeRTOS太出名了，就不介绍了。TLSF是一个实时动态内存分配器，可用于嵌入式系统。具有高效的内存使用效率和可预测的响应时间，它具体的工作原理可以参考作者主页上的一些文档。\n我运行了一些简单的测试来比较二者的一些差异：\n\n\n\n\nTLSF\nheap4\n\n\n\n8000次内存分配耗时\n33ms\n13ms\n\n\n3000次碎片化分配耗时\n12ms\n106ms\n\n\n单个内存额外开销\n8字节\n8字节\n\n\n内存固定开销\n3224字节\n16字节\n\n\n内存碎片合并\n支持\n支持\n\n\n线程安全\n支持\n支持\n\n\n多块内存管理\n支持\n不支持\n\n\nrealloc接口\n支持\n不支持\n\n\n对齐分配\n不支持\n不支持\n\n\n堆内存溢出检测\n不支持\n不支持\n\n\ndouble free检测\n不支持\n不支持\n\n\n开源协议\nLGPL\nMIT\n\n\n注：性能数据仅仅反映在我的测试平台和测试用例上的结果\n简单总结：\n\n相比于heap4，tlsf可管理多块内存，支持realloc接口，功能上更完善。但是其内存固定开销较大，可能不适合管理较小的内存。在分配速度上，在分配连续内存时，heap4的分配速度优于TLSF。但是在遇到较多内存碎片后，tlsf的优势就比较明显了，其可预测的分配时间更适合高实时性的场景。\n\nheap4采用空闲链表管理空闲内存，当内存碎片较多后，内存分配性能将急剧下降。tlsf采用bitmap和空闲链表两级管理的方式，可实现O(1)的分配时间复杂度。\n\nheap4通过portBYTE_ALIGNMENT设置全局字节对齐方式。tlsf通过BLOCK_ALIGN设置全局字节对齐方式。均不支持分配时指定对齐方式。\n\nmalloc(0)的行为差异。tlfs会按照一个最小快进行分配(8字节)。heap4返回空指针并在内部触发内存申请失败的hook。\n\n二者都具备一些辅助内存调试的接口。作为经过多个版本迭代的发行版软件，它们都具有较高的可靠性。选择TLSF还是heap4，主要看你的需求。它们都具备良好的性能，并且都支持多线程。\n\n\n我看到另外一个分支版本tlsf，它支持对齐分配、更低的单块内存开销(4字节)，但是它没有实现线程安全的机制。\n内存分配器通常最为系统基础组件存在，因此选择一个好的内存分配器，可以带来更好的系统稳定性。我在之前总结了关于内存分配器对堆内存故障的一些内容，我就不单独发表了，一并贴在后面。\n堆内存使用中常见的4种问题\n1.内存泄漏 (memory leak)内存使用的基本流程是申请-&gt;使用-&gt;释放。如果内存不释放就会导致对该段内存的管理失去了控制，如果频繁发生这种问题，就会导致可用内存越来越小。通常来说在程序正常运行过程出现严重的内存泄漏时，通过观察可用内存的变化量可以判定是否出现了内存泄漏问题。如何进一步定位这个内存泄漏点呢？这个可以通过内存申请释放日志分析，如果内存泄漏频率较高能够非常容易就定位到问题所在。对于大块内存的泄漏一般也比较容易发现。如果出现较小内存的泄漏且频率不高的话需要长时间的测试才能发现问题。\n\n2.重复释放(double free)内存重复释放比较好理解，就是内存经历了申请-&gt;释放-&gt;再释放的过程。显然第二次释放这段内存会出现无法预料到的情况。该问题导致的具体现象也不确定。通常只能通过经验分析是否发生了该问题，出现该问题可能导致两个以上的线程出现异常行为。虽然不容易确认是否发生了double free，但是如果确认发生了double free，通常能够通过内存的申请释放日志找到问题点。但是如果某些情况可能会使问题变得比较棘手，即线程A申请内存指针p1，随机释放p1指针，线程B申请到同样的内存指针p1，线程A再次释放指针p1，即线程A释放了两次内存。如果使用log分析，能够看到这个地址的申请和释放都是成对的，很难定位问题点。对于前面这种情况，显然线程B会使用到一块不安全的内存，进一步导致UAF等问题。当出现这样的问题，设计一种malloc\\free成对机制就能较快的定位问题，常见的作法是添加动态标记，这样其它线程就不能释放一个不属于它的指针了。\nstatic inline uint32_t malloc_flag_generate(void)&#123;    static uint16_t id = 0;    return (id++ &lt;&lt; 16) | (rand() &amp; 0xffff);&#125;void *malloc_f(size_t size, uint32_t *flag)&#123;    if(!flag) return NULL;    uint32_t *ptr = malloc(size + sizeof(uint32_t));    *ptr = *flag = malloc_flag_generate();    return ptr++;&#125;void free_f(void *ptr, uint32_t *flag)&#123;    uint32_t *_ptr = ptr;    _ptr--;    assert(*flag == *_ptr);    free(_ptr);&#125;\n\n3.内存越界(memory overflow)内存越界不同于前面两种内存释放操作不合理导致的问题，它主要是由于内存申请的长度小于实际想要使用的长度，或者是实际使用的内存长度超过了分配的内存长度。内存越界可能导致篡改其它应用数据。但在某些内存管理器下可能出现破坏堆内存链表的情况，进一步导致的问题就是使得分配器分配出异常的内存空间地址。对于第二种问题情况，具体出现的问题现象也不确定，只能通过经验判断。检查内存溢出是内存分配器的一个基础安全能力，业内通用的做法是在内存区域的边界添加redzone，在释放内存时检查redzone进行分析，判断是否发生溢出。如何构造redzone也是一个复杂的问题，包括redzone填充的数据以及数据长度，随机的redzone内容和长度是一种安全的算法，但在具体的实施上通常比较麻烦，且在面对精心构造的shellcode时也会出现绕过的情况，应对该问题时一些内存调试手段有助于分析该问题，例如内存断点、陷阱等。\n\n4.内存非法访问(UAF)指针p指向一段合法申请的内存空间，当释放p指向的内存空间后，p指针未置NULL，所以理论上来说通过p指针任然能够访问该段内存下的数据。显然后续通过p指针访问数据都属于非法的访问。该问题配合堆内存管理器的一些特性能够导致系统出现严重的安全性问题。该问题通常不易发现，它如果没有造成明显的问题，很难定位问题点。内存分配器加入一些检测机制能够规避某些场景下的use after free问题，释放内存时，对内存中填充关键字。在分配内存时再检测关键字有没有被污染，以此来判断UAF问题。但是这种检测机制作用有限，它不能检测到上面场景下发生的问题。\n\n\n"},{"title":"单片机总线选择焦虑","url":"/2022/12/11/%E5%8D%95%E7%89%87%E6%9C%BA%E6%80%BB%E7%BA%BF%E9%80%89%E6%8B%A9%E7%84%A6%E8%99%91/","content":"\n当你有多个选择，但是每个选择都不完美时，就会出现选择焦虑！\n\n\n最近在优化单片机上USB协议栈内的代码，我发现了一个我之前没有被注意到的地方，那就是写入到USB端点上的数据是由DMA自动完成的，涉及到DMA的内存区域都需要特别对待，而我之前就是将它当作普通内存处理，也就是普通内存的缓存策略(庆幸运行了这么久居然没出错)。\n由于单片机内的内存分布比较复杂，所以我决定在解决这个问题时顺便优化一下内存布局。这是单片机的总线连接情况，看起来比较复杂。\n\n仔细看看总线的连接情况，发现一个很蠢的事情，目前USBHS1(可以理解为USB的专用DMA)操作的数据位于AXISRAM上，中间要经过一个D2-to-D1 AHB bus的通道，我认为这太不合理了，因为D2域也有三块内存，我决定将USB的缓存调整到D2的SRAM3上，毕竟AXISRAM内存与CPU的交互较多，这样USB的DMA传输数据就几乎能独享到SRAM3的内存总线带宽了，而不用占用D1域的总线矩阵。这样还有一个好处是使用MPU配置缓存策略也比较方便。\n\n不过我改完了之后就发现了新的问题。因为USB协议栈中实现了大容量存储设备实例，需要用到内存卡SDMMC1，这就出现一个新的问题。SD卡的数据操作也是专用的DMA，我使用的是SDMMC1，硬件已经决定了我无法调整到SDMMC2上。观察D1总线矩阵就能看到，SDMMC1无法访问到D2域上。\n\n要解决这个问题就只能让MDAM或者CPU帮忙，把数据从D2域拷贝到D1域的AXISRAM中，然后SDMMC的DMA就能操作数据了。\n为了优化数据总线上的负载反而带来了更多的数据总线操作，这就更蠢了。\n在这里纠结了好久，最后选择在AXISRAM末尾使用约8K字节的数据用来作为USB的缓存，并将它配置为非缓存的模式。\n还是感觉不爽😔，为什么D1域上的SDMMC1不能访问D2，是故意这样设计的吗？\n"},{"title":"初学射频信号","url":"/2023/05/07/%E5%88%9D%E5%AD%A6%E5%B0%84%E9%A2%91%E4%BF%A1%E5%8F%B7/","content":"\n从事嵌入式软件开发4年有余，我自认为还是有相当多的知识和技能存在欠缺，所以近年来一直保持良好的学习态度，持续充实自身的技能。从之前的文章内容能够看出，我主要围绕嵌入式软件开发的多个方面记录自己的学习心得。但实际上不仅限于此，在过去的一年中有很多机会接触到射频开发，所以学习到了很多有意思的新知识，这对我来说算是一件很有乐趣的事情。这种乐趣来自于对未知的探索，因为我并非专业的科班出身，所以在这之前对射频开发领域是完全一片空白的，因此刚开始对我来说这是一个很大的挑战，但是我逐渐将它变为一种乐趣。以下内容来自与一位初学者的日记。\n\n从射频信号开始什么是射频信号？通俗来说就是特定频率的电磁波信号，但是这个描述太笼统了，因为大多数电子产品都会发射一些干扰信号，这些我并不认为这是射频信号，我理解的射频信号是具有一定信号强度且能够远距离传输的电磁信号。\n射频信号的产生射频信号需要依靠射频电路和天线来产生。通过时钟源、PLL、放大器就能组成简单的射频电路，接触过单片机的开发者应该都听说过PLL这个词，通过它能够得到我们想要的频率的信号，例如单片机内部的主时钟信号、射频信号等。可能有些人对单片机上的晶振有误解，认为单片机的时钟是由晶振提供的，这是不正确的，如果单片机内部具有PLL，那么时钟信号由PLL提供，晶振仅仅是一个时钟参考的作用，用于校正PLL输出的时钟频率。\nPLL的工作原理PLL的全称是Phase-Locked Loop，即相位锁定环路，下图是某PLL信号内部的模块框图，这里只关心最关键的PLL部分。信号的来源是那个正弦符号的那个模块（VCO），它直接输出我们想要的频率，而它输出频率的准确性就是依靠PLL的负反馈机制完成的，输出的信号经过N分频后与参考信号进行比较，当频率和相位不一致时，会调节VCO的电压来调节VCO输出的频率，这个调节是快速且准确的。这个负反馈环就是相位锁定环路，PLL一般先锁定频率，保证频率没有误差，再锁定相位，保证相位一致。CPout和VTune通过一个外部电路连接，一个滤波电路，形成一个更加稳定的PLL环路，这个外部电路叫做环路滤波器。\n天线为什么能发射电磁波我认为这里采用了和变压器类似的原理，我们的天线可以看成变压器的初级绕组，通过施加高频电流，使得天线周围产生交变电场和磁场，距离天线一定距离的电磁场信号能够向空间外自由传播，这就将射频信号发射到空中了。射频信号的接收原理类似，就是空中的电磁场信号耦合到了天线上，相当于变压器的次级绕组。为什么电磁信号能够在空中自由的传播，我目前还不能够完全理解，大致就是变化的电磁和磁场能够相互感应产生，具体到理论上可能需要深入理解麦克斯韦方程。\n调制发射射频信号的意义很大程度上是为了在空中传递信息，因为低频的信号的天线不方便制作，因为天线需要1/4波长的长度，当直接发射一个低频信号时所需的天线就显得太庞大了。把需要传递的信号叠加到高频信号上就是一个和好的方法，射频信号承载信息的过程就是调制，调制的方法由很多，有调相、调频等，还可以组合多种不同的调制方法以充分利用信道带宽。什么是信道？传输信息的通道，这里特指射频通道。强调信道的意义是因为所有的空中射频信号都同时存在，而却别它们的就只有频率不同而已，信号因为调频等原因它占用的频率不是一个固定的点，而是一段频率，例如蓝牙的某个信道频率范围是2401~2403MHz，显然整个自由空间的信道是有限的，因为高频信号的产生和传输都是很难的。通过混频器能够将低频信号和高频信号进行叠加合成出另一个射频信号，在这个射频信号中包含了我们先要传递的信号。而那个低频信号就是基带信号，高频信号就是有PLL产生的本振信号。\n阻抗匹配在一般的电路设计中都会考虑阻抗匹配，阻抗匹配是为了功率能够最大程度的传递出去，当阻抗不匹配，信号的功率就不能最大化的进行传递，导致信号质量不佳，更严重的是信号可能引起反射等问题。考虑一个简单的电压源，其内部电阻r，电压源外接一个电阻R构成一个简单的回路，为了使得电阻R的功率最大，显然当R=r时其能够获得的功率最大，这时输出阻抗r和输入阻抗R相等，这就是阻抗匹配。在射频电路中除了电阻外，还有电抗(复阻抗中的虚部)，它们共同组成了射频电路中的阻抗。我尝试理解射频电路中的阻抗匹配，发现这是一门非常复杂的学问，还要解决一些偏微分方程。总之保证阻抗匹配是射频电路设计的一大要点。\n如果想要强行调整一个射频端口的阻抗怎么办呢，手动计算肯定是一个非常麻烦的过程，史密斯圆图是一个非常好的工具，它是用于确定射频传输阻抗的基本工具，通过它也能调整端口的阻抗，可以使用史密斯圆图软件进行阻抗的精确计算。史密斯圆图的用途非常广泛，矢量网络分析仪中表示端口的阻抗通常也是在史密斯图上表示。\n一般的射频连接件都使用50欧姆的阻抗进行设计，在设计射频电路时，不同射频模块的连接部分就需要考虑两端的阻抗要一致，对于印刷电路板来说，上面的导线也是射频电路的一部分，所有电路的走线也需要进行阻抗匹配，需要综合考虑PCB布线的线宽、拐角等，此外PCB基板材料的层厚、材料等都是影响PCB走线阻抗的因素，一般的RF4材料的PCB介电常数不稳定，通常不作为高质量射频电路板考虑，进口的罗杰斯PCB是射频电路板中用的较多的。最近国产的特氟龙材料的PCB也能实现稳定优质的介电常数，使用它做了一块天线阵列，效果还比较好。\nS参数学习射频信号，肯定离不开S参数，S参数不仅仅是用于射频领域，它用于所有信号领域。它是描述信号完整性的一个工具，S参数的全程是Scatter参数，即散射参数，一般用于描述一个二端口网络的频域特性。使用S11描述一个端口的反射特性，通常可以用它描述一个天线的质量好坏，S11可以转换为SWR(驻波)表示，一般天线的驻波小于1.2就说明天线质量比较好。S21通常用于描述二端口器件的插入损耗，对于一般的滤波器，在通带内S21大于-0.5dB。\n谐波谐波是一个很有意思的东西，正经的射频信号是标准的正弦波，但是如果它经过分频或者一些其它处理，那么在信号中就会产生谐波成分，谐波就是原始基波信号频率整数倍的频率的信号。一个信号分频后通常是方波，使用傅里叶分解后，很明显能够看到多阶的谐波。此外，一个标准的正弦波信号经过一个非线性元件时，在其内部同样会产生谐波信号的成分，非线性元件就是伏安特性曲线不是一条直线，在其非线性区域带入正弦信号表达式，经过泰勒展开后可以得到原始正弦信号的多阶谐波信号成分，通常阶数越高其振幅越弱。\n接收射频信号射频信号经过在空气中传输后，其信号强度肯定会衰减的，其信号衰减的规律符合自由空间损耗模型，信号衰减值与传播距离的对数线性相关，与信号频率的对数线性相关。大部分待接收的信号强度都比较低，一般在-80dBm以下。为了解析如此低的信号，就需要放大器来放大这个信号，一般使用低噪声放大器，它通常用于放大接收端的微弱信号。将接收到的信号可以采用和发射端类似的方法进行混频来解析我们想要的信号，也就是下变频。下变频后的信号称为中频信号，中频的意思就是中间频率，因为它还不是最终想要的信号。中频信号一般还需要使用带通滤波器进行处理，因为这里需要一把下变频带来的镜频干扰，过滤难度一般和中频大小和滤波器的带宽有关。中频信号经过ADC采样后就得到了基带信号。\nIQ调制现在接收芯片都使用IQ正交调制，即基带信号使用一对正交的信号进行表述，I相就是原始信号下变频后的信号，Q相信号时原始信号经过90度的相位旋转后下变频后的信号，IQ调制能够解决镜频干扰等问题，在信号发射端还能实现扩频的效果。在复平面坐标下，使用I表示实部，Q表示虚部，每一对IQ就表示一个复平面下的一个点，将基带数据映射到复平面上就是IQ调制的过程。\n调制方法信号的调制方法有调频、调幅、调相这三种或者同时使用多种不同类型的调制方法。调幅就是载波频率保持不变，载波信号随着基带信号调整幅度。调频就是载波信号幅度不变，但其瞬时频率的偏移随基带信号做线性变化。调相就是载波信号的相位随基带信号线性变化。\n具体来说，调整方法有AM、FM、PSK、QPSK、QAM、16QAM等。\n星座图表示方法对于具体的调整方法来说，都可以使用IQ调制实现，其调制符号在复平面上的图像就构成了一个星座图像，通过星座图像可以更加清晰理解信号解调的过程。这是一个8PSK调制的星座图。\nOFDMOFDM是正交频分复用的简称，它是一种信号复用的方法，它是一种应用在具体调制方法上层的技术。它将传统的一个信道划分为多个信道，能够更加充分的使用信道带宽。更具体的来说它主要是为了解决再宽带信道中的频率选择性衰落问题而广泛运用的。我自己使用OFDM+QPSK实现了OFDM的收发代码，主要是使用傅里叶变换来实现的，OFDM中使用循环前缀来进行数据同步是一个比较好的设计。不过我在实现OFDM时遇到过一个问题一直没有解决，就是当传输信道中存在相位噪音时，QPSK星座图出现了旋转偏移，显然对于QPSK来说偏移超过90度时就会导致无法正确解调，应该有方法能够解决星座图旋转的问题，不过我目前还不会。\n软件无线电(SDR)一般人很难同时接触射频电路设计和信号调制解调算法的设计。为了简化软件开发人员的学习难度，使用软件无线电技术，可以使用软件的方法直接输出射频信号。这里需要使用相关的射频开发板，通过USB和主机连接，再主机上通过一定的算法生成IQ信号，将IQ信号传输到射频开发板上由射频板输出信号，这对软件开发人员来说是一个很友好的过程。同理信号的接收也可以使用SDR完成。我自己也使用软件无线电开发实际参与多个项目开发，感受到了软件无线电的强大。\n我使用过两款SDR设备，LimeSDR和HackRF，都具有易用的SDR，使用体验也比较好。\n"},{"title":"在RTOS中如何优雅的处理Fault异常","url":"/2021/11/06/%E5%9C%A8RTOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86Fault%E5%BC%82%E5%B8%B8/","content":"ARM处理器下的Fault异常ARM处理器当发生异常事件后就会暂停当前程序的运行，处理器进入异常模式，响应一个来自处理器内核或者外设的中断请求。\n这里想要处理的Fault异常就是ARM处理器多个异常中的一类，以Cortex-M7内核的ARM处理器为例，主要的Fault异常有HardFault、BusFault、UsageFault、MemManage。当发生这些异常就表示程序出现了比较严重的错误，进而导致“死机”。\n嵌入式实时操作系统下发生Fault异常后会如何处理常见的各种嵌入式实时操作系统(FreeRTOS、UCOSII/III等)都没有特别的对Fault进行处理，基本上都是按照默认处理方式来解决，也就是让处理器进入死循环。\nvoid xxxFault_Handler(void)&#123;    while (1);&#125;\n\n这种处理方式是无可厚非的，因为程序本身发生了致命的故障，暂停当前程序的运行或许能够避免程序发生更严重的错误。大多数单线程嵌入式软件(NoOS)都是这样处理的，一个地方的错误会导致整个系统崩溃。\n但是在多任务环境下，RTOS提供了多线程运行的机制，线程之间是相对独立的运行。基于此，在RTOS中采用这种暂停处理器的方式来处理异常就不是最佳的解决方案了。例如有两个线程在运行(线程A和线程B)，线程B在正常运行，线程A由于地址访问错误，导致触发HardFault异常，Fault异常会暂停整个处理器的运行，不但使发生错误的A线程停止了运行，线程B也被牵连导致运行停止。所以在RTOS中发生异常时想要将出现Fault异常而带来的损失降低到最小，也就是单独停止错误线程的运行而不结束整个系统的运行。\n发生Fault异常后如何暂停异常线程首先需要知道的是，异常并不总是由线程运行导致的，还有用户中断处理程序(IRQ)、RTOS内核调度等，在这些地方发生的异常目前看起来是比较难处理的，所以后面主要处理的就是在线程中发生的Fault异常。这里以FreeRTOS操作系统为例，对于其他的操作系统都能实现类似的解决方案，可以结合实际的处理器、操作系统平台进行修改移植，因为核心思想是一致的。当发生Fault后不能简单的while(1)处理了，更优雅且安全的的实现要完成两步动作：\n\n暂停错误线程的运行\n将CPU的执行权限切换到正常线程中\n\n清理异常线程这是在FreeRTOS下的一个实现：\n// fault_handle.c#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;#if (INCLUDE_xTaskGetIdleTaskHandle == 0)#warning &quot;Unable to switch to a valid task!&quot;#endifvoid* clean_fault_task(void)&#123;    extern void* pxCurrentTCB;    TaskHandle_t fault_task = pxCurrentTCB;    if(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)&#123;        /* RTOS not running. */        return NULL;    &#125;    /* Switch to Idle task and delete current fault task. */    // log_info(&quot;task(%s) fault.\\n&quot;, pcTaskGetName(task));    #if defined(INCLUDE_xTaskGetIdleTaskHandle) &amp;&amp; (INCLUDE_xTaskGetIdleTaskHandle == 1)    pxCurrentTCB = xTaskGetIdleTaskHandle();    #else    return NULL;    #endif    vTaskDelete(fault_task);    return pxCurrentTCB;&#125;\n简单解释一下这段代码的含义。首先需要判断操作系统的任务调度有没有运行，如果操作系统还没有启动，这就说明异常不是在线程中触发的，这就不在解决范围内。然后找到一个可以切入的线程，而且它是处于就绪态的任务，显然最好的选择就是Idle线程了。通过xTaskGetIdleTaskHandle()获取到Idle线程的句柄，赋值给pxCurrentTCB。最后调用vTaskDelete()删除当前错误的线程，并返回新的当前线程就好了。\n这里为什么需要先获取新的的线程再删除旧的错误线程呢？这就需要理解线程删除中发生了什么。\n// void vTaskDelete( TaskHandle_t xTaskToDelete )if( pxTCB == pxCurrentTCB )&#123;    /* A task is deleting itself.  This cannot complete within the    * task itself, as a context switch to another task is required.    * Place the task in the termination list.  The idle task will    * check the termination list and free up any memory allocated by    * the scheduler for the TCB and stack of the deleted task. */    vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );    /* Increment the ucTasksDeleted variable so the idle task knows    * there is a task that has been deleted and that it should therefore    * check the xTasksWaitingTermination list. */    ++uxDeletedTasksWaitingCleanUp;    /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as    * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */    traceTASK_DELETE( pxTCB );    /* The pre-delete hook is primarily for the Windows simulator,    * in which Windows specific clean up operations are performed,    * after which it is not possible to yield away from this task -    * hence xYieldPending is used to latch that a context switch is    * required. */    portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );&#125;// ...if( pxTCB == pxCurrentTCB )&#123;    configASSERT( uxSchedulerSuspended == 0 );    portYIELD_WITHIN_API();&#125;// ...\n这是FreeRTOS线程删除时是进行的一些操作，当判断为删除当前线程(pxCurrentTCB)是会进行的额外操作。FreeRTOS是不能直接删除线程自身的，它是将自己标记为预删除的状态，然后操作系统切换到Idle线程中时去清理这些需要被删除的线程，此外这里还会进行一次主动的线程调度，这是非常危险的，当线程出现错误后，如果继续进行常规调度流程，这可能会涉及到访问错误线程的栈空间，这是不可靠的(导致更严重的错误)。所以线程清理仅仅是让操作系统不再调度这个错误的线程，与原错误线程相关的操作降低到最少。\n进行一次特别的线程调度有何特别？这里的线程调度操作将没有切出线程，只有切入线程，因为本该切入的线程在刚刚前面那段代码中删除了。所以这里的线程调度就不能直接使用系统的API完成调度，这里需要自己实现一段线程调度的代码。这里以一段ARM汇编来实现这段调度程序。\nbic r3, lr, #7cmn r3, #8beq .endbl clean_fault_taskcmp r0, #0beq .endldr r0, [r0]ldmia r0!, &#123;r4-r11, r14&#125;tst r14, #0x10it eqvldmiaeq r0!, &#123;s16-s31&#125;msr psp, r0isbmov r0, #0msr basepri, r0bx r14.end: b .end\n这段汇编代码分为4个部分，第一段，这里是通过LR寄存器的值来判断触发异常是否是在普通的线程中，如果不是在线程中触发的异常将不能处理，直接跳转到最后的死循环中。第二段，调用前面实现的任务清理函数，清理掉错误线程并选择一个新的可运行线程(这里就是Idle线程)，函数返回后，判断r0，如果无法清理错误线程或者没有可用的线程，仍然跳转到最后的死循环中。第三段，r0就是前面函数返回时传递过来的新的线程句柄，它存储的第一个字段就是该线程的栈，栈里面存储的内容结构涉及到FreeRTOS线程调度相关的内容。这里就简单说一说FreeRTOS的任务调度时的栈内结构，栈里面存储的是r4-r11寄存器，这些寄存器是ARM异常处理无法自动保存的。此外还有保存r14(lr)寄存器，它是用来判断栈内是否存储了浮点寄存器的，LR寄存器的bit4指示了线程是否在使用浮点寄存器。由于s0-s15以及浮点状态寄存器FPSR是直接由ARM异常自动完成存取了，所以这里还需要根据线程是否使用了浮点寄存器来存储s16-s31寄存器。\n将待切入运行的线程相关的寄存器都恢复完毕后，就可以退出异常并转入到新的线程去执行了，也就是第四段代码的内容。\n封装异常处理将前面汇编代码进行封装，这样就能够处理多个Fault异常了。\n// fault_handle.h#ifndef _FAULT_HANDLE_H#define _FAULT_HANDLE_H#if defined(__CC_ARM)#define FAULT_HANDLER()#elif defined(__GNUC__)#define FAULT_HANDLER() \\    (&#123; \\    __asm volatile ( \\        &quot;   push &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot; \\        /* Exception not returned to Handle mode */ \\        &quot;   bic r3, lr, #7                  \\n&quot; \\        &quot;   cmn r3, #8                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;                                   \\n&quot; \\        /* Clean fault task and get the pxCurrentTCB address. */ \\        &quot;   bl clean_fault_task             \\n&quot; \\        &quot;   cmp r0, #0                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;   add sp, #24                     \\n&quot; \\        &quot;                                   \\n&quot; \\        /* The first item in pxCurrentTCB is the task top of stack. */ \\        &quot;   ldr r0, [r0]                    \\n&quot; \\        /* Pop the registers that are not automatically saved on \\           exception entry and the critical nesting count. */ \\        &quot;   ldmia r0!, &#123;r4-r11, r14&#125;        \\n&quot; \\        /* Is the task using the FPU context?  If so, pop the high vfp registers too. */ \\        &quot;   tst r14, #0x10                  \\n&quot; \\        &quot;   it eq                           \\n&quot; \\        &quot;   vldmiaeq r0!, &#123;s16-s31&#125;         \\n&quot; \\        /* Restore the task stack pointer. */   \\        &quot;   msr psp, r0                     \\n&quot; \\        &quot;   isb                             \\n&quot; \\        &quot;   mov r0, #0                      \\n&quot; \\        &quot;   msr basepri, r0                 \\n&quot; \\        &quot;   bx r14                          \\n&quot; \\        &quot;                                   \\n&quot; \\        &quot;.end&quot; END_LINE &quot;:                  \\n&quot; \\        &quot;   pop &#123;r0, r1, r2, r3, r12, lr&#125;   \\n&quot; \\        ); \\    &#125;)#define _STR2(x) #x#define _STR(x) _STR2(x)#define END_LINE _STR(__LINE__)#endif#endif\n这段代码实现比前面的汇编多了一些内容，主要是要考虑堆栈平衡以及异常线程清理失败后的恢复线程的问题。前面处理失败是进入一个死循环中，这里没有进入死循环。处理失败后所有的寄存器会恢复到处理前的状态，这样能够为其它错误分析类的程序提供帮助，比如我前面有篇文章讲解了如何进行栈回溯，那段程序就能够衔接在这段程序前面或者后面，帮助分析异常问题。\n这里需要特别提醒，栈平衡是非常重要的一点，尤其是使用汇编来操作栈空间时。要知道，bx lr后后面的代码是无法继续执行的，所以需要保证进入Fault时到执行bx lr时msp栈是平衡的。如果栈不平衡就会导致栈内存空间异常减小。这段宏定义是内联汇编，当它嵌入到C函数后，函数头是否还有栈操作我不确定。可能不同的编译器情况不一样，但我用GCC时没有发现问题。如果你想要把这段代码移植到你的系统中，最好仔细核对栈平衡相关的内容。\n相比于最开始的while(1)，新的异常处理程序可以写为：\nvoid xxxFault_Handler(void)&#123;    FAULT_HANDLER()；    while (1)    &#123;    &#125;&#125;\n这样当一个线程执行出现异常后能够自动停止并继续进行系统调度，保证了系统的持续运行。\n总结通过这种处理方式能够解决线程错误带来的死机问题，但是在实际的生产运行过程中，还需要其它辅助性质的程序来帮助程序更加稳固的运行，例如可以设计一个基于定时器的守护任务，当它监视到线程崩溃结束后自动重启它。这样才更加具有实际意义。\n这段程序任然有不完美的地方，比如它不能处理非线程Fault异常，还有线程清理时是暂停它还是删除它？删除线程后相关资源是否及时回收？这些问题都需要结合实际项目进一步完善。\n"},{"title":"复刻一个BlackMagicProbe","url":"/2024/09/05/%E5%A4%8D%E5%88%BB%E4%B8%80%E4%B8%AABlackMagicProbe/","content":"Black MagicBlack Magic Probe是一个内建GDB server的嵌入式芯片调试器，可以用来调试ARM、riscv等单片机。关于该调试器的详细信息可以参考官网网。\n克隆版本我基于官方的固件，设计了一个电路板，做了一个自己的版本，主要的功能同官方版本一样，只是多了目标设备电源控制和电压检测功能。\n\n\n图1. 自己设计制作的BMP\n\n\n常用命令这里记录一些该调试器常用的一些命令，方便以后查阅。\n# 查询BlackMagic设备的串口号# powershellGet-CimInstance -ClassName Win32_SerialPort -Filter &quot;PNPDeviceID like &#x27;USB\\\\VID_1D50&amp;PID_6018&amp;MI_00%&#x27;&quot; | Select -ExpandProperty DeviceID | Set-Variable -Name BMP_GDB_PORT# 固件一键下载arm-none-eabi-gdb -nx --batch -ex &#x27;target extended-remote \\\\.\\\\COM21&#x27; -ex &#x27;monitor swdp_scan&#x27; -ex &#x27;attach 1&#x27; -ex &#x27;load&#x27; -ex &#x27;compare-sections&#x27; -ex &#x27;kill&#x27; binary.elf# GDB命令# 连接调试器target extended-remote \\\\.\\COM21# 使用SWD模式扫描设备monitor swdp_scan# 使用JTAG模式扫描设备monitor jtag_scan# 连接目标设备attach 1# 设置下载线频率monitor freq 900k# 目标设备供电控制monitor tpwr enablemonitor tpwr disable# 下载固件load binary.elf# 比较固件compare-sections# 使用RTT功能monitor rtt# 查看寄存器info registers# 运行目标设备startrun# 断点调试break &lt;function&gt;break &lt;file&gt;:&lt;line&gt;watch &lt;var&gt;# 退出调试器detachkill\n\n在STM32CubeIDE中调试新建一个调试配置，类型选择GDB Hardware Debug。\n在Debugger选项框中GDB命令输入arm-none-eabi-gdb。勾选Use remote target，Debug server选择Generic Serial, 协议选择extended-remote，端口选择BMP的串口号(例如\\\\.\\COM21 or COM6)。\n在Startup选项框中初始命令输入：mon tpwr enablemon freq 900kmonitor swdp_scanattach 1\n如果仅调试不下载程序则不勾选load image。可以为下载单独建立一个配置，否则每次下载都要执行一遍下载动作(影响芯片Flash寿命和调试的速度)。\n勾选Set breakpoint at, 后面输入main。表示在main函数建立一个默认断点。在下面的命令框中再输入run指令，这样可以每次启动调试都会复位一次程序，如果不想复位则不输入。\n保存该配置即可开始调试。\n在VSCODE中调试我最开始的想法是使用VSCODE中原生的调试组件，但是在进行了一些尝试后发现Native Debug存在一些问题。这似乎是cppdbg不太兼容串口远程调试，在执行附加进程时会出现一些故障，可能是GDB server交互存在一些兼容性问题。我在检索相关资料时也发现其它网友存在该问题。\n这个无法使用的调试配置也可以参考：\n&#123;    &quot;name&quot;: &quot;Black Magic Probe(invalid)&quot;,    &quot;type&quot;: &quot;cppdbg&quot;,    &quot;request&quot;: &quot;launch&quot;,    &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,    &quot;MIMode&quot;: &quot;gdb&quot;,    &quot;targetArchitecture&quot;: &quot;arm&quot;,    &quot;logging&quot;: &#123;&quot;engineLogging&quot;: true&#125;,    &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,    &quot;miDebuggerPath&quot;: &quot;arm-none-eabi-gdb&quot;,    &quot;customLaunchSetupCommands&quot;: [        &#123;&quot;text&quot;: &quot;cd $&#123;workspaceRoot&#125;/Debug&quot;&#125;,        &#123;&quot;text&quot;: &quot;file $&#123;workspaceFolderBasename&#125;.elf&quot;&#125;,        &#123;&quot;text&quot;: &quot;target extended-remote \\\\\\\\.\\\\COM23&quot;&#125;,        &#123;&quot;text&quot;: &quot;monitor tpwr enable&quot;&#125;,        &#123;&quot;text&quot;: &quot;mon freq 500k&quot;&#125;,        &#123;&quot;text&quot;: &quot;monitor swdp_scan&quot;&#125;,        &#123;&quot;text&quot;: &quot;attach 1&quot;&#125;,        &#123;&quot;text&quot;: &quot;load&quot;&#125;,        &#123;&quot;text&quot;: &quot;cd $&#123;workspaceRoot&#125;&quot;&#125;,        &#123;&quot;text&quot;: &quot;set mem inaccessible-by-default off&quot;&#125;,        &#123;&quot;text&quot;: &quot;break main&quot;&#125;    ],    &quot;serverLaunchTimeout&quot;: 10000,    &quot;windows&quot;: &#123;        &quot;miDebuggerPath&quot;: &quot;arm-none-eabi-gdb.exe&quot;    &#125;&#125;\n\n无法使用原生调试，那就只有依赖于VSCODE插件，很流行的一个调试插件cortex-debug支持Black Magic Probe，这里列出下载脚本和调试脚本。\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;BMP Download&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;executable&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;type&quot;: &quot;cortex-debug&quot;,            &quot;device&quot;: &quot;&quot;,            &quot;runToEntryPoint&quot;: &quot;main&quot;,            &quot;showDevDebugOutput&quot;: &quot;raw&quot;,            &quot;servertype&quot;: &quot;bmp&quot;,            &quot;interface&quot;: &quot;swd&quot;,            &quot;BMPGDBSerialPort&quot;: &quot;\\\\\\\\.\\\\COM23&quot;,            &quot;powerOverBMP&quot;: &quot;enable&quot;,            &quot;preLaunchCommands&quot;: [&quot;mon freq 500k&quot;]        &#125;,        &#123;            &quot;name&quot;: &quot;BMP Debug&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;executable&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;type&quot;: &quot;cortex-debug&quot;,            &quot;device&quot;: &quot;&quot;,            &quot;runToEntryPoint&quot;: &quot;main&quot;,            &quot;showDevDebugOutput&quot;: &quot;raw&quot;,            &quot;servertype&quot;: &quot;bmp&quot;,            &quot;interface&quot;: &quot;swd&quot;,            &quot;BMPGDBSerialPort&quot;: &quot;\\\\\\\\.\\\\COM23&quot;,            &quot;powerOverBMP&quot;: &quot;enable&quot;,            &quot;preAttachCommands&quot;: [&quot;mon freq 500k&quot;]        &#125;    ]&#125;\n\nBlack Magic还支持RTT功能，可以使用postAttachCommands选项去手动开启，我简单测试了一下，似乎会影响调试功能。\nPS:cortex-debug参数说明\n总结Black Magic Probe非常的灵活好用，不依赖特别的驱动，支持主流的三大操作系统，且不需要类似openocd的中间适配层就能实现完整的嵌入式调试。\n相较于Jlink等调试器来说，它的性能不算特别强大，但它可以和GDB调试器直接交互，使得它的灵活性更强。\n目前该调试器的缺陷是速度问题，USB2.0FS在某些情况下可能会出现一些意外的情况。后续我想制作一个高速版本的BMP来改进使用体验。\n"},{"title":"在创建FreeRTOS任务时容易忽略的一个问题","url":"/2024/07/11/%E5%9C%A8%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/","content":"面向对象的编程思想经常出现在嵌入式软件开发过程中，通常将一组相关的业务逻辑及其相关联的数据封装为一个实例对象以方便数据和方法的集中管理，尤其是在该实例对象还涉及一个关联的任务时，为了将相关的数据传入线程，将所有的数据封装起来是一种非常合理的操作。下面是一段这样的代码：\ntypedef struct &#123;    TaskHandle_t task;    const char *str;    int cnt;&#125; hello_obj_t;void hello_task(void *pvParameters)&#123;    hello_obj_t *obj = (hello_obj_t *)pvParameters;    for(int i = 0; i &lt; obj-&gt;cnt; i++)&#123;        printf(&quot;%s\\n&quot;, obj-&gt;str);        vTaskDelay(1000);    &#125;    TaskHandle_t task = obj-&gt;task;    free(obj);    vTaskDelete(task);&#125;int main_test(const char *str, int cnt)&#123;    hello_obj_t *obj;    obj = malloc(sizeof(hello_obj_t));    obj-&gt;str = str;    obj-&gt;cnt = cnt;    static StackType_t stack[1024];    static StaticTask_t task;    obj-&gt;task = xTaskCreateStatic(hello_task, &quot;hello&quot;, 1024, obj, 10, stack, &amp;task);    return 0;&#125;\n\n这段代码展示一种常见的编程模式，即将任务线程相关的数据封装在一个结构体中，然后在任务创建时传入到任务函数中。当任务将相关业务数据处理完成后删除相关资源。\n上面这段代码看起来没什么太大的问题，对象分配的资源都在线程删除前得到释放。但上面这段代码仍然存在一个致命的缺陷，即可能出现hello_task线程无法被正常删除的情况。\nFreeRTOS在创建任务时，如果被创建的任务优先级高于当前上下文的优先级，会在任务创建函数返回前就调度到新创建的任务中执行，这使得使得任务创建函数没有及时的返回，导致obj-&gt;task无法取得正确的值。线程hello_task执行太快且没有释放CPU执行权时，会导致在任务删除时obj-&gt;task没有取到正确的值，从而导致任务无法被正确删除。\n可能大多数业务代码都不会执行的太快，但在一些极端情况还是需要考虑这个问题，例如上述代码中传入cnt为0时的情况。\n解决这个问题有两个思路，一是使用xTaskCreate()替代xTaskCreateStatic()，xTaskCreate函数通过传参的方式取得任务句柄，不会出现上述问题，它可以保证在任务执行前就将句柄赋予正确的值。二是在使用xTaskCreateStatic接口前关闭任务调度器，在任务创建完成后在打开任务调度，确保任务创建函数正常返回后再启动任务调度器。\n或许可以使用vTaskDelete(NULL)来删除当前线程，这样就能规避该问题。但通过上面这个示例可以看出这是一个时序不严谨的代码可能导致比较严重的问题，在实现其它类似这样的多线程代码时也应当注意类似的问题。\n"},{"title":"妙不可言的异常捕获机制","url":"/2024/04/25/%E5%A6%99%E4%B8%8D%E5%8F%AF%E8%A8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6/","content":"什么是异常捕获异常捕获是程序员在程序中捕获异常的一种方式，异常捕获可以避免程序崩溃，让程序继续运行。当程序的运行环境收到异常信息后，会自动寻址处理该异常的catch块处理该异常，这个过程被称为异常捕获。\n大部分高级的编程语言都提供了异常捕获机制，如Java、C++、Python等。C语言不提供异常捕获机制，尤其是在嵌入式开发中，C语言的异常捕获机制非常弱，而且容易导致程序崩溃。所有一般MCU提供了错误检测机制，如：HardFault等中断，但是这些中断是直接导致程序崩溃的，而不是异常捕获机制。\n本文提供了一种方法，可以捕获C语言中的异常，并且可以自定义异常处理过程，可以到达同一般异常捕获机制相似的效果。\n异常捕获的基本原理通过try语句标记捕获异常的代码，通过catch语句标记异常处理代码。所以在执行try语句时，需要保存程序上下文的信息，以便在catch语句中恢复执行。保存上下文的过程根据不同的处理器架构有所不同，但基本思路是保存处理器寄存器、堆栈指针、堆栈内容等。\n如何保存上下文信息这里通过特定的处理器来说明上下文信息是如何保存的，以Cortex-M7芯片为例，其它的芯片的实现方式类似。上下文信息包括：寄存器、栈指针、LR、PC、PSR。其中寄存器需要根据AAPCS规范来处理，即主要保存被调用者保存寄存器，包括R4-R11。调用者的寄存器在外层栈帧中已经处理过了，所以不需要保存。栈指针为SP寄存器。程序指针这里将使用LR指针，通过它可以快速返回到异常调用的出口位置。\nShow code:\n.global try_save_context.type try_save_context,%function.thumb_func// typedef int try_ctx_t[10];// int try_save_context(try_ctx_t ctx);try_save_context:    push &#123;r0, lr&#125;    mov r2, r0    mov r0, #0    mov r1, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;r0, lr&#125;    mov ip, sp    stmia.w r0!, &#123;r4, r5, r6, r7, r8, r9, sl, fp, ip, lr&#125;    mov r0, 0    bx lr\n这里实现了一个保存上下文函数的接口，用户传入一个try_ctx_t结构体指针，保存上下文。该指针将保存到FreeRTOS的线程本地存储中，方便后续恢复上下文。将处理器的r4、r5、r6、r7、r8、r9、sl、fp、ip、lr保存到try_ctx_t结构体中。最后函数返回0表示上下文保存完成。\n对于非RTOS的用户，这里的代码需要做响应的调整，可以使用一个独立的全局变量来存储ctx，这里就不再详细介绍了。后续的整个实现都是基于FreeRTOS来实现的。\n如何在中断内恢复到用户线程的上下文这是整个异常捕获机制中最复杂的部分。当处理器进入中断后处于handle模式，而用户的线程处于user模式。两者没有在同一个上下运行空间内。如何恢复到用户线程的上下文呢？\n基本思路是从FreeRTOS的线程本地存储中获取用户上下文信息，然后将其中主要的寄存器恢复到处理器寄存器中。然后在用户线程中模拟一个中断栈来保证当前的handle中断能够正常退出，使得用户返回到线程模式后能够继续执行，且用户栈和中断栈都满足平衡的要求。\nShow code:\n#define FAULT_THROW()                                                                           \\    &#123;                                                                                           \\        __asm volatile(                                                                         \\            &quot;dsb \\n isb                     \\n&quot;                                                 \\            &quot;push &#123;r0, r1, r2, r3, r12, lr&#125; \\n&quot;                                                 \\            &quot;tst lr, #4                     \\n&quot;                                                 \\            &quot;beq .end&quot; END_LINE &quot;           \\n&quot; /* Can&#x27;t try in Handle mode */                  \\            &quot;mov r0, #0                     \\n&quot;                                                 \\            &quot;mov r1, #0                     \\n&quot;                                                 \\            &quot;bl pvTaskGetThreadLocalStoragePointer\\n&quot; /* Get try context */                     \\            &quot;cmp r0, #0                     \\n&quot;                                                 \\            &quot;beq .end&quot; END_LINE &quot;           \\n&quot;                                                 \\            &quot;mov r12, r0                    \\n&quot;                                                 \\            &quot;mov r0, #0                     \\n&quot;                                                 \\            &quot;mov r1, #0                     \\n&quot;                                                 \\            &quot;mov r2, #0                     \\n&quot;                                                 \\            &quot;bl vTaskSetThreadLocalStoragePointer\\n&quot; /* Set try context to NULL */              \\            &quot;mov r0, r12                    \\n&quot;                                                 \\            &quot;ldr r1, [r0, 32]               \\n&quot; /* get sp in context */                         \\            &quot;ldr r2, [r0, 36]               \\n&quot; /* get pc in context */                         \\            &quot;sub r1, #32                    \\n&quot; /* adjust sp for user stack frame */            \\            &quot;str r2, [r1, 24]               \\n&quot; /* save PC to the user stack frame */           \\            &quot;mov r2, #0x1000000             \\n&quot; /* xPSR, bit24 is thumb state, it&#x27;s always 1 */ \\            &quot;str r2, [r1, 28]               \\n&quot; /* save xPSR to the user stack frame */         \\            &quot;mov r2, #0x40000000            \\n&quot;                                                 \\            &quot;str r2, [r1,  0]               \\n&quot; /* R0=0x40000000, it&#x27;s the throw value */       \\            &quot;ldmia r0!, &#123;r4, r5,  r6,  r7,    &quot;                                                 \\            &quot;            r8, r9, r10, r11&#125;  \\n&quot; /* restory context */                           \\            &quot;msr psp, r1                    \\n&quot; /* restore the PSP */                           \\            &quot;isb                            \\n&quot;                                                 \\            &quot;pop &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot; /* MSP stack balance */                         \\            &quot;orr lr, lr, #0x10              \\n&quot; /* clear floating-point flag */                 \\            &quot;isb                            \\n&quot;                                                 \\            &quot;bx lr                          \\n&quot; /* exit ISR and jump to user context */         \\            &quot;.end&quot; END_LINE &quot;:              \\n&quot;                                                 \\            &quot;pop &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot;);                                               \\    &#125;#define _STR2(x) #x#define _STR(x) _STR2(x)#define END_LINE _STR(__LINE__)\n这里实现了一个宏定义，用于捕获异常，并跳转到用户上下文。\n\n首先判断跳转到该中断前的处理器模式，如果不是用户模式，则直接返回，因为这不能捕获异常。\n然后判断当前线程本地存储指针内容，这是用于保存上下文信息的指针，如果指针为NULL，则表示当前没有执行try_save_context，所以直接返回。\n如果指针不为NULL，则表示当前执行了try_save_context。同时清空线程本地存储指针，表示当前的异常已经被处理了。\n从上下文信息中取出sp指针，以次为基础构造一个中断栈，这是为了当前的中断能够正常返回而必要的。”sub r1, #32”\n在调整的栈中保存PC指针(即原上下文中的LR寄存器)，构造一个合法的PSR寄存器，PSR寄存器中不需要浮点标志位、栈对齐等信息，只需要处理器模式为thumb模式即可。\n从上下文信息中取出r4-r11，依次恢复到各种的寄存器中。\n通过msr指令将新的栈指针写入到psp中。\n通过lr寄存器退出当前的中，特别主要需要将lr寄存器的浮点上下文标志清除。\n\n当处理器执行bx lr时，处理器根据运行模式从psp中取出r0-r3的值恢复的处理器上，同时取出PC寄存器跳转到用户程序中，这样就完成了从中断上下文恢复到应用程序的上下文。这里涉及到了大量Cortex-M处理器的中断处理机制相关内容，这里就不展开了。\ntry语法糖前面实现了用户线程的保护和恢复，已经就能够实现异常捕获了，类似这样的代码：\nvoid test_func(void)&#123;    try_ctx_t ctx;    if(try_save_context(ctx) == 0)&#123;        printf(&quot;test_func\\n&quot;);        // do something        illegal_function_execution(); // Trigger exception        printf(&quot;never run here\\n&quot;);    &#125;else&#123;        printf(&quot;catch test_func exception\\n&quot;);    &#125;&#125;void test_func2(void)&#123;    _try&#123;        printf(&quot;test_func\\n&quot;);        // do something        illegal_function_execution(); // Trigger exception        printf(&quot;never run here\\n&quot;);    &#125;    _catch&#123;        printf(&quot;catch test_func exception\\n&quot;);    &#125;&#125;\n将test_func函数包装为test_func2函数，需要实现两个语法糖：_try、_catch。\nint try_save_context(try_ctx_t ctx);void try_clear_context(void);#define _try                                             \\    try_ctx_t CONNECT(__ctx, __LINE__);                  \\    if (try_save_context(CONNECT(__ctx, __LINE__)) == 0) \\    &#123;#define _catch           \\    try_clear_context(); \\    &#125;                    \\    else#define CONNECTION(text1, text2) text1##text2#define CONNECT(text1, text2) CONNECTION(text1, text2)\n\n这里需要注意一个问题，当用户程序未出现异常时，需要主动调用try_clear_context函数，这样才能将当前try的上下文环境清除掉，否则try的边界不清晰，导致异常捕获机制出现混乱。\n这里还需要注意的是该语法糖不支持ex消息传递。我最开始设计的时候是想要取得该消息的，但是后来在设计该语法结构时发现这需要使用finial块，但是finial块的意义并不大，且会导致该语法糖变得复杂，所以该语法糖不支持ex消息传递。此外还需要特别注意的是try语句不能独立出现，它必须和catch语句一起出现。\n在使用该语法糖时，还需要注意的一点时，在try语句块中不能直接出现return语句。return语句会破坏try的边界，导致异常捕获机制的混乱。但是在catch语句中可以使用return。\n从用户空间抛出一个异常也是一个有意思的设计。\n.global try_clear_context.type try_clear_context,%function.thumb_func// void try_clear_context(void)try_clear_context:    push &#123;lr&#125;    mov r0, #0    mov r1, #0    mov r2, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;pc&#125;.global _throw.type _throw,%function.thumb_func// void _throw(int ex)_throw:    push &#123;r0, lr&#125;    mov r0, #0    mov r1, #0    bl pvTaskGetThreadLocalStoragePointer    cmp r0, #0    beq .end_throw    mov r12, r0    mov r0, #0    mov r1, #0    mov r2, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;r0, lr&#125;    mov r1, r12    ldmia r1!, &#123;r4, r5, r6, r7, r8, r9, r10, r11, r12, lr&#125;    mov sp, r12    cmp r0, #0    it eq    moveq r0, #1    isb    bx lr.end_throw:    pop &#123;r0, pc&#125;\n在用户空间调用_throw可以主动抛出一个异常，ex为一个非零的异常编号。\ntry嵌套问题我最开始是想要设计异常捕获嵌套的，因为这不是一个复杂的技术问题，一个链式结构就能够实现。我之所以选择放弃这部分实现的原因是，我担心这会带来一些问题。因为C语言本身不支持垃圾回收，滥用异常捕获机制可能会导致资源泄漏的风险，所以我放弃了异常捕获嵌套的功能。这里实现的异常捕获机制也许更适合一个故障分析的场景，或者用于对一些关键代码进行保护。\n浮点寄存器相关问题这里的设计没有考虑保存浮点上下文，所以在使用的时候需要特别注意用法环境。此外对于惰性压栈机制，我这里使用DSB、ISB指令进行处理，确保浮点数的中断压栈正常，但我对这一块的具体细节不是很清楚，所以需要进一步研究。\n总结我最开始想要该功能的原因是我在执行一些第三方的代码时经常出现hard故障，我需要对这些不可信代码的执行做一个保护，于是写了一个简单的异常捕获机制，将异常捕获后返回一个错误码，然后根据错误码来判断是否需要重试。对于多任务环境，故障时直接将MCU挂起可能带来一些额外的风险，以为某些关键任务程序不能中断运行。这个异常捕获程序很好的解决了这方面的问题。\n测试附件int devide_zero(void)&#123;    int r;    volatile unsigned int a;    volatile unsigned int b;    SCB-&gt;CCR |= SCB_CCR_DIV_0_TRP_Msk;    a = 1;    b = 0;    r = a / b;    return r;&#125;int main_test()&#123;    _try&#123;        printf(&quot;devide zero test\\n&quot;);        // 对于一般的MCU，执行该函数会导致HardFault异常，使处理器停机。        // 但这里的异常捕获机制会使得程序能够继续运行。        devide_zero();    &#125;    _catch&#123;        printf(&quot;catch devide zero fault\\n&quot;);    &#125;    printf(&quot;mcu not stop\\n&quot;);    return 0;&#125;void HardFault_Handler(void)&#123;    FAULT_THROW();    while(1);&#125;\n\nRun output:\ndevide zero testcatch devide zero faultFault Analysis:Exception id: 3Systick: 25857Core register:R0:  00000001  R1:  00000000  R2:  e000ed00  R3:  00000000R4:  900ad014  R5:  24018140  R6:  900ad014  R7:  20003db0R8:  00000001  R9:  900ad014  R10: 00000000  R11: 24015180R12: fa000000  SP:  20003d48  LR:  9007f63f  PC:  9001905cPSR: 61000000  ERT: fffffffd  (PSP / User)Usage Fault:  Divide by zeroHard Fault:  Forced Hard FaultStack memory:20003d48: 00000000 00000001 900ad008 9007a61520003d58: 900ad008 24018140 900ad014 20003db020003d68: 00000001 900ad014 00000000 2401518020003d78: 20003d58 9007a609 00000001 900ad01420003d88: 24018140 00000000 00000000 a5a5a5a520003d98: a5a5a5a5 9007a969 00000001 a5a5a5a520003da8: a5a5a5a5 0da5a5a5 24018140 0000000020003db8: 00000000 00000000 00000000 0000000020003dc8: 00000000 00000000 00000000 0000000020003dd8: 00000000 00000000 00000000 0000000020003de8: 00000000 00000000 00000000 0000000020003df8: 00000000 00000000 00000000 0000000020003e08: 00000000 00000000 a5a5a5a5 a5a5a5a520003e18: a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a520003e28: a5a5a5a5 a5a5a5a5 a5a5a5a5 900834f520003e38: a5a5a5a5 a5a5a5a5 20003d4c 00006501Call stack backtrack:[9001905c] call from &lt;9007f63f&gt;, sp=20003d4c[9007f63f] call from &lt;9007a615&gt;, sp=20003d54[9007a615] call from &lt;9007a969&gt;, sp=20003d9c[9007a969] call from &lt;900834f5&gt;, sp=20003e34Show fault ASM code:9001904a: f043 0310   orr     r3, r3, #169001904e: 6153        str     r3, [r2, #20]90019050: 2301        movs    r3, #190019052: 9301        str     r3, [sp, #4]90019054: 2300        movs    r3, #090019056: 9300        str     r3, [sp, #0]90019058: 9801        ldr     r0, [sp, #4]9001905a: 9b00        ldr     r3, [sp, #0] &lt;break point&gt;9001905c: fbb0 f0f3   udiv    r0, r0, r390019060: b002        add     sp, #890019062: 4770        bx      lr90019064: ed00 e000   stc     0, cr14, [r0, #0]!90019068: b500        push    &#123;lr&#125;9001906a: b083        sub     sp, #129001906c: 9200        str     r2, [sp, #0]9001906e: 460a        mov     r2, r1mcu not stop\n经过测试，该功能工作正常，通过在线故障诊断，已经输出了错误时刻的详细信息，包括：寄存器、堆栈、调用栈、故障点附近的汇编代码。可以发现break point已经给出了故障具体的位置，配合寄存器，可以确认这是除零故障。\n如何在单片机内自诊断，生成详细的故障诊断报告也是一个非常有意思的功能，以后有时间再写一篇文章详细介绍。\n"},{"title":"实现独有的硬件通信总线","url":"/2023/05/07/%E5%AE%9E%E7%8E%B0%E7%8B%AC%E6%9C%89%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/","content":"背景前段时间开发了一个嵌入式软件，其中有一个功能是使用PWM驱动一个无源的蜂鸣器，根据以往的经验来看，这是一个非常简单的功能，不过在实际操作时遇到了一个很多人往往都忽略的问题。我们硬件选择的单片机没有硬件PWM功能，只有普通的定时器，这就意味着我们只能使用定时器+IO口模拟PWM。通过定时器中断操作IO口能够模拟一个较为准确的PWM信号，把这个信号输出到音频放大电路并驱动蜂鸣器后，蜂鸣器能够发出期望的声音，但是其中存在一点噪音，起初以为是驱动电路存在问题，但是经过排查确认是单片机输出的PWM信号频率成分不干净，除了期望的频率信号外，还存在其它频率的信号。如果使用频谱仪进行分析，就能发现其中的杂散成分。导致这个问题的原因是依靠因为CPU控制IO口的时间是不准确的。单片机存在其它高优先级的中断任务，导致定时器的中断被延时触发，进而导致PWM信号生成不准确。这种误差非常的小，大多数人可能都没有注意到模拟硬件IO时序上引入的误差，但它是客观存在的。\n使用软件模拟IO时序总体来说是不常见的，因为软件通常只能模拟一些简单的IIC、SPI、PWM等速度较低的信号。如果你想使用GPIO模拟几百兆时钟频率的USB信号，大多数CPU都是无法完成的。因为CPU侧重于计算而不是这种重复、繁琐的IO控制。当CPU的时钟频率越高，模拟的时序越复杂，CPU的负担也就越重，这种额外的开销对于CPU来说是非常不划算的，所以后面就诞生了FPGA之类的芯片。FPGA芯片几乎能够模拟出任何你想要的硬件时序，但是嵌入式开发中使用FPGA会带来额外的高昂成本，同时限制开发人员使用FPGA的另外一个难题是它复杂的开发方式。\n一种全新的方案-PIO2021年树莓派基金会推出了一款新的微控制器-RP2040，关于这款单片机的详细介绍可以从官网了解。它和一般的ARM微控制器大体上差不多，但是它存在一个特殊的外设-PIO，这是在以往的单片机中从未出现过的，通过PIO可以由硬件自动完成IO口的时序操作而无需CPU的干预。PIO能够独立运行一段简单的程序来控制IO从而实现特定的硬件时序。通过它控制IO是非常高效的，它甚至比CPU直接控制IO还要快。\nPIO的硬件结构RP2040单片机内有两个独立的PIO模块，每个PIO模块的结构如下：每个PIO有4个状态机，状态机是执行指令的实体。4个状态机共享32字的指令存储空间。每个状态机上连接了TXRX FIFO用于与CPU交互数据。FIFO事件和状态机的事件能够触发两个不同的中断，这两个中断是两个PIO共享的。状态机还能够绑定IO列表，用于控制IO口的输入和输出。\n每个状态机上有两个位移寄存器(ISR、OSR)，主要用于数据输出到IO上或者从IO上读取数据。还有两个缓存寄存器(X、Y)，用于保存临时数据和一些中间状态。PC寄存器记录当前的状态机执行到了那一条指令。此外每个状态机都能独立配置时钟，16位的整数分频加8位的小数分频能满足大多数时钟要求。\nPIO编程指南类似于C语言，PIO编程也是先编写PIO代码然后使用PIOASM编译器生成目标文件。生成的目标文件文件格式可以选择，为了方便集成到C-SDK中，PIOASM工具默认生成.h格式的目标文件。\nPIO源文件的组成\n1.注释代码中的注释可以使用分号;或者//作为注释内容的开头。按照官方示例的传统，建议使用分号。\n\n2.伪指令伪指令主要是用于描述一些配置的代码，伪指令以.开头，需要记住的伪指令有这些\n\n\n\n\n\n指令\n描述\n\n\n\n.define ( PUBLIC ) &lt;symbol&gt; &lt;value&gt;\n定义一个符号，类似于C语言中的define，附加public关键字后会在目标文件中也生成同步的宏定义。\n\n\n.program &lt;name&gt;\n声明程序的名称，并表示后续的代码即为程序代码，一个文件中可以包含多个不同名称的代码。\n\n\n.origin &lt;offset&gt;\n用于指定PIO程序必须加载到指定的存储空间地址下，这对于使用了绝对地址跳转的功能是有用的。\n\n\n.side_set &lt;count&gt; (opt) (pindirs)\n声明指令中允许使用侧设置指令来控制io，count表示io的数量，opt意味这代码中不需要每条指令都进行侧设置，pindirs表示设置的是io的方向而不是io的电平状态。\n\n\n其中最难理解的也许是side_set(侧设置)，它是用于控制IO状态的指令，要理解它，我们就将另外三种控制IO的指令拿出来一起说明。PIO有4中方式控制IO口，输入(IN)，输出(OUT)，设置(SET)，侧设置(SIDE_SET)。\n每种控制方式都需要配置一个连续的引脚范围用于控制，各个控制方式的引脚范围是可重叠的，这意味着一个引脚可以同时用4种方式进行控制。引脚数量除了SET、SIDE_SET控制外，其它三种方式都没有引脚数量的限制，SET能最多映射5个引脚，side_set受限与指令编码的位宽，最多5个IO口能够控制。\n输入用于读取IO的值到ISR寄存器中，通过位移的方式读取。输出是将OSR寄存器中的值输出到IO上，同样也是位移的方式。当位移寄存器满了或者空了之后，经过适当的配置，位移寄存器能够自动和FIFO交互数据。SET能够直接控制引脚的电平状态而不依赖位移寄存器。SIDE_SET是附加在一般指令中的指令，它与被附加的指令一起执行，通过它也能够直接设置IO的电平状态。\n此外还有JMP指令能够读取引脚状态，它可以单独配置一个引脚用于条件跳转。\n\n3.标签指令前可以使用一个命名标签用于表示代码段的位置，类似这样的：标签:    指令\n通过这样标签，使用JMP指令就能实现分支流程处理。\n\n指令所有的指令结构都为如下形式：\n&lt;指令&gt; (side &lt;侧设置电平状态&gt;) ([&lt;延时周期&gt;])\n每条指令都可以附加侧设置指令以在执行指令的过程中设置电平状态。延时周期则用于在指令执行完成后延时一段时间再执行下一条指令，如果指令导致状态机阻塞，延时的时间是从结束阻塞开始计算的。PIO支持的9条指令都是单周期指令，这是非常准确的，如果两个状态机设置为相同的时钟频率一起执行同一段代码，它们能够保证同步运行。\n侧设置电平状态和延时周期所占的编码位宽是共享的，如果配置了.side_set 2，意味着可以同时设置两个IO，但是延时时间就只能占用3个位了，即最长只能延时7个时钟周期。此外如果加入了opt选项.side_set 2 opt，意味着opt还要单独占用一位，延时时间只能使用2个位，最长的延时时间就是3个时钟周期。\n9条指令有 JMP、WAIT、IN、OUT、PUSH、PULL、MOV、IRQ、SET。每条指令的细节说明应当去看芯片手册，这里就不需要复述了。这些指令非常的灵活，有很多让人意外的用法，例如将FIFO中的数据取出后把它当作指令执行。\n中断前面提到了PIO具有两条中断线(irq0和irq1)，两个PIO模块是共享的。PIO模块的中断是系统级别的，和SPI等外设的中断在一个层次上，也是由NVIC进行管理的。PIO有12个事件能够触发中断，其中0 ~ 3是来自状态机内部的中断，4 ~ 11是4个状态机共8个FIFO的满空事件中断。\nPIO模块有两条中断线到NVIC，且每个中断事件都是可以单独路由的。举个例子方便理解，PIO0的中断0和中断2事件发送到irq0，PIO0的中断1和中断3事件发送到irq1，PIO1的中断0和中断1发送到irq0，这是可以混搭的。但实际上不会这么使用，因为要在中断处理中去分析PIO0和PIO1的具体中断事件比较麻烦，需要检查每个中断状态寄存器。\n除了PIO具有中断外，每个状态机也具有中断，或者说是中断标志位，PIO的4个状态机共享8个中断标志位，也就是说状态机可以使用8个中断。比如说可以在一个状态机中设置中断标志，在另一个状态机中等待中断标志，这样就实现了状态机的交互。这应该是状态机间进行直接交互的唯一方式了，因为状态机之间是不能传输数据的。8个中断标志位中的前4个可以上报到PIO并触发PIO的中断事件，后4个中断标志仅仅用于状态机内部。处理器通过PIO模块能够直接清除这8个中断标志。\n如果PIO打开了内部0 ~ 3的中断使能，那么任意一个状态机设置了0 ~ 3的中断标志位，中断都会上报到PIO中。由于状态机和CPU的NVIC都能处理一些相同的中断源，所以在使用时，需要注意等待中断中的竟态条件。\nIRQ 1         ;表示设置一个中断标志并继续运行，1表示中断标志位的序号IRQ WAIT 1    ;表示设置一个中断标志并等待该标志被清除IRQ CLEAR 1   ;表示清除一个中断标志\n\n中断标志位的序号有两种表示方式，绝对值和相对值，前面的三个写法都是绝对序号，举例说明一下相对序号的写法：\n; 状态机序号为 1IRQ 5 rel     ;表示设置的中断序号为6，6 = (设置序号 &amp; 4) + (设置序号 + 状态机序号) &amp; 3\n相对序号的具体细节还是要参考芯片手册。\nDMACPU和PIO的数据交互主要是FIFO，但该FIFO的容量有限，且需要通过轮询或者中断来触发数据传输，这对CPU来说是额外的负担，PIO提供了数据请求机制，通过该机制并结合DMA子模块，数据能够无需CPU干预从而在RAM和PIO状态机之间传输大量数据，数据传输速度为每个时钟周期1字节。\nPIO编程中的一些细节PIO状态机总是要一直运行的，可以通过JMP指令进行无条件跳转达到循环的目的，但是PIO提供了一种边界机制，当程序运行到边界后能够自动恢复到起始位置，这个边界默认是程序的起始和结束位置，当然也能够通过.wrap_target指定循环的起始位置，并用.wrap指定循环的结束位置。\n每个状态机都有输入和输出FIFO，用于数据的交互，但是某些应用仅仅输出数据或者读取数据，这样我们可以将它们的FIFO进行合并以扩大FIFO的使用空间。\n再说明一些数据方向的问题，OUT指令是将OSR寄存器的数据输出到PIN，当配置了autopull，OSR位移完成后，TXFIFO中的数据会转移到OSR中。PULL指令是主动将TXFIFO中的数据转移到OSR寄存器中。PULL指令默认是阻塞的，意味着TXFIFO中没有数据时状态机会阻塞运行。\nPIO代码经过PIOASM编译后生成的是一个.h文件，其中有些细节需要知道。如果我们声明的程序名为xx，即.program xx，那么.h文件中会生成一个类型为pio_program的变量，变量名为xx_program。这是用来加载程序的。此外在.program内定义的public符号在生成的.h文件中也会附件xx_的前缀。PIO中的相关配置会转化为一个配置获取函数xx_program_get_default_config()。PIO代码源文件代码是不区分大小写的。\n侧设置的执行和指令执行是同时发生的，在同一个时钟周期内完成。但是需要注意的是，许多指令能够导致状态机阻塞而暂停指令的执行，例如WAIT、PUSH、PULL等，当状态机阻塞时，侧设置是不会被影响的，它总能在第一个时钟周期内完成。\nAUTOPULL是怎么实现的呢？假如将OSR配置为8位，这就意味着当OSR移动了8位后，就需要执行PULL操作，状态机内部记录了OSR位移的量，所以才能够自动触发PULL。\nJMP指令跳转的目标地址在编译后都是相对0的绝对地址，当使用pio_add_program载入程序时，如果载入的偏移地址不是0，那么JMP指令中的目标地址会自动进行调整以保证程序正确运行。这是唯一一个会被重定位的指令。\nC-SDK编程为了用好PIO，还需要大量C-SDK中的接口来配合，实现配置、数据交互、程序加载等。下面说明一些常用的C函数的用法和功能。\n\n1.PIO程序加载类\n\nuint pio_add_program(PIO pio, const pio_program_t *program);加载一个程序，并将程序加载到的位置返回。\nvoid pio_remove_program(PIO pio, const pio_program_t *program, uint loaded_offset);从指令存储空间中卸载程序，需要提供加载地址。\nvoid pio_clear_instruction_memory(PIO pio);清空PIO的全部指令存储空间。\n\n2.状态机类\n\nint pio_claim_unused_sm(PIO pio, bool required);请求一个空闲的状态机。\nvoid pio_sm_init(PIO pio, uint sm, uint initial_pc, const pio_sm_config *config);初始化一个状态机，initial_pc就是程序的加载地址，config可以使用.h文件中生成的一个方法得到。\nvoid pio_sm_set_enabled(PIO pio, uint sm, bool enabled);启动或者关闭状态机。\nvoid pio_set_sm_mask_enabled(PIO pio, uint32_t mask, bool enabled);使用掩码同时启动或者关闭多个状态机。\nvoid pio_sm_restart(PIO pio, uint sm);状态机复位。\nvoid pio_restart_sm_mask(PIO pio, uint32_t mask);复位多个状态机。\nvoid pio_enable_sm_mask_in_sync(PIO pio, uint32_t mask);将多个状态机的时钟分频同步。\nuint8_t pio_sm_get_pc(PIO pio, uint sm);获取当前状态机执行的位置。\n\n3.状态机配置类\n\nvoid sm_config_set_out_pins(pio_sm_config *c, uint out_base, uint out_count);配置OUT引脚的范围，起始引脚和引脚数量。\nvoid sm_config_set_set_pins(pio_sm_config *c, uint set_base, uint set_count);配置SET引脚的范围，起始引脚和引脚数量。\nvoid sm_config_set_in_pins(pio_sm_config *c, uint in_base);配置IN引脚的起始引脚。\nvoid sm_config_set_sideset_pins(pio_sm_config *c, uint sideset_base);配置SIDE引脚的起始引脚。\nvoid sm_config_set_jmp_pin(pio_sm_config *c, uint pin);配置JMP引脚，JMP条件指令能够选择一个引脚的值作为条件，当引脚为高电平时，条件成立。\nvoid sm_config_set_clkdiv(pio_sm_config *c, float div);配置状态机的时钟分频。\nvoid sm_config_set_wrap(pio_sm_config *c, uint wrap_target, uint wrap);配置状态机的程序边界。\nvoid sm_config_set_in_shift(pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold);配置IN指令，shift_right为真时OSR为右移模式，autopush为真时，意味着OSR达到阈值后自动执行PUSH，从TXFIFO中取出数据到OSR中。push_threshold表示OSR的位宽。\nvoid sm_config_set_out_shift(pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold);配置OUT指令。\nvoid sm_config_set_fifo_join(pio_sm_config *c, enum pio_fifo_join join);配置FIFO的用法，有三种，0均匀分配，1将FIFO全部用于TXFIFO，2将FIFO全部用于RXFIFO。\n\n4.状态机IO配置\n\nvoid pio_gpio_init(PIO pio, uint pin);将IO口绑定到指定的PIO上。不允许多个PIO控制同一个引脚。\nvoid pio_sm_set_pins(PIO pio, uint sm, uint32_t pin_values);使用特定的状态机将PIO所属的IO全部设为指定值。\nvoid pio_sm_set_pins_with_mask(PIO pio, uint sm, uint32_t pin_values, uint32_t pin_mask);；使用掩码初始化IO。\nvoid pio_sm_set_pindirs_with_mask(PIO pio, uint sm, uint32_t pin_dirs, uint32_t pin_mask);设置IO的方向。\nvoid pio_sm_set_consecutive_pindirs(PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out);设置一组连续IO的方向。\n\n5.数据交互类\n\nvoid pio_sm_clear_fifos(PIO pio, uint sm);清空状态机的FIFO。SDK14.0存在BUG。\nvoid pio_sm_drain_tx_fifo(PIO pio, uint sm);丢掉TXFIFO中的所有数据。\nvoid pio_sm_put(PIO pio, uint sm, uint32_t data);写入一个数据到TXFIFO中。如果FIFO满了则丢掉数据。\nvoid pio_sm_put_blocking(PIO pio, uint sm, uint32_t data);向TXFIFO中写入数据，如果TXFIFO已经满了则等待，直到能够写入数据。\nuint32_t pio_sm_get(PIO pio, uint sm);从RXFIFO中读取一个数据并返回。如果RXFIFO是空的，那么返回的值没有意义。\nuint32_t pio_sm_get_blocking(PIO pio, uint sm);从RXFIFO中读取数据，如果RXFIFO为空则等待，直到RXFIFO中存在新的数据。\nbool pio_sm_is_rx_fifo_full(PIO pio, uint sm);断言接收FIFO已满。\nbool pio_sm_is_rx_fifo_empty(PIO pio, uint sm);断言接收FIFO已空。\nuint pio_sm_get_rx_fifo_level(PIO pio, uint sm);读取RXFIFO中的数据个数，都是按字计算的。\nbool pio_sm_is_tx_fifo_full(PIO pio, uint sm);断言TXIFO已满。\nbool pio_sm_is_tx_fifo_empty(PIO pio, uint sm);断言TXFIFO为空。\nuint pio_sm_get_tx_fifo_level(PIO pio, uint sm);读取TXFIFO中的数据个数。\n\n6.中断管理类\n\nvoid pio_set_irq0_source_enabled(PIO pio, enum pio_interrupt_source source, bool enabled);设置IRQ0的中断事件源。\nvoid pio_set_irq1_source_enabled(PIO pio, enum pio_interrupt_source source, bool enabled);设置IRQ1的中断事件源。\nvoid pio_interrupt_clear(PIO pio, uint pio_interrupt_num);清除状态机内部的中断标志。\n除了C函数外，还需要Cmake来辅助实现编译PIO源文件。\n总结这只是我学习PIO的一个过程记录，到此已经能够基本读懂官方例程中的PIO例子。当然后面还需要自己大量的实践才能熟练掌握这个强大的PIO模块。\n\n示例代码解读一个简单的串口数据发送协议：\n.program uart_tx           ; 程序名称为uart_tx.side_set 1 opt            ; 代码中可以使用侧设置指令，控制的IO数量为1，侧设置指令是可选的。    pull       side 1 [7]  ; 从TXFIFO缓冲区中读取一个数据到OSR寄存器中，如果没有数据就等待。并将side引脚输出高电平。最少执行8个时钟周期。    set x, 7   side 0 [7]  ; 将7赋值到X寄存器。并将side引脚设为低电平。固定执行8个时钟周期。bitloop:                   ; 循环入口    out pins, 1            ; 从OSR寄存器中右移一位到输出OUT引脚上。单个周期。    jmp x-- bitloop   [6]  ; 如果X非0则跳转到bitloop。X=X-1。固定执行7个时钟周期。                           ; 到达程序边界后会自动跳回程序起始处。这是0周期执行的。\n\n与之配套的C相关函数如下：\nstatic inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint baud) &#123;    /* 设置引脚的初始电平状态和引脚方向 */    pio_sm_set_pins_with_mask(pio, sm, 1u &lt;&lt; pin_tx, 1u &lt;&lt; pin_tx);    pio_sm_set_pindirs_with_mask(pio, sm, 1u &lt;&lt; pin_tx, 1u &lt;&lt; pin_tx);    /* 初始化引脚 */    pio_gpio_init(pio, pin_tx);    /* 根据Pio源码的配置生成一个默认配置 */    pio_sm_config c = uart_tx_program_get_default_config(offset);    /* OSR寄存器采用右移输出，不会自动执行PUSH，数据位宽为32位 */    sm_config_set_out_shift(&amp;c, true, false, 32);    /* 绑定tx_pin到out输出引脚上 */    sm_config_set_out_pins(&amp;c, pin_tx, 1);    /* 绑定tx_pin到侧设置输出引脚上 */    sm_config_set_sideset_pins(&amp;c, pin_tx);    /* 将状态机的8个字FIFO全部分配给TXFIFO */    sm_config_set_fifo_join(&amp;c, PIO_FIFO_JOIN_TX);    /* 根据波特率计算时钟分频并设置状态机的分频系数，这里每输出1bit是8个周期 */    float div = (float)clock_get_hz(clk_sys) / (8 * baud);    sm_config_set_clkdiv(&amp;c, div);    /* 初始化状态机 */    pio_sm_init(pio, sm, offset, &amp;c);    /* 启动状态机 */    pio_sm_set_enabled(pio, sm, true);&#125;static inline void uart_tx_program_putc(PIO pio, uint sm, char c) &#123;    /* 阻塞的方式向状态机的TXFIFO中写入数据 */    pio_sm_put_blocking(pio, sm, (uint32_t)c);&#125;static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) &#123;    while (*s)        uart_tx_program_putc(pio, sm, *s++);&#125;\n\n下面是一个串口数据接收协议，并包含帧错误管理：\n.program uart_rxstart:    wait 0 pin 0        ; 等待第0个输入引脚变为低电平    set x, 7    [10]    ; 设置一个临时变量X=7bitloop:                ;     in pins, 1          ; 读取输入引脚的值，并通过右移保存到ISR寄存器    jmp x-- bitloop [6] ; 如果X非0则跳转到bitloop，X=X-1    jmp pin good_stop   ; 确认输入引脚为高电平，这里输入引脚也配置为了JMP引脚                        ; 如果为低电平则检查到帧错误    irq 4 rel           ; 设置一个IRQ标志表示发生了帧错误，rel将表示每个状态机设置的标志不同    wait 1 pin 0        ; 等待输入引脚恢复到高电平    jmp start           ; 返回到开始处重新接收数据good_stop:              ;     push                ; 接收到了正确的数据，将该数据推入到RXFIFO中\n\n"},{"title":"常见的字符串Hash算法","url":"/2021/04/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E7%AE%97%E6%B3%95/","content":"常见hash算法的碰撞概率统计\n\n\n\n10万\n50万\n100万\n500万\n1000万\n一亿\n1000万次的平均执行时间\n一亿次的平均执行时间\n一亿次的平均长度\n\n\n\nBKDRHash\n0.00002\n0.000112\n0.000251\n0.0011894\n0.0023321\n0.0229439\n0.0064134\n0.00968998\n9\n\n\nAPHash\n0\n0.000052\n0.000122\n0.0005794\n0.0011712\n0.01155826\n0.0061518\n0.01088634\n10\n\n\nDJBHash\n0.00001\n0.00011\n0.000204\n0.0011782\n0.0023154\n0.02294341\n0.0064836\n0.01098645\n9\n\n\nJSHash\n0\n0.000188\n0.00032\n0.001464\n0.0029323\n0.02876141\n0.0063464\n0.00904354\n9\n\n\nRSHash\n0.00001\n0.000122\n0.000245\n0.001154\n0.00233\n0.02290588\n0.0063627\n0.01168532\n9\n\n\nSDBMHash\n0.00002\n0.000132\n0.000235\n0.001175\n0.0023435\n0.02294529\n0.0064155\n0.01201398\n9\n\n\nPJWHash\n0.00312\n0.015032\n0.029957\n0.1386394\n0.251465\n0.83290663\n0.0067549\n0.00601705\n8\n\n\nELFHash\n0.00096\n0.005584\n0.011239\n0.0539746\n0.1028391\n0.52002744\n0.0060441\n0.00704438\n9\n\n\nMurmurHash\n0\n0\n0\n0\n0\n0\n0.0066868\n0.01194736\n19\n\n\nCityHash\n0\n0\n0\n0\n0\n0\n0.0066179\n0.01129171\n19\n\n\nFNVHash\n0.00005\n0.000186\n0.000349\n0.0016688\n0.0033469\n0.03279751\n0.0061614\n0.01018707\n9\n\n\ncrc64\n0\n0\n0\n0\n0\n0\n0.0064459\n0.01242473\n19\n\n\n1.BKDR hash function\nunsigned int bkdr_hash(const char *str)&#123;    unsigned int seed = 131; // the magic number, 31, 131, 1313, 13131, etc.. orz..    unsigned int hash = 0;    unsigned char *p = (unsigned char *)str;    while (*p)        hash = hash * seed + (*p++);    return hash;&#125;\n\n2.AP hash function\nunsigned int ap_hash(char *str)&#123;    unsigned int hash = 0;    int i;    for (i=0; *str; i++)        if ((i &amp; 1) == 0)            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));        else            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));    return (hash &amp; 0x7FFFFFFF);&#125;\n\n3.DJB hash function\nunsigned long hash_djbx33a(const char *str, size_t len)&#123;    unsigned long hash = 0U;    for(size_t i = 0;i &lt; len; ++i) &#123;        hash = hash * 33 + (unsigned long)str[i];        /* or, hash = ((hash &lt;&lt; 5) + hash) + (unsigned long)str[i];          * where, hash * 33 = ((hash &lt;&lt; 5) + hash)         */    &#125;    return hash;&#125;long long djb2(char s[])&#123;    long long hash = 5381; /* init value */    int i = 0;    while (s[i] != &#x27;\\0&#x27;)    &#123;        hash = ((hash &lt;&lt; 5) + hash) + s[i];        i++;    &#125;    return hash;&#125;\n\n4.JS hash function\nunsigned int js_hash(char*str)&#123;    unsigned int hash = 1315423911 ;    while(*str)    &#123;        hash ^=((hash &lt;&lt;5 ) + (*str++) + (hash &gt;&gt;2 ));    &#125;    return hash;&#125;\n\n5.RS hash function\nunsigned int RSHash( char * str)&#123;    unsigned int b = 378551;    unsigned int a = 63689;    unsigned int hash = 0;    while(*str)    &#123;        hash = hash * a + (*str++);        a *= b;    &#125;    return (hash &amp; 0x7FFFFFFF);&#125;\n\n6.SDBM hash function\nstatic unsigned long sdbm(unsigned char *str)&#123;    unsigned long hash = 0;    int c;    while (c = *str++)        hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;    return hash;&#125;\nsdbm_hash.c\n/* Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//* * sdbm - ndbm work-alike hashed database library * based on Per-Aake Larson&#x27;s Dynamic Hashing algorithms. BIT 18 (1978). * author: oz@nexus.yorku.ca * status: ex-public domain. keep it that way. * * hashing routine */#include &quot;apr_sdbm.h&quot;#include &quot;sdbm_private.h&quot;/* * polynomial conversion ignoring overflows * [this seems to work remarkably well, in fact better * then the ndbm hash function. Replace at your own risk] * use: 65599  nice. *      65587  even better.  */long sdbm_hash(const char *str, int len)&#123;    register unsigned long n = 0;#define DUFF/* go ahead and use the loop-unrolled version */#ifdef DUFF#define HASHCn = *str++ + 65599 * n    if (len &gt; 0) &#123;        register int loop = (len + 8 - 1) &gt;&gt; 3;        switch(len &amp; (8 - 1)) &#123;        case 0:do &#123;                HASHC;case 7:HASHC;        case 6:HASHC; case 5:HASHC;        case 4:HASHC; case 3:HASHC;        case 2:HASHC;case 1:HASHC;            &#125; while (--loop);        &#125;    &#125;#else    while (len--)        n = *str++ + 65599 * n;#endif    return n;&#125;\n\n7.PJWHash hash function\n/*  * A generic hash function HashPJW better than ElfHash point,  * but depending on the context. */#include &lt;limits.h&gt;#define BITS_IN_int     ( sizeof(int) * CHAR_BIT )#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))#define HIGH_BITS       ( ~((unsigned int)(~0) &gt;&gt; ONE_EIGHTH ))unsigned int HashPJW ( const char * datum )&#123;    unsigned int hash_value, i;    for ( hash_value = 0; *datum; ++datum )    &#123;        hash_value = ( hash_value &lt;&lt; ONE_EIGHTH ) + *datum;        if (( i = hash_value &amp; HIGH_BITS ) != 0 )            hash_value = ( hash_value ^ ( i &gt;&gt; THREE_QUARTERS )) &amp; ~HIGH_BITS;    &#125;    return ( hash_value );&#125;\n\n8.ELFHash hash function\n/* *    This function hash the input string &#x27;name&#x27; using the ELF hash *    function for strings. */static unsigned int hash(char* name)&#123;    unsigned int h = 0;    unsigned int g;    while(*name) &#123;        h = (h&lt;&lt;4) + *name++;        if ((g = (h &amp; 0xf0000000)))            h ^= g&gt;&gt;24;        h &amp;=~ g;    &#125;    return h;&#125;\n\n9.Murmur hash function\nuint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) &#123;    uint32_t h = seed;    if (len &gt; 3) &#123;        const uint32_t* key_x4 = (const uint32_t*) key;        size_t i = len &gt;&gt; 2;        do &#123;            uint32_t k = *key_x4++;            k *= 0xcc9e2d51;            k = (k &lt;&lt; 15) | (k &gt;&gt; 17);            k *= 0x1b873593;            h ^= k;            h = (h &lt;&lt; 13) | (h &gt;&gt; 19);            h = (h * 5) + 0xe6546b64;        &#125; while (--i);        key = (const uint8_t*) key_x4;    &#125;    if (len &amp; 3) &#123;        size_t i = len &amp; 3;        uint32_t k = 0;        key = &amp;key[i - 1];        do &#123;        k &lt;&lt;= 8;        k |= *key--;        &#125; while (--i);        k *= 0xcc9e2d51;        k = (k &lt;&lt; 15) | (k &gt;&gt; 17);        k *= 0x1b873593;        h ^= k;    &#125;    h ^= len;    h ^= h &gt;&gt; 16;    h *= 0x85ebca6b;    h ^= h &gt;&gt; 13;    h *= 0xc2b2ae35;    h ^= h &gt;&gt; 16;    return h;&#125;\n\n10.City hash function\n/*  * CityHash 的主要优点是大部分步骤包含了至少两步独立的数学运算 * 代码较同类流行算法复杂 */\n\n11.FNVHashFNV-1 hash\nhash = FNV_offset_basisfor each byte_of_data to be hashed    hash = hash × FNV_prime    hash = hash XOR byte_of_datareturn hash\nFNV-1a hash\nhash = FNV_offset_basisfor each byte_of_data to be hashed    hash = hash XOR byte_of_data    hash = hash × FNV_primereturn hash\n\n其它的比较\n\n\nHash函数\n数据1\n数据2\n数据3\n数据4\n数据1得分\n数据2得分\n数据3得分\n数据4得分\n平均分\n\n\n\nBKDRHash\n2\n0\n4774\n481\n96.55\n100\n90.95\n82.05\n92.64\n\n\nAPHash\n2\n3\n4754\n493\n96.55\n88.46\n100\n51.28\n86.28\n\n\nDJBHash\n2\n2\n4975\n474\n96.55\n92.31\n0\n100\n83.43\n\n\nJSHash\n1\n4\n4761\n506\n100\n84.62\n96.83\n17.95\n81.94\n\n\nRSHash\n1\n0\n4861\n505\n100\n100\n51.58\n20.51\n75.96\n\n\nSDBMHash\n3\n2\n4849\n504\n93.1\n92.31\n57.01\n23.08\n72.41\n\n\nPJWHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\nELFHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\n其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。\n经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。\n在信息修竞赛中，要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的。\n"},{"title":"我们需要谨慎操作Cache","url":"/2023/08/30/%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E%E6%93%8D%E4%BD%9CCache/","content":"\n成都有疫情有半个月了，在家办公的日子总是很枯燥的，很多的工作无法正常开展。今天有时间，我尝试对Ymodem的传输效率进行优化并完善其中的一些细节实现，本来一个简单的优化工作却牵出一个严重的问题，并最终折腾了一天才解决。这是一个并不典型的内存溢出问题，这种溢出的方式在以前的工作中完全没有遇到过。记录今天排查问题的过程以提醒自己，不严谨的Cache操作会导致内存溢出。\n\n今天一开始在修改并测试Ymodem相关的一些功能，主要是优化了内部数据封装逻辑，并改善数据传输速度。测试发现向单片机发送文件，速度有较大的改善。为了确认数据传输的正确性，使用Ymodem将单片机内的文件读取出来。\n惊！发送和接收到的文件数据不一致。\n查！🧐\n更换多个文件后测试发现，问题能够稳定复现，且每次从单片机内读取出的文件数据都不一样。是Ymodem在单片机内的发送有问题还是接收有问题呢？我决定使用系统内的FTP文件服务来协助排查，通过FTP能够非常方便的上传和下载文件。\n惊！😱\n通过FTP上传和下载的文件依旧存在问题。通过两种文件传输方式，每次文件都能稳定的传输，传输过程中没有出现任何问题，连Ymodem都没有发出NAK的消息，而且文件大小也没有问题，就唯独内容乱码，我是根据7zip的CRC校验来确认的。这就把问题牵扯到Ymodem功能以外的地方了，很显然该问题不是Ymodem直接导致的。\n到这里我认为这个问题比较严重了，这个工程代码中文件系统相关的代码一直运行都比较稳定。\n开始排查问题！\n我首先构造了一个内容清晰的文本文件abc.txt，约1700字节。使用FTP先上传到系统中，通过串口的命令行，使用指令查看文件内容，cat abc.txt。发现偶尔存在几行文本的乱码。但是更严重的是我发现连续发送cat abc.txt系统就崩溃了，最后一次的数据也没有显示出来。\n我到这里就基本上确认文件系统存在问题，且这个问题大概率是和文件传输不一致相关的问题。有了这个更容易复现的bug，我决定先从这里入手，相信这个问题很快就能解决。\n但实际上我真的低估这个问题了，我几乎花了一天的时间来排查这个问题，最终仅仅依靠一行代码解决。这充分诠释了一个真理，高端的BUG往往只需要最朴素的方式进行处理。\n下面我回顾一下我是如何一步一步排查问题的。\n问题的入口点肯定是cat指令，通过分析代码，定位到如下的逻辑：\nuint8_t tmp[4];file_h = vfopen(path, &quot;r&quot;);if(file_h)&#123;    while(1)&#123;        len = vfread(file_h, tmp, 4);        if(len &gt; 0)&#123;            output(tmp, len);        &#125;else&#123;            break;        &#125;    &#125;    vfclose(file_h);&#125;\n\n这段代码逻辑非常简单，打开文件，以4字节长度的方式依次读取数据并将它显示出来，直到全部数据读取完成。\n看到这里并没有什么好的想法，我决定打开调试器仿真。仿真起来后，发现问题点好像不是很稳定，偶尔会进入到hardfault，有时会陷入死循环。\n通过检查hardfault的触发原因，应该是访问了不该访问的地址，这个地址并没有什么意义，但是检查触发时的PC指针，基本能够定位到malloc模块中。\n进一步来看，前面说的还会进入死循环，这个循环也是在malloc模块中，死循环的原因是堆内存的空闲链表中出现了异常的值，导致链表出现问题。具体来说时malloc在分配内存时需要进行链表的操作，查询链表时无法正常触发结束条件导致进入了死循环。\n将问题定位到这里已经废了很大劲了，但是依然没有办法确定导致问题的原因。\n通过malloc的问题点进行栈回溯，确认是文件系统在申请内存，终于和文件系统关联上了。到此问题依然很迷茫，因为内存导致的问题通常不会花费我那么多时间。\n这个内存破坏分子到底是谁呢？？？\n我开始尝试打开内存的分配日志，保守起见，我先使用一种简单点的日志模型，它不会破坏现有的内存分配结构。\n通过日志我基本确认了出问题点前后所发送的事情，也就是在file_h = vfopen(path, “r”);会触发两次内存申请的操作。在多次执行cat abc.txt时，可能是前面内存分配的数据结构出现严重问题，导致后面分配内存就会出错。\n我开始怀疑是栈溢出导致内存链表出现问题，但是通过内存的分配日志，逐渐将这个想法排除，因为所有的任务栈都不在这段内存附近。\n逐渐陷入僵局，居然连内存出现破坏的点都没有捕获到！\n我决定使用更高级的内存日志来分析问题，但这可能会导致问题不复现，因为这种内存日志分析方法会在用户申请的内存前后额外再申请一部分空间，用来检测内存边界上是否出现破坏。我一开始担心内存布局出现变化会导致问题不复现，但是测试后发现这种方法是可行的，我终于定位到内存破坏的点了。也就是vfopen返回的文件句柄，这是一个动态申请的内存，大小为4184字节。通过内存日志分析，该段内存在释放时检查发现内存末尾出现数据溢出的情况。\n通过添加多个内存检查点，基本确认了内存破坏的代码段，也就是在vfread函数中，但是我任然不是很确定。毕竟这是一个多任务的系统。\n我决定使用内存断点来排查问题，通常内存断点都是能够很轻松的解决这类内存溢出的问题，在内存溢出位置设置监视断点，很容易查到是什么代码在修改内存数据。但是这次内存断点并没有帮我解决问题，内存断点看起来并没有起作用。我没有在这里纠缠太久，我不想去查内存断点为什么没有生效。因为今天大部分时间都在盯着这个问题，精神也有点儿恍惚了。\n为什么读取文件数据会将句柄外的数据破坏了呢？我发现句柄结构体中末尾是一个4096字节的数据缓存，是在读取数据时导致内存溢出吗？\n我检查了许久文件系统中文件读取相关的代码，并没有可疑的地方。\n我开始尝试在存储介质上寻找原因，存储介质是一块8M的flash，spi总线访问。\n前面都没有提到这个存储介质，因为我能够确认这个存储介质是完好的，它能够稳定的存储数据，并可靠的读取出来。\n我通过日志分析从falsh读取数据时将数据填充到那些地址空间下。flash读取出的数据并没有填充到那个被破坏的地址下，这也就排除了DMA的问题。\n本来到此我决定放过存储介质上的驱动代码，但是我还是做了一些尝试。我在flash驱动的读取函数入口处先检查一遍那个内存边界是否破坏，在出口再检查一遍内存是否破坏。\n喜！🎉🎉🎉\n居然问题就在这个驱动函数中。通过逐行分析，最终确认问题点。\nflash读取函数大致是这样的：\n\n1.构造数据读取请求；\n2.发送数据读取请求；\n3.通过DMA将数据直接传输到内存中；\n4.将该段内存相对应的Cache清除；\n\n就是第4个代码存在问题，在存在Cache的系统中，使用DMA传输数据后，为了后面CPU从物理地址中取得有效数据，需要将Cache中的数据清除掉，这是非常必要且正常的逻辑(除非内存不具备Cache特性)。\n但是这里忽略了一个点，清除Cache的操作并不是想清除那段内存就清除那段内存，它是需要字节对齐的，32字节对齐，在这个系统中Cache的操作接口不是原生的CMSIS接口，而是包装过的，它为了保证数据操作可靠，它会自动对齐到32字节的边界上，首尾均是这样。如果操作的内存地址不是32字节对齐时，会导致在清除Cache时错误的将期望内存外的数据都清除掉了，而这部分数据可能还没有及时的写入到物理内存中。这类似与一种数据溢出的效果，但是又与一般的内存溢出有很大的区别。\n\n最终，我尝试了一个简单的解决办法，在触发DMA数据传输前，将Cache中的数据先同步到物理内存中，这样问题就解决了。只需要一行代码，完美解决了cat指令导致系统出错的问题，连同最开始文件传输数据异常都一并解决了。到这里也解释了为什么内存断点为什么没有生效，由Cache引入的内存问题使用内存断点的排查手段不一定有效。再说一句，通过DMA写入的内存数据，内存断点也是无法捕获的。\n这个问题以前没有暴露出来肯能是因为以前的那个内存地址正好是32字节对齐的。检查GIT提交记录，该问题已经暴露很长时间了。\n通过这个问题，反应了滥用SCB_InvalidateDCache_by_Addr()接口导致数据溢出的问题。后面需要再次排查系统中其它Cache操作，看看是否存在类似问题。\n"},{"title":"我们需要非常谨慎的使用Cache","url":"/2024/07/11/%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%9D%9E%E5%B8%B8%E8%B0%A8%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8Cache/","content":"最近在学习的过程中遇到一个软件上的问题，该问题非常折磨人。\n在一个嵌入式软件系统中使用WiFi网络并通过FTP服务读取设备内存储在SD上的文件，就是这样一个看起来非常简单的逻辑，最近在测试过程中出现了一点问题。\n发现小概率情况下文件传输会导致系统崩溃，崩溃的问题点也是非常奇怪的，会爆发出很多稀奇古怪的问题(包括但不限于malloc返回null、内存申请卡死、网络协议栈数据异常等等)，且该故障似乎很难在调试模式下复现。\n该故障仅在上述条件下会触发，其它情况下没有复现：\n\n通过FTP读取内存中的文件(ramfs)不会导致系统崩溃\n通过USB连接网络，仍然通FTP传输SD卡上的文件，系统不会崩溃\n在系统内通过文件拷贝方法在SD和nand直接传输文件，系统不会崩溃\n关闭系统D-Cache，使用wifi通过FTP读取SD卡的文件，系统不会崩溃\n\n分析以上情况，好像很难确定问题点。但该故障大概率是与Cache相关的，因为这可以解释为什么在调试模式下问题不那么容易复现。\n整个系统相当复杂，底层磁盘驱动、文件系统、文件系统抽象层、网络协议栈、FTP服务、WIFI驱动、操作系统等等。我花费了相当多的额时间去梳理WIFI驱动代码，这是我最不熟悉的一部分，但是WIIF驱动看来没有明显的问题。\n其中多个与硬件相关的组件均会使用到DMA和Dcache的操作，好像没有办法把问题聚焦到一个点上。\n系统出现故障时的一种常见现象是内存分配器出现故障，包括无法分配内存(但显示存在剩余内存)、无法释放内存等。\n我设计了一种检查机制，即在内存分配和释放的时候检查一下内存分配器的链表释放正常。该方法确实有用，它能够迅速的捕获系统最近出现故障的时刻，这使得复现和分析问题非常有帮助。\nvTaskSuspendAll();&#123;    int tot_len = 0;    BlockLink_t * pxBlock;    pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );    while( pxBlock != pxEnd )&#123;        tot_len += pxBlock-&gt;xBlockSize;        pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock-&gt;pxNextFreeBlock );    &#125;    configASSERT( tot_len == xFreeBytesRemaining );&#125;( void ) xTaskResumeAll();\n当发现系统内剩余内存和链表中描述的剩余内存不一致后立即中断系统运行。\n配合内存分配日志和Cache操作日志，确定是SD卡驱动的一次INVALID DCACHE操作后内存分配器就出现故障了。\nint sdmmc_read(void *buf, int len)&#123;    // 1:    CLEAN_DCACHE(buf, len);    // 2:    SD_ReadBlocks_DMA(buf, len);    // 3:    INVALID_DCACHE(buf, len);    return 0;&#125;\n\n解释一下这段代码的含义。第3行代码，当使用DMA读取数据后，需要将缓存中的数据清除掉，这是为了后续CPU读取数据时可以读取到物理内存中的数据，而非Cache中的数据。第1行代码，这段代码有点不太好解释，当buf和Cache边界未对齐时，后续的第三步可能会使得buf边界外到Cache边界中的数据被清除掉，这就使得系统内的数据完整性无法得到保证，所以设计了第1步的代码来将附近的数据全部同步到内存中。\n以上的设计在我以前的文章中提到过，可以去翻看一下。\n这样的设计在单线程环境下是没有问题的，但是在多线程下就会有点问题，因为第2行代码是一个耗时操作，这就使得已经被同步到内存中的数据可能又被另一个线程取出放入Cache，而后续的第3行代码还不知道这样的情况，直接将缓存清除掉了，导致系统内部分数据丢失，进而导致出现系统崩溃的情况。\n一个安全的做法是为DMA读取操作单独分配一块与Cache边界对齐的一块缓存，用它作为数据传输的桥梁，由DMA读取完成后再由CPU将数据搬运到其它内存空间下。但是这样有一些缺陷，即无法连续读取多块数据，这会导致SDMMC出现严重的性能瓶颈，一般SDMMC连续读取多块扇区有更明显的速度优势。\n所以需要设计另外一种方法来安全的清理Cache，且必须考虑线程安全问题。\n#define CACHE_SIZE (32)void InvalidDCache(void *addr, int len)&#123;    __disable_irq();    static char cache_head_buf[CACHE_SIZE - 1];    static char cache_end_buf[CACHE_SIZE - 1];    uint32_t cache_head_addr;    uint32_t cache_head_len;    uint32_t cache_end_addr;    uint32_t cache_end_len;    cache_head_addr = ((uint32_t)(addr) &amp; ~(CACHE_SIZE - 1));    cache_head_len = ((uint32_t)(addr) &amp; (CACHE_SIZE - 1));    cache_end_addr = ((uint32_t)(addr) + len);    cache_end_len = CACHE_SIZE - (cache_end_addr &amp; (CACHE_SIZE - 1));    if(cache_end_len == CACHE_SIZE)&#123;        cache_end_len = 0;    &#125;    if(cache_head_len &gt; 0)&#123;        memcpy(cache_head_buf, cache_head_addr, cache_head_len);    &#125;    if(cache_end_len &gt; 0)&#123;        memcpy(cache_end_buf, cache_end_addr, cache_end_len);    &#125;    SCB_InvalidateDCache_by_Addr(addr, len);    if(cache_head_len &gt; 0)&#123;        memcpy(cache_head_addr, cache_head_buf, cache_head_len);    &#125;    if(cache_end_len &gt; 0)&#123;        memcpy(cache_end_addr, cache_end_buf, cache_end_len);    &#125;    __enable_irq();&#125;\n这段代码可以解决缓存Invalidate带来的风险，它将边界上的内存主动保存了一遍。\n但还有一个问题似乎不可忽略，那就是缓存自动写入的情况，当切换线程上下文后执行了其它的内存密集操作，当缓存不足时，可能导致原先的缓存被自动写入到内存中，尤其是边界上的，这仍然可能出现数据失效的问题。\n最终，我选择牺牲性能来保证可靠性，通过一个中间缓存来读取数据，确保DMA和Cache的操作都是安全可靠的。当然在实现过程中可以通过检查输入的内存指针是否与Cache边界对齐，如果是对齐的情况，那么就可以绕过中间缓存直接读取数据。\nCache的问题总是那么有意思。最好的情况还是应该在软件设计时就能够保证数据边界对齐，或者牺牲一定的性能来保证数据的可靠性和系统安全性。\nPS：为什么wifi传输数据异常而USB网卡传输数据正常呢？因为USB网卡驱动内部没有频繁的内存申请操作，而wifi设备驱动中有频繁的内存申请操作。出现Cache问题的那块内存正好是从堆内获取的，且故障边界正好命中内存管理器的空闲链表数据项。所以频繁的内存申请操作会导致该问题更容易复现。\n"},{"title":"更优雅的使用Protothreads协程框架","url":"/2023/08/30/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Protothreads%E5%8D%8F%E7%A8%8B%E6%A1%86%E6%9E%B6/","content":"PT协程框架PT(Protothreads)是一个轻量级的多任务框架，区别于一般基于栈的RTOS，它实现多任务的基本原理是通过语句间的任意跳转来实现任务切换，所以实现多任务的开销比较小。\n我们看一段示例代码来了解其用法。\n/** * This is a very small example that shows how to use * protothreads. The program consists of two protothreads that wait * for each other to toggle a variable. *//* We must always include pt.h in our protothreads code. */#include &quot;pt.h&quot;#include &lt;stdio.h&gt; /* For printf(). *//* Two flags that the two protothread functions use. */static int protothread1_flag, protothread2_flag;/** * The first protothread function. A protothread function must always * return an integer, but must never explicitly return - returning is * performed inside the protothread statements. * * The protothread function is driven by the main loop further down in * the code. */static intprotothread1(struct pt *pt)&#123;  /* A protothread function must begin with PT_BEGIN() which takes a     pointer to a struct pt. */  PT_BEGIN(pt);  /* We loop forever here. */  while(1) &#123;    /* Wait until the other protothread has set its flag. */    PT_WAIT_UNTIL(pt, protothread2_flag != 0);    printf(&quot;Protothread 1 running\\n&quot;);    /* We then reset the other protothread&#x27;s flag, and set our own       flag so that the other protothread can run. */    protothread2_flag = 0;    protothread1_flag = 1;    /* And we loop. */  &#125;  /* All protothread functions must end with PT_END() which takes a     pointer to a struct pt. */  PT_END(pt);&#125;/** * The second protothread function. This is almost the same as the * first one. */static intprotothread2(struct pt *pt)&#123;  PT_BEGIN(pt);  while(1) &#123;    /* Let the other protothread run. */    protothread2_flag = 1;    /* Wait until the other protothread has set its flag. */    PT_WAIT_UNTIL(pt, protothread1_flag != 0);    printf(&quot;Protothread 2 running\\n&quot;);        /* We then reset the other protothread&#x27;s flag. */    protothread1_flag = 0;    /* And we loop. */  &#125;  PT_END(pt);&#125;/** * Finally, we have the main loop. Here is where the protothreads are * initialized and scheduled. First, however, we define the * protothread state variables pt1 and pt2, which hold the state of * the two protothreads. */static struct pt pt1, pt2;intmain(void)&#123;  /* Initialize the protothread state variables with PT_INIT(). */  PT_INIT(&amp;pt1);  PT_INIT(&amp;pt2);    /*   * Then we schedule the two protothreads by repeatedly calling their   * protothread functions and passing a pointer to the protothread   * state variables as arguments.   */  while(1) &#123;    protothread1(&amp;pt1);    protothread2(&amp;pt2);  &#125;&#125;\n一个任务就是一个单独的函数和一个记录任务状态的句柄。通过在一个循环中一直执行所有任务相关的函数就能够实现多任务的效果，因为它是非抢占式的，如果某个任务函数不需要执行的时机了，那么它就主动退出该函数并将执行时机转移到下一个任务函数。由于pt句柄记录了函数内部执行的位置，所以下次进入任务函数能够恢复上一次执行的位置。\n相比于传统的RTOS，PT协程的用法不够灵活，任务不能动态的创建，任务的调度是提前分配好的，如果需要实时的创建或者删除一个任务，上面的这种写法就不是很方便。\n基于PT实现一套更优雅的任务框架主要是需要解决PT协程框架不能动态创建任务的问题，解决的办法是使用链表将所有的任务管理起来，将创建好的任务就放入到链表中，如果任务结束或删除就将其从链表中删除。实现一个调度器自动调度并运行链表中的所有任务。为了完全保留原始PT的用法，这里只新增任务创建和调度的实现，其余用法保持不变。\n这里链表的引用参考Linux内核链表，其实现和使用都很简单。\n首先需要定义一个全局的链表，用于管理所有的任务。\n// pt_os.c#include &quot;list.h&quot;LIST_HEAD(pt_pool);\n\n剩余的内容就只需要在头文件中实现即可。\n// pt_os.h#ifndef _PT_OS_H#define _PT_OS_H#include &quot;pt.h&quot;#include &quot;list.h&quot;typedef struct&#123;    struct list_node list;    PT_THREAD((*task)(struct pt *pt));    struct pt pt;&#125; pt_item_t;extern struct list_node pt_pool;/** * Run pt os. * OS_SCHEDULE() executes an infinite loop. *  * Example usage: * @code&#123;c&#125; * int main(void)&#123; *     //... *     for(;;)&#123; *         OS_SCHEDULE(); *     &#125; *     return 0; * &#125; * @endcode */#define OS_SCHEDULE()                                           \\    do                                                          \\    &#123;                                                           \\        pt_item_t *pt_item;                                     \\        list_for_each_entry(&amp;pt_pool, pt_item, pt_item_t, list) \\        &#123;                                                       \\            if (pt_item-&gt;task(&amp;(pt_item-&gt;pt)) &gt;= PT_EXITED)     \\            &#123;                                                   \\                list_delete(&amp;(pt_item-&gt;list)); break;           \\            &#125;                                                   \\        &#125;                                                       \\    &#125; while (0)/**  * Create a new pt task. *  * Example usage: * @code&#123;c&#125; * PT_THREAD(iwdg_task(struct pt *pt))&#123; *      static struct timer periodic_timer; *      PT_BEGIN(pt); *      timer_set(&amp;periodic_timer, 100); *      while(1)&#123; *          HAL_IWDG_Refresh(&amp;hiwdg); *          PT_WAIT_UNTIL(pt, timer_expired(&amp;periodic_timer)); *          timer_reset(&amp;periodic_timer); *      &#125; *      PT_END(pt); * &#125; *  * int main(void)&#123; *     OS_TASK_RUN(iwdg_task); *     //... *     for(;;)&#123; *         OS_SCHEDULE(); *     &#125; *     return 0; * &#125; * @endcode */#define OS_TASK_RUN(func)                            \\    do                                               \\    &#123;                                                \\        static pt_item_t pt_##_func;                 \\        pt_##_func.task = func;                      \\        PT_INIT(&amp;(pt_##_func.pt));                   \\        list_add_head(&amp;pt_pool, &amp;(pt_##_func.list)); \\    &#125; while (0)#endif\n\n这里定义任务结构pt_item_t，相比与原生PT，每个任务会多占用12字节的RAM，此外就没有多余的开销了。使用OS_TASK_RUN()方法可以创建一个新的任务，它可以将PT任务添加到任务列表中。OS_SCHEDULE()方法用于调度所有的PT任务，它需要放入到一个循环中一直执行，当某个任务执行退出后可以将它从任务列表中自动删除。\n这里存在一些缺陷，任务的入口不能传递参数，如果一定要实现这个功能那也是很容易的，对pt_item_t中的任务签名做调整即可。 \n通过这段短小的代码(大约20行)就拓展了原生PT的实现，达到任务的自动调度，任务的动态创建和删除，这样在资源受限的单片机内能够实现更加灵活的异步编程。\n"},{"title":"第一次向FreeRTOS内核提交代码","url":"/2024/06/20/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%91FreeRTOS%E5%86%85%E6%A0%B8%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/","content":"背景前段时间我在测试wolfSSL中RSA相关代码的时候，发现在进行加密、解密、key生成过程中存在一些性能问题。在分析问题的过程中，发现算法对堆内存的申请非常频繁。生成一对2048长度的公钥和私钥，会进行10万次以上的内存申请。我为了跟踪函数在执行过程中的内存具体使用情况，决定设计一套堆内存跟踪机制来评估函数的内存使用情况。\n在设计内存跟踪机制的过程中，我发现了一个FreeRTOS内核中的Bug，最终该Bug由我亲自修复，相关修复代码已经合并入内核代码主线。\n设计一个内存跟踪机制原本想设计一个不依赖堆实现的的内存跟踪机制，但我发现各种堆内存的实现可能都存在一些差别，尤其是不太好分析内存释放时相关内存块的大小(C库的实现就是这样)。妥协后我决定基于目前的情况，配合FreeRTOS的heap实现来设计相关的内存跟踪机制。\nFreeRTOS预留了traceMALLOC(pv, size)和traceFREE(pv, size)两个跟踪宏，用于指示内存申请和释放。它会指示内存指针和内存的大小。\n基于这两个宏，我就能记录内存的分配次数、释放次数、内存的实时用量、内存的最大用量、内存泄露等。再通过一个简单的异或操作，可用非常方便的检测内存的申请和是否是否成对。\n整个跟踪机制的代码如下：\n// heapt.h#ifndef _HEAPT_H#define _HEAPT_H#include &lt;stdint.h&gt;typedef struct &#123;    uint32_t trace_enable;    uint32_t malloc_count;    uint32_t free_count;    uint32_t malloc_used_count;    uint32_t malloc_max_count;    uint32_t memory_used;    uint32_t memory_max_used;    uint32_t ptr_xor;    uint32_t malloc_faild;&#125; heapt_info_t;void heapt_init(void);void heapt_deinit(void);const heapt_info_t *heapt_get_info(void);// FreeRTOS hookvoid heapt_trace_malloc(void *ptr, uint32_t size);void heapt_trace_free(void *ptr, uint32_t size);#endif\n#include &quot;heapt.h&quot;#include &lt;string.h&gt;static heapt_info_t heapt_info;void heapt_init(void)&#123;    memset(&amp;heapt_info, 0, sizeof(heapt_info));    heapt_info.trace_enable = 1;&#125;void heapt_deinit(void)&#123;    memset(&amp;heapt_info, 0, sizeof(heapt_info));&#125;const heapt_info_t *heapt_get_info(void)&#123;    return &amp;heapt_info;&#125;void heapt_trace_malloc(void *ptr, uint32_t size)&#123;    if(heapt_info.trace_enable == 0)&#123;        return ;    &#125;    if(ptr == NULL)&#123;        heapt_info.malloc_faild++;        return ;    &#125;    heapt_info.malloc_count++;    heapt_info.malloc_used_count++;    heapt_info.memory_used += size;    if(heapt_info.malloc_used_count &gt; heapt_info.malloc_max_count)&#123;        heapt_info.malloc_max_count = heapt_info.malloc_used_count;    &#125;    if(heapt_info.memory_used &gt; heapt_info.memory_max_used)&#123;        heapt_info.memory_max_used = heapt_info.memory_used;    &#125;    heapt_info.ptr_xor ^= (uint32_t)ptr;&#125;void heapt_trace_free(void *ptr, uint32_t size)&#123;    if(heapt_info.trace_enable == 0)&#123;        return ;    &#125;    heapt_info.free_count++;    heapt_info.malloc_used_count--;    heapt_info.memory_used -= size;    heapt_info.ptr_xor ^= (uint32_t)ptr;&#125;int heapt(int argc, char * const argv[])&#123;    int ret;    if(argc &lt; 2)&#123;        printf(&quot;Usage: %s PROG [ARGS]\\r\\n&quot;, argv[0]);        return 1;    &#125;    heapt_init();    ret = run_cmd(argc - 1, &amp;argv[1]);    const heapt_info_t *info = heapt_get_info();    printf(&quot;max heap use: %lu\\r\\n&quot;, info-&gt;memory_max_used);    printf(&quot;max alloc nm: %lu\\r\\n&quot;, info-&gt;malloc_max_count);    printf(&quot;malloc count: %lu\\r\\n&quot;, info-&gt;malloc_count);    printf(&quot; free  count: %-8lu&quot;  , info-&gt;free_count);    if(info-&gt;malloc_count != info-&gt;free_count)&#123;        printf(&quot; [Warning]\\r\\n&quot;);    &#125;else&#123;        printf(&quot;\\r\\n&quot;);    &#125;    if(info-&gt;memory_used != 0)&#123;        printf(&quot;used at exit: %-8lu [Warning]\\r\\n&quot;, info-&gt;memory_used);    &#125;    if(info-&gt;ptr_xor)&#123;        printf(&quot;mem ptr xor : %08lx [Warning]\\r\\n&quot;, info-&gt;ptr_xor);    &#125;    if(info-&gt;malloc_faild)&#123;        printf(&quot;malloc faild: %-8lu [Warning]\\r\\n&quot;, info-&gt;malloc_faild);    &#125;    heapt_deinit();    return ret;&#125;\n\n基于该内存跟踪，我测试了一些常用的代码，发现它都工作良好，直到我测试RSA相关代码时。RSA一个解密操作就动辄100k+次的内存申请量，导致系统出现了一些意外的情况。\n系统日志显示：\nmax heap use: 17264max alloc nm: 16malloc count: 279544 free  count: 279544used at exit: 4294967288 [Warning]\n日志显示内存分配和释放的内存字节数不相等，导致程序退出时内存记录的量不为0。起初我以为是内存有用法问题，但wolfSSL作为一款商业级的软件，应该不存在这样低级的错误。且mem ptr xor也没有报告内存泄露，内存申请和释放次数也是相等的。至此我不得不怀疑FreeRTOS提供的traceMALLOC(pv, size)和traceFREE(pv, size)存在问题。\n发现FreeRTOS内核代码存在问题FreeRTOS的heap4实现是基于空闲块链表实现的，将所有的可用内存块以链表的形式连接起来，当分配的内存小于内存块时，会将内存块进行分割，将其中一部分返回到用户，另一部分重新插入到空闲链表中。\n// pvPortMalloc()// ....if( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )&#123;    /* This block is to be split into two.  Create a new        * block following the number of bytes requested. The void        * cast is used to prevent byte alignment warnings from the        * compiler. */    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );    configASSERT( ( ( ( size_t ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == 0 );    /* Calculate the sizes of two blocks split from the        * single block. */    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;    pxBlock-&gt;xBlockSize = xWantedSize;    /* Insert the new block into the list of free blocks. */    pxNewBlockLink-&gt;pxNextFreeBlock = pxPreviousBlock-&gt;pxNextFreeBlock;    pxPreviousBlock-&gt;pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );&#125;else&#123;    mtCOVERAGE_TEST_MARKER();&#125;xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;if( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )&#123;    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;&#125;else&#123;    mtCOVERAGE_TEST_MARKER();&#125;// ....traceMALLOC( pvReturn, xWantedSize );//...\n传入到traceMALLOC(pv, size)的size参数是用户传入的内存大小，这里返回到用户的内存卡大小可能比用户预期想要的要大。因为内存块可拆分的条件是内存块拆分后剩余的大小必须大于16字节，如果不满足条件则该内存不拆分且不会进一步去寻找其它的内存块，这样返回到用户的内存块大小实际上要比用户预期的要大一些。\n// vPortFree()// ...vTaskSuspendAll();&#123;    /* Add this block to the list of free blocks. */    xFreeBytesRemaining += pxLink-&gt;xBlockSize;    traceFREE( pv, pxLink-&gt;xBlockSize );    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );    xNumberOfSuccessfulFrees++;&#125;( void ) xTaskResumeAll();// ...\n而传入到traceFREE(pv, size)的size正好是内存块的大小。这就导致了malloc和free时记录到的内存用量不一致。\n这真是一个有意思的发现。traceMALLOC机制由早在2013年的V7.5.3版本引入，在过去的这段时间内大家似乎并没有经常使用它，导致这个问题潜伏了10年之久。好在这仅仅是一个作为调试功能存在的bug，而且它不会影响FreeRTOS的主要功能。\n6月5日，我在FreeRTOS-Kernel上提交了相关Issue，内核开发小组很快确认该问题并建议我提交一个Pull Request来修复它。注：存在该问题的最后版本应该为V11.1.0\n修复内核代码这个问题看起来非常简单，只需要将实际分配的内存块大小传入到 trace_MALLOC()函数中即可。但实际操作起来却让我非常为难。\n\n当内存申请失败时，该size是0还是用户想要的内存大小xWantedSize？\n直接修改xWantedSize还是新建变量进行处理？\nheap1和heap3是否需要同步修改？\n\n我向内核提交的第一版代码是在内存块不拆分时修改xWantedSize，这样就能够使得trace_MALLOC获得正确的大小。但是官方在第一次审核我的代码时建议我建立一个新的变量用于表示内存块的大小而非使用xWantedSize，于是我修改了代码，这样看起来代码的可读性更高。由于不同处理器架构的heap实现有多个，我没法逐个去测试验证。PR代码只测试了heap4，但是其它的修改是一致的，且代码会经过GIT服务器上的自动化流程测试。确保代码在代码风格、可集成性、功能上都满足规范要求。\n从我提交PR - Fix traceMALLOC() allocated bytes到将代码合并入主干仅花了两天时间，过程很顺利。由于我的github账号是中文昵称，这导致合并到主线的代码作者名称显示为中文昵称，而不是我的英文名。这在Git-Graph中看起来怪怪的，似乎我没有看到其它开发者使用中文昵称提交的代码。😅\n在我发现问题和解决问题的过程中，内核开发者都比较友好，也对我做的工作给予了肯定。这也是第一次尝试在大型开源项目中贡献代码，一段非常有意思的经历。\n"},{"title":"统计FreeRTOS中各个线程的处理器利用率","url":"/2023/08/30/%E7%BB%9F%E8%AE%A1FreeRTOS%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/","content":"\n大约是在一年前，我在工作中遇到了需要分析嵌入式系统性能的需求，需要查看系统在关键时间点上，部分任务是否存在执行时间过长导致系统实时性能降低的情况。我在基于FreeRTOS的系统中设计了一段非侵入式的代码，能够获取到各个线程实时的处理器利用率，进而分析系统是否设计合理。最近我在整理以前的代码时又看到当时设计的这个功能，我发现当时仅仅是满足了一个基本的功能需求，部分地方还设计的不是足够的合理，所以最近抽空想把这个功能整理完善，以备以后工作之需。\n\n处理器利用率如何理解处理器利用率？这里摘抄了Linux系统中对这个词的理解：\nCPU Usage:The task&#x27;s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time.\n翻译过来差不多就是指在一段时间长度T内，线程A的运行时间占用了t，则在这段T时间端内，线程A的处理器利用率为 t/T。如果了解操作系统运作的原理，再来理解处理器利用率是非常简单的。\n统计每个线程的执行时间FreeRTOS操作系统内核本身是支持统计任务执行时间的，但是它是统计从任务开始运行时计算的，这种统计方法无法分析实时的处理器利用率，而且长时间的记录会导致内部时间计数器溢出，所以需要重新设计统计线程执行时间的功能。\n统计一个任务的执行时间长度需要在任务开始运行和结束运行的时间点上计时，这里的开始运行和结束运行是指任务对处理器的占用情况，而不是指任务真正的开始和结束。结合FreeRTOS内核可以利用内核提前设计好的Hook机制找到任务进入和退出的时机，也就是下面两个宏：\n#ifndef traceTASK_SWITCHED_IN/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the selected task. */    #define traceTASK_SWITCHED_IN()#endif#ifndef traceTASK_SWITCHED_OUT/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the task being switched out. */    #define traceTASK_SWITCHED_OUT()#endif\n\n这里的注释非常好理解，根据这两个Hook函数和pxCurrentTCB就能够掌握每个线程的切换情况。这里先说明一点，这个功能对FreeRTOS内核是非侵入的，不会到FreeRTOS内核代码做任何改动。\n接下来就是需要设计一个高精度的定时器，以我的经验来看定时器精度至少要达到微秒级别以上才行，因为有时候线程的切入和切出非常的块，定时器精度不够的话就无法准确的计算执行时间。\n这里我采用的高精度定时器是DWT内核调试模块的计时单元，它的运行频率和处理器一致，所以定时精度是足够的，而且32位的计数器也能够满足一定时间长度的计时需求，这个内核调试模块在ARM Cortex-M处理器中都存在。\n这里是我设计的DWT计时功能代码：\n/* cpu tick timer config. */#define TIME_SEC_TO_US (1000000u)#define CPU_CLK_FREQ() (SystemCoreClock)#if defined(DWT) &amp;&amp; defined(CoreDebug)static unsigned int fclk_pre_us;static inline void cpu_ts_time_init(void)&#123;    fclk_pre_us = CPU_CLK_FREQ() / TIME_SEC_TO_US;    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;    DWT-&gt;CTRL        |= DWT_CTRL_CYCCNTENA_Msk;    DWT-&gt;CYCCNT       = 0;&#125;static inline unsigned int cpu_ts_timrd(void)&#123;    //return us    return (DWT-&gt;CYCCNT / fclk_pre_us);&#125;static inline void cpu_ts_reset(void)&#123;    DWT-&gt;CYCCNT = 0;&#125;\n提供了计数器初始化、复位、记录时间的功能。\n记录FreeRTOS各个任务的运行时间建立一个长度为MAX_TASK_NUMS的数组task_runtime用于存储每个任务的执行时间，数组中的每一项对应一个任务，所以需要为每个任务分配一个唯一的ID，FreeRTOS内核为每个任务分配了独立的ID，但是这些ID是不受控制的，即ID的分配总是递增的，任务删除后不会回收。所以需要为每个任务重新分配ID并在任务删除后做回收的处理。\n#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;\n\n分配ID的过程是足够简单的，不会对系统的性能产生太多额外的影响。同样的利用Hook机制，把它嵌入到FreeRTOS内核中。\n// FreeRTOSConfig.h#define traceTASK_CREATE(pxTCB)  alloc_task_id(pxTCB)#define traceTASK_DELETE(pxTCB)  release_task_id(pxTCB)\n\n通过task_runtime[(TASK_ID(pxCurrentTCB))]就能记录和访问线程的运行时间。\n接下来就是最关键的traceTASK_SWITCHED_IN()和traceTASK_SWITCHED_OUT()，它们看起来还是比较简单的，一个最基础的逻辑如下：\nstatic uint32_t switch_in_time = 0;static uint32_t task_runtime[MAX_TASK_NUMS] = &#123;0&#125;;void task_switched_out(void)&#123;    task_runtime[(TASK_ID(pxCurrentTCB))] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();&#125;\n\n到此就实现了记录任务的运行时间，但是这和FreeRTOS内部的实现是类似的，我们需要在适当的时候清空所有的任务运行时间并重置计数器，保证系统总是记录任务最新的处理器利用率。\n记录任务实时的处理器利用率如果只有一个缓存记录处理器的运行时间，就会存在一个这样的情况，当运行时间情况的时候，正好需要查看处理器的利用率，那此时就看不到准确的数据。所以设计两个缓存，一个用于记录当前的数据，另一个用于缓存上一次的数据并给予用户访问。\n最终完整的设计实现如下：\nextern void* pxCurrentTCB;#define STAT_PERIOD (3000000u)#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])#define CURRENT_TASK_ID (TASK_ID(pxCurrentTCB))#define MAX_TASK_NUMS (32)static uint32_t switch_in_time = 0;static uint32_t task_runtime_buf1[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_runtime_buf2[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_total_runtime = 0;static uint32_t *task_current_runtime = task_runtime_buf1;void task_switched_out(void)&#123;    task_current_runtime[CURRENT_TASK_ID] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();    if(switch_in_time == 0)&#123;        cpu_ts_time_init();        switch_in_time = cpu_ts_timrd();    &#125;    if(switch_in_time &gt; STAT_PERIOD)&#123;        cpu_ts_reset();        task_total_runtime = switch_in_time;        switch_in_time = 0;        if(task_current_runtime == task_runtime_buf1)            task_current_runtime = task_runtime_buf2;        else            task_current_runtime = task_runtime_buf1;        for(int i = 0; i &lt; MAX_TASK_NUMS; i++) task_current_runtime[i] = 0;    &#125;&#125;/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;static int task_id_exist(int id)&#123;    return (id_pool &amp; (1 &lt;&lt; id));&#125;static const uint32_t *get_task_runtime(void)&#123;    if(task_current_runtime == task_runtime_buf1)        return task_runtime_buf2;    else        return task_runtime_buf1;&#125;int show_cpu_usage(int argc, char **argv)&#123;    char buf[1024] = &#123;0&#125;;    int buf_len = 0;    // os_enter_critical();    const uint32_t *tick_buf = get_task_runtime();    float r = 0;    uint32_t irq_runtime = task_total_runtime;    for(int i = 0; i &lt; MAX_TASK_NUMS; i++)&#123;        if(!task_id_exist(i))&#123;            continue;        &#125;        if(i == 0)&#123;            if(tick_buf[i] &gt; 0)                buf_len += sprintf(buf + buf_len, &quot;&gt;32 --  &quot;);            else                continue;        &#125;else&#123;            buf_len += sprintf(buf + buf_len, &quot;%2d  --  &quot;, i);        &#125;        if(tick_buf[i] == 0)&#123;            buf_len += sprintf(buf + buf_len, &quot;0\\n&quot;);        &#125;else&#123;            r = 100.0f * (float)tick_buf[i] / task_total_runtime;            if(r &lt; 0.01f)                buf_len += sprintf(buf + buf_len, &quot;&lt;0.01%%\\n&quot;);            else                buf_len += sprintf(buf + buf_len, &quot;%.2f%%\\n&quot;, r);        &#125;        irq_runtime -= tick_buf[i];    &#125;    r = 100.0f * (float)irq_runtime / task_total_runtime;    buf_len += sprintf(buf + buf_len, &quot;IS  --  %.2f%%\\n&quot;, r);    // os_exit_critical(0);    puts(buf);    return 0;&#125;\n记录周期为3000ms，这个时间需要结合定时器的溢出时间、系统性能要求做调整，时间太短会影响系统调度性能，太长会导致处理器利用率统计的实时性降低，且计数器存在溢出的风险。\n最后这里写了一段简单的代码来输出各个任务的CPU利用率，经过我的测试，它能够很好的工作。访问数据时建议进入到临界区处理，这样更加安全。在实际使用时，每个线程使用ID表示的，ID和任务名称的关系可以通过FreeRTOS内核函数vTaskList()得到，一一对应即可。\n总结内容我写的比较仓促，其中部分细节我没有太多的说明，但我认为这些都是比较好理解。关于任务ID的分配，还有些细节没有说明，我将超过31个任务后面的任务ID统一分配为0，它们的处理器利用率将一并计算，这是我的ID分配器决定的，它只能分配31个ID。\n当时我实现这个功能时忽略了FreeRTOS内核对任务ID的分配策略，当时我直接引用系统分配的ID，如果不对任务进行删除操作，他还是能够可靠的工作。但是如果需要进行任务删除，那么就会出现一些奇怪的问题。我也是最近才发现这个问题。主要是当时对FreeRTOS内核内的一些细节还是不够了解。\n关于中断的执行时间，我这里只是粗略的估算了一个irq_runtime ，它包含了大部分任务调度的时间，并不能够保证把所有的中断时间统计在内。\n这里涉及到了高精度定时器、快速ID的分配、双缓冲机制、内核调度、非侵入式设计等内容，每个都能够拿出来细讲，限于时间和篇幅就点到为止。如果你有幸看到这篇文章，对其中的内容有疑问或者建议，欢迎一起沟通学习。\n"},{"title":"简单尝试一下ITCM","url":"/2023/12/15/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8BITCM/","content":"ITCM简介在STM32高性能单片机中存在一种供内核专用的内存TCM-SRAM，称为紧耦合内存。为了区分不同的用途，又存在称为DTCM和ITCM的两种不同内存，这两种内存本质上是一致的，但是其背后默认的MPU策略不同，所以一般将DTCM用于存储关键的堆栈数据，将ITCM用于存储关键代码的指令。\n由于TCM内存拥有独立的总线直连Cortex内核，它不经过AXI总线矩阵，所以理论上它应该要块很多才对。那TCM相比于一般的内存到底快多少呢？这里做一些简单的测试来说明一下。\nITCM运行测试构造一个简单的函数作为测试的对象：\nvoid runtest(void)&#123;  for(int i = 0; i &lt; 2000 * 1000; i++)&#123;    __NOP();    __NOP();    __NOP();    __NOP();  &#125;&#125;\n\n测试的芯片选用STM32H7B0芯片，其主频280MHz，理论上主频越高，ITCM的优势越明显。\n这里还需要说明一下D-Cache，指令缓存也能显著提高代码的运行速度，所以这里设计了4中不同的测试场景。通过统计被测函数的执行时钟周期来反应代码的执行速度。\n注：测试时未开启编译优化，调用函数在Flash中，运行栈为AXI-SRAM\n\n1.关闭D-Cache，被测函数在Flash中执行运行周期：26065054\n2.关闭D-Cache，被测函数在ITCM中执行运行周期：15088644\n3.开启D-Cache，被测函数在Flash中执行运行周期：16019317\n4.开启D-Cache，被测函数在ITCM中执行运行周期：14017011\n\n通过以上的数据不难看出ITCM的优势。在ITCM中运行的指令比在Flash中开启了D-Cache的指令运行还要块。测试的第4中情况相比于第1种情况性能更是提升了45%以上。\n如何使用ITCM这里简单介绍在gcc开发平台下如何方便快捷的使用ITCM。\n首先需要在链接脚本中为函数分配独立的字段，用于将相关函数链接到ITCM中。\n/* Initialized ramfunc sections goes into RAM, load LMA copy after code */_siramfunc = LOADADDR(.ramfunc);.ramfunc :&#123;  . = ALIGN(4);  _sramfunc = .;     /* create a global symbol at data start */  *(.RamFunc)        /* .RamFunc sections */  *(.RamFunc*)       /* .RamFunc* sections */  . = ALIGN(4);  _eramfunc = .;     /* define a global symbol at data end */&#125; &gt;ITCMRAM AT&gt; FLASH\n这里需要注意，RamFunc可能已经存在于data字段中，需要将其中data字段中删除。\n这段链接脚本将函数的存储地址放到Flash中用于持久固化，将函数运行地址放到ITCM中用于执行。\n之后需要代码将Flash中的代码数据搬运到ITCM中，这部分工作最好在汇编代码中完成。\n/* 这部分放到最前面 */.word _siramfunc.word _sramfunc.word _eramfunc/* 这部分插入到启动汇编代码中 *//* Copy RamFunc segment from flash to RAM */  ldr r0, =_sramfunc  ldr r1, =_eramfunc  ldr r2, =_siramfunc  b LoopCopyRamFuncCopyRamFunc:  ldr r3, [r2], #4  str r3, [r0], #4LoopCopyRamFunc:  cmp r0, r1  bcc CopyRamFunc\n如果认为汇编较复杂，也可以使用C代码替代，作用是一样的：\nextern uint8_t _siramfunc;extern uint8_t _sramfunc;extern uint8_t _eramfunc;memcpy(&amp;_sramfunc, &amp;_siramfunc, (uint32_t)(&amp;_eramfunc - &amp;_sramfunc));\n\n这样当声明函数时就可以将函数存放到ITCM中，并实现持久化的运行：\nvoid runtest(void) __attribute__((section(&quot;.RamFunc&quot;)));void runtest(void)&#123;  for(int i = 0; i &lt; 2000 * 1000; i++)&#123;    __NOP();    __NOP();    __NOP();    __NOP();  &#125;&#125;\n\n其它的开发平台也是类似的原理。\nITCM的一些限制ITCM用起来也不是完美的，当涉及较多的函数间调用时，如果指令地址频繁在Flash、ITCM直接来回切换，会产生许多不必要的开销，因为它们两个区域的地址跨度太大，无法直接跳转，编译器会产生一些虚拟函数来实现这个跳转的过渡，无论是Flash到ITCM，还是ITCM到Flash都会有这样的操作。\nITCM主要是用于执行一些时间敏感的函数，例如中断函数，使得中断能够更快响应。还有就是例如FFT这种纯粹的计算型函数，它不会发生较多的其它函数调用且函数执行时间较长，这也能发挥ITCM的关键优势。\n"},{"title":"锁相环(PLL)基本原理","url":"/2024/03/03/%E9%94%81%E7%9B%B8%E7%8E%AF(PLL)%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","content":"\n本文转载自《模拟对话》卷52，文章原作者是Ian Collins，《模拟对话》是亚德诺半导体的一份技术期刊，专注于电子模拟技术的最新进展和应用。原作者和亚德诺半导体对本文保留所有权利。本文不采用 BY-NC-SA 许可协议。PLL被广泛应用于嵌入式系统开发中的时钟同步和频率合成，本文可以帮助嵌入式软件开发工程师理解PLL的基本工作原理。\n\nIan Collins “AnalogDialogue” Volume 52, July 2018\n摘要：锁相环(PLL)电路存在于各种高频应用中，从简单的时钟净化电路到用于高性能无线电通信链路的本振(LO)，以及矢量网络分析仪(VNA)中的超快开关频率合成器。本文将参考上述各种应用来介绍PLL电路的一些构建模块，以指导器件选择和每种不同应用内部的权衡考虑，这对新手和PLL专家均有帮助。本文参考ADI公司的ADF4xxx和HMCxxx系列PLL和压控振荡器(VCO)，并使用ADIsimPLL（ADI公司内部PLL电路仿真器）来演示不同电路性能参数。\n基本配置：时钟净化电路锁相环的最基本配置是将参考信号(FREF)的相位与可调反馈信号(RFIN)F0的相位进行比较，如图1所示。图2中有一个在频域中工作的负反馈控制环路。当比较结果处于稳态，即输出频率和相位与误差检测器的输入频率和相位匹配时，我们说PLL被锁定。就本文而言，我们仅考虑ADI公司ADF4xxx系列PLL所实现的经典数字PLL架构。\n该电路的第一个基本元件是鉴频鉴相器(PFD)。PFD将输入到REFIN的频率和相位与反馈到RFIN的频率和相位进行比较。ADF4002是一款可配置为独立PFD（反馈分频器N=1）的PLL。因此，它可以与高质量压控晶体振荡器(VCXO)和窄低通滤波器一起使用，以净化高噪声REFIN时钟。\n\n\n图1. PLL基本配置\n图2. PLL基本配置\n\n\n鉴频鉴相器\n\n图3. 鉴频鉴相器\n\n\n图3中的鉴频鉴相器将+IN端的FREF输入与和-IN端的反馈信号进行比较。它使用两个D型触发器和一个延迟元件。一路Q输出使能正电流源，另一路Q输出使能负电流源。这些电流源就是所谓电荷泵。有关PFD操作的更多详细信息，请参阅”用于高频接收器和发射器的锁相环“。\n使用这种架构，下面+IN端的输入频率高于-IN端（图4），电荷泵输出会推高电流，其在PLL低通滤波器中积分后，会使VCO调谐电压上升。这样，-IN频率将随着VCO频率的提高而提高，两个PFD输入最终会收敛或锁定到相同频率（图5）。如果-IN频率高于+IN频率，则发生相反的情况。\n\n\n图4. PFD错相和频率失锁\n图5. 鉴频鉴相器、频率和锁相\n\n\n回到原先需要净化的高噪声时钟例子，时钟、自由运行VCXO和闭环PLL的相位噪声曲线可以在ADIsimPLL中建模。\n\n\n图6. 参考噪声\n图7. 自由运行VCXO\n图8. 总PLL噪声\n\n\n从所示的ADIsimPLL曲线中可以看出，REFIN的高相位噪声（图6）由低通滤波器滤除。由PLL的参考和PFD电路贡献的所有带内噪声都被低通滤波器滤除，只在环路带宽外（图8）留下低得多的VCXO噪声（图7）。当输出频率等于输入频率时，PLL配置最简单。这种PLL称为时钟净化PLL。对于此类时钟净化应用，建议使用窄带宽(&lt;1kHz)低通滤波器。\n高频整数N分频架构为了产生一系列更高频率，应使用VCO，其调谐范围比VCXO更宽。这常用于跳频或扩频跳频(FHSS)应用中。在这种PLL中，输出是参考频率的很多倍。压控振荡器含有可变调谐元件，例如变容二极管，其电容随输入电压而改变，形成一个可调谐振电路，从而可以产生一系列频率（图9）。PLL可以被认为是该VCO的控制系统。\n反馈分频器用于将VCO频率分频为PFD频率，从而允许PLL生成PFD频率倍数的输出频率。分频器也可以用在参考路径中，这样就可以使用比PFD频率更高的参考频率。ADI公司的ADF4108就是这样的PLL。PLL计数器是电路中要考虑的第二个基本元件。\n\n\n图9. 压控振荡器\n\n\nPLL的关键性能参数是相位噪声、频率合成过程中的多余副产物或杂散频率（简称杂散）。对于整数N PLL分频，杂散频率由PFD频率产生。来自电荷泵的漏电流会调制VCO的调谐端口。低通滤波器可减轻这种影响，而且带宽越窄，对杂散频率的滤波越强。理想单音信号没有噪声或额外杂散频率（图10），但在实际应用中，相位噪声像裙摆一样出现在载波边缘，如图11所示。单边带相位噪声是指在距离载波的指定频率偏移处，1Hz带宽内相对于载波的噪声功率。\n\n\n图10. 理想LO频谱\n图11. 单边带相位噪声\n\n\n整数N和小数N分频器在窄带应用中，通道间隔很窄（通常&lt;5MHz），反馈计数器N很高。通过使用双模P/P + 1预分频器，如图12所示，可以利用一个小电路获得高N值，并且N值可以利用公式N = PB + A来计算；以8/9预分频器和90的N值为例，计算可得B值为11，A值为2。对于A或2个周期，双模预分频器将进行9分频。对于剩余的(B-A)或9个周期，它将进行8分频，如表1所示。预分频器一般利用较高频率电路技术设计，例如双极性射极耦合逻辑(ECL)电路，而A和B计数器可以接受这种较低频率的预分频器输出，它们可以利用低速CMOS电路制造，以减少电路面积和功耗。像ADF4002这样的低频净化PLL省去了预分频器。\n\n\n图12. 具有双模N计数器的PLL\n\n\n表1. 双模预分频器操作\n\n\n\nN Value\nP/P + 1\nB Value\nA Value\n\n\n\n90\n9\n11\n2\n\n\n81\n9\n10\n1\n\n\n72\n8\n9\n0\n\n\n64\n8\n8\n0\n\n\n56\n8\n7\n0\n\n\n48\n8\n6\n0\n\n\n40\n8\n5\n0\n\n\n32\n8\n4\n0\n\n\n24\n8\n3\n0\n\n\n16\n8\n2\n0\n\n\n8\n8\n1\n0\n\n\n0\n8\n0\n0\n\n\n带内（PLL环路滤波器带宽内）相位噪声受N值直接影响，带内噪声增幅为20log(N)。因此，对于N值很高的窄带应用，带内噪声主要由高N值决定。利用小数N分频合成器（例如ADF4159或HMC704），可以实现N值低得多但仍有精细分辨率的系统。这样一来，带内相位噪声可以大大降低。图13至图16说明了其实现原理。在这些示例中，使用两个PLL来生成适合于5G系统本振(LO)的7.4GHz至7.6GHz频率，通道分辨率为1MHz。ADF4108以整数N分频配置使用（图13），HMC704以小数N分频配置使用。HMC704（图14）可以使用50MHz PFD频率，这会降低N值，从而降低带内噪声，同时仍然支持1MHz（或更小）的频率步长——可注意到性能改善15dB（在8kHz偏移频率处）（图15与图16对比）。但是，ADF4108必须使用1MHz PFD才能实现相同的分辨率。\n对于小数N分频PLL务必要小心，确保杂散不会降低系统性能。对于HMC704之类的PLL，整数边界杂散（当N值的小数部分接近0或1时产生，例如147.98或148.02非常接近整数值148）最需要关注。解决措施是对VCO输出到RF输入进行缓冲，以及/或者做精心的规划频率，改变REFIN以避免易发生问题的频率。\n\n\n图13. 整数N分频PLL\n图14. 小数N分频PLL\n图15. 整数N分频PLL带内相位噪声\n图16. 小数N分频PLL带内相位噪声\n\n\n对于大多数PLL，带内噪声高度依赖于N值，也取决于PFD频率。从带内相位噪声测量结果的平坦部分减去20log(N)和10log(FPFD)得到品质因数(FOM)。选择PLL的常用指标是比较FOM。影响带内噪声的另一个因素是1/f噪声，它取决于器件的输出频率。FOM贡献和1/f噪声，再加上参考噪声，决定了PLL系统的带内噪声。\n用于5G通信的窄带LO对于通信系统，从PLL角度来看，主要规格有误差矢量幅度(EVM)和VCO阻塞。EVM在范围上与积分相位噪声类似，考虑的是一系列偏移上的噪声贡献。对于前面列出的5G系统，积分限非常宽，从1kHz开始持续到100 MHz。EVM可被认为是理想调制信号相对于理想点的性能降幅百分比（图17）。类似地，积分相位噪声将相对于载波的不同偏移处的噪声功率进行积分，表示通过配置可以计算EVM、积分相位噪声、均方根相位误差和抖动。现代信号源分析仪也会包含这些数值（图18），只需按一下按钮即可得到。随着调制方案中密度的增加，EVM变得非常重要。对于16-QAM，根据ETSI规范3GPP TS 36.104，EVM最低要求为12.5%。对于64-QAM，该要求为8%。然而，由于EVM包括各种其他非理想参数（功率放大器失真和不需要的混频产物引起），因此积分噪声通常有单独的定义（以dBc为单位）。\n\n\n图17. 相位误差可视化\n图18. 信号源分析仪图\n\n\nVCO阻塞规范在需要考虑强发射存在的蜂窝系统中非常重要。如果接收器信号很弱，并且VCO噪声太高，那么附近的发射器信号可能会向下混频，淹没目标信号（图19）。图19演示了如果接收器VCO噪声很高，附近的发射器（相距800kHz）以-25dBm功率发射时，如何淹没-101dBm的目标信号。这些规范构成无线通信标准的一部分。阻塞规范直接影响VCO的性能要求。\n\n\n图19. VCO噪声阻塞\n\n\n压控振荡器(VCO)我们的电路中需要考虑的下一个PLL电路元件是压控振荡器。对于VCO，相位噪声、频率覆盖范围和功耗之间的权衡十分重要。振荡器的品质因数(Q)越高，VCO相位噪声越低。然而，较高Q电路的频率范围比较窄。提高电源电压也会降低相位噪声。在ADI公司的VCO系列中，HMC507的覆盖范围为6650MHz至7650MHz，100kHz时的VCO噪声约为-115dBc/Hz。相比之下，HMC586覆盖了从4000MHz到8000MHz的全部倍频程，但相位噪声较高，为-100dBc/Hz。为使这种VCO的相位噪声最小，一种策略是提高VCO调谐电压VTUNE的范围（可达20V或更高）。这会增加PLL电路的复杂性，因为大多数PLL电荷泵只能调谐到5V，所以利用一个由运算放大器组成的有源滤波器来提高PLL电路的调谐电压。\n多频段集成PLL和VCO另一种扩大频率覆盖范围而不恶化VCO相位噪声性能的策略是使用多频段VCO，其中重叠的频率范围用于覆盖一个倍频程的频率范围，较低频率可以利用VCO输出端的分频器产生。ADF4356就是这种器件，它使用四个主VCO内核，每个内核有256个重叠频率范围。该器件使用内部参考和反馈分频器来选择合适的VCO频段，此过程被称为VCO频段选择或自动校准。\n多频段VCO的宽调谐范围使其适用于宽带仪器，可产生范围广泛的频率。此外，39位小数N分辨率使其成为精密频率应用的理想选择。在矢量网络分析仪等仪器中，超快开关速度至关重要。这可以通过使用非常宽的低通滤波器带宽来实现，它能非常快地调谐到最终频率。在这些应用中，通过使用查找表（针对每个频率直接写入频率值）可以绕过自动频率校准程序，也可以使用真正的单核宽带VCO，如HMC733，其复杂性更低。\n对于锁相环电路，低通滤波器的带宽对系统建立时间有直接影响。低通滤波器是我们电路中的最后一个元件。如果建立时间至关重要，应将环路带宽增加到允许的最大带宽，以实现稳定锁定并满足相位噪声和杂散频率目标。通信链路中的窄带要求意味着使用HMC507时，为使积分噪声最小（30kHz至100MHz之间），低通滤波器的最佳带宽约为207kHz（图20）。这会贡献大约-51dBc的积分噪声，可在大约51μs内实现频率锁定，误差范围为1kHz（图22）。\n相比之下，宽带HMC586（覆盖4GHz至8GHz）以更接近300kHz带宽的更宽带宽实现最佳均方根相位噪声（图21），积分噪声为-44dBc。但是，它在不到27μs的时间内实现相同精度的频率锁定（图23）。正确的器件选择和周围电路设计对于实现应用的最佳结果至关重要。\n\n\n图20. 相位噪声HMC704加HMC507\n图21. 相位噪声HMC704加HMC586\n图22. 频率建立：HMC704加HMC507\n图23. HMC704加HMC586\n\n\n低抖动时钟对于高速数模转换器(DAC)和高速模数转换器(ADC)，干净的低抖动采样时钟是必不可少的构建模块。为使带内噪声最小，应选择较低的N值；但为使杂散噪声最小，最好选择整数N值。时钟往往是固定频率，因此可以选择频率以确保REFIN频率恰好是输入频率的整数倍。这样可以保证PLL带内噪声最低。选择VCO（无论集成与否）时，须确保其噪声对应用而言足够低，尤其要注意宽带噪声。然后需要精心放置低通滤波器，以确保带内PLL噪声与VCO噪声相交——这样可确保均方根抖动最低。相位裕度为60°的低通滤波器可确保滤波器峰值最低，从而较大限度地减少抖动。这样的话，低抖动时钟就落在本文讨论的第一个电路的时钟净化应用和所讨论的最后一个电路的快速开关能力之间。\n对于时钟电路，时钟的均方根抖动是关键性能参数。这可以利用ADIsimPLL估算，或使用信号源分析仪测量。对于像ADF5356这样的高性能PLL器件，相对较宽的低通滤波器带宽(132kHz)，配合WenxelOCXO之类的超低REFIN源，允许用户设计均方根抖动低于90fs的时钟（图26）。操纵PLL环路滤波器带宽(LBW)的位置表明，如果降低太多，VCO噪声在偏移较小时（图24）将开始占主导地位，带内PLL噪声实际上会降低，而如果提高太多的话，带内噪声在偏移处占主导地位，VCO噪声则显著降低（图25）。\n\n\n图24. LBW = 10 kHz，331 fs抖动\n图25. LBW = 500 kHz，111 fs抖动\n图26. LBW = 132 kHz，83 fs抖动\n\n\n参考电路Collins, Ian. “用于无线应用的集成PLL和VCO.” Radio Electronics, 2010年。\nCurtin, Mike and Paul O’Brien. “用于高频接收器和发射器的锁相环。” 《模拟对话》，第33卷，1999年。\n作者Ian Collins毕业于爱尔兰科克大学，拥有电气和电子工程学位并从2000年起在ADI公司的射频和微波部工作。他目前是微波频率生成部的应用经理，主要负责锁相环(PLL)和压控振荡器(VCO)产品方面的工作。非工作时间或不陪伴家人时，Ian喜欢摄影和戏剧（无论是在台上还是在台下）、阅读以及听音乐。\n"},{"title":"阻抗匹配","url":"/2024/02/18/%E9%98%BB%E6%8A%97%E5%8C%B9%E9%85%8D/","content":"\n本人非专业领域工作者，内容难免瑕疵，所以仅供参考。\n\n什么是阻抗匹配？阻抗匹配的概念应用在各个工程领域，但在射频电路领域，阻抗匹配有更加重要的意义。阻抗匹配的目的在于将能量完整的从一个端口传输到另一个端口上，当负载的输入阻抗和源的输出阻抗共轭相等时则认为阻抗匹配。当源和负载的阻抗不相等时，可以在其之间插入一个无源网络进行阻抗转换，使得源和负载之间达到阻抗匹配的要求。\n什么是阻抗？阻抗是一个表征电路特性的一个重要参数，通常定义为电路在给定频率下对交流电的总阻抗。它是一个矢量值，实数部分可以理解为一般的电阻，虚数部分为电抗，电抗是由电容或电感导致的。这里说一下电容和电感的阻抗计算公式，对于电感来说：\n对于电容来说：\n电阻、电容和电感串并联后的阻抗值计算方法仍然同初中时学习的电阻串并联规则类似，只是将实数替换为了复数。\n和串联的总阻抗为。\n和并联的总阻抗为，并满足关系。为了方便表述可以记为\n说到阻抗可以顺便说一下Q值，这里主要是说电感电容的Q值，也就是元件的品质因数。由于实际的电容和电感存在ESR，所以实际的元件电抗不纯。为了表征元件电抗的纯粹程度，使用Q值来表示，其值为：\n对于源阻抗和负载阻抗，其满足匹配的要求是，即阻抗共轭相等。\n电抗计算器\n\n\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    电感:    \n    \n        nH\n        uH\n        mH\n        H\n    \n    感抗:    Ω \n    计算\n\n\n\n\n\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    电容:    \n    \n        pF\n        nF\n        uF\n        mF\n        F\n    \n    容抗:    Ω \n    计算\n\n\n\n\n阻抗并联计算器\n    阻抗A:    \n    阻抗B:    \n    并联阻抗:    Ω \n    计算\n\n\n阻抗匹配的方法如果源端口的阻抗和负载的阻抗不一致，会导致能量无法最大化的传输，为了使能量最大化的传输，在源和负载之间插入一个无耗匹配网络来使得源阻抗和匹配网络的输入端匹配，匹配网络的输出端和负载匹配，这样就间接使得源和负载达成匹配条件。\n这里看一个一般情况，就是常见的L型匹配网络：\n\n\nL型匹配\n\n\n其中源阻抗为，负载阻抗是，根据串并联规则，满足匹配的条件为：\n就是从负载点开始，串联元件就是相加，并联元件就是并联计算。复杂的匹配网络仍然遵循该规则。\n通常L型匹配网络的Q值较差，更复杂的Pi型匹配和T型匹配可以获得更高的Q值，但是计算会更加复杂，但计算原理是一致的。\n匹配网络中可以使用电阻元件，但是使用电阻会导致匹配网络带来插入损耗，因为电阻会消耗能量，而电感和电容不会消耗能量。使用电阻进行匹配仍然满足上述的串并联计算公式。\n通过匹配条件方程来解算L和C的值是非常麻烦的，更推荐的方法是使用一些现成的工具进行计算，如Smith工具和ADS仿真软件等。\nLC巴伦前面提到了LC匹配网络，这里再顺带说一下LC巴伦，这也是射频电路中常见到的。\n\n\n4 element balun\n\n\n该电路的解为：为了使得L和C具有实数解，通常LC巴伦两端的阻抗都为实数阻抗，或者保证根号内为实数即可。如果为复数，但是为实数，可以考虑再前串联电感、电容或者LC网络来进行阻抗转换。\n相关的计算工具有AppCAD。\n4元件实数LC巴伦设计\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    ZL:    Ω\n    Zs:    Ω\n    计算\n    电感:   \n    电容:   \n\n\n\ninput{\n    width: 230px;\n    height: 30px;\n    border: 1px solid #D4D6D9;\n    border-radius: 4px;\n    padding-left: 8px;\n    padding-right: 8px;\n    box-sizing: border-box;\n}\ninput:disabled{\n    background-color: #E6E8EB;\n}\nselect{\n    width: 76px;\n    height: 30px;\n    border: 1px solid #D4D6D9;\n    border-radius: 4px;\n    padding-left: 8px;\n    padding-right: 8px;\n    box-sizing: border-box;\n}\nbutton{\n    width: 76px;\n    height: 32px;\n    line-height: 32px;\n    text-align: center;\n    box-sizing: border-box;\n    color: #fff;\n    background-color: #2F51FF;\n    border-radius: 4px;\n    border: none;\n}\n\n\n\n\n    function calc_ind(){\n        var freq = $(\"#ind_freq\").val() * $(\"#ind_freq_unit\").val()\n        var value = $(\"#ind_value\").val() / $(\"#ind_value_unit\").val()\n        var ret = 2 * Math.PI * freq * value\n        $(\"#ind_result\").val(ret.toFixed(3))\n    }\n    function calc_cap(){\n        var freq = $(\"#cap_freq\").val() * $(\"#cap_freq_unit\").val()\n        var value = $(\"#cap_value\").val() / $(\"#cap_value_unit\").val()\n        var ret = -1/(2 * Math.PI * freq * value)\n        $(\"#cap_result\").val(ret.toFixed(3))\n    }\n    function complex_add(a, b){\n        return [a[0] + b[0], a[1] + b[1]]\n    }\n    function complex_mul(a, b){\n        return [a[0] * b[0] - a[1]*b[1], a[0]*b[1]+a[1]*b[0]];\n    }\n    function complex_conjugate(a){\n        return [a[0], -a[1]]\n    }\n    function complex_div(a, b){\n        var p = complex_mul(b, complex_conjugate(b));\n        if(p[0] == 0){\n            return [0, 0];\n        }\n        var m = complex_mul(a, complex_conjugate(b));\n        return [m[0] / p[0], m[1] / p[0]];\n    }\n    function calc_parallel(){\n        var a = $(\"#imp_a\").val();\n        var b = $(\"#imp_b\").val();\n        var as = a.split(/\\+|\\-/);\n        var bs = b.split(/\\+|\\-/);\n        var a_real = Number(as[0]);\n        var a_imag = 0;\n        if(as.length > 1){\n            a_imag = Number(as[1].substring(1))\n            if(a[a.indexOf('j')-1] == '-'){\n                a_imag = -a_imag\n            }\n        }\n        var b_real = Number(bs[0]);\n        var b_imag = 0;\n        if(bs.length > 1){\n            b_imag = Number(bs[1].substring(1))\n            if(b[b.indexOf('j')-1] == '-'){\n                b_imag = -b_imag\n            }\n        }\n        var pa = [a_real, a_imag]\n        var pb = [b_real, b_imag]\n        var ans = complex_div(complex_mul(pa, pb), complex_add(pa, pb));\n        var flag = \"+\";\n        if(ans[1] < 0){\n            flag = \"-\";\n            ans[1] = -ans[1]\n        }\n        $(\"#imp_pra\").val(ans[0].toFixed(3).toString(10) + flag + \"j\" + ans[1].toFixed(3).toString(10))\n    }\n    function calc_balun(){\n        var zs = $(\"#balun_Zs\").val();\n        var zl = $(\"#balun_Zl\").val();\n        var freq = $(\"#balun_freq\").val() * $(\"#balun_freq_unit\").val()\n        var tmp = Math.sqrt(1.0 * zs * zl);\n        var cap = 1 / tmp / (2 * Math.PI * freq);\n        var cap_unit = 0;\n        while(cap > 0 && cap < 1 && cap_unit < 5){\n            cap = cap * 1000;\n            cap_unit = cap_unit + 1;\n        }\n        var cu = \"F\";\n        if(cap_unit == 0) cu = \"F\";\n        else if(cap_unit == 1) cu = \"mF\";\n        else if(cap_unit == 2) cu = \"uF\";\n        else if(cap_unit == 3) cu = \"nF\";\n        else if(cap_unit == 4) cu = \"pF\";\n        else if(cap_unit == 5) cu = \"fF\";\n        else cu = \"\"\n        var ind = tmp / (2 * Math.PI * freq);\n        var ind_unit = 0;\n        while(ind > 0 && ind < 1 && ind_unit < 3){\n            ind = ind * 1000;\n            ind_unit = ind_unit + 1;\n        }\n        var iu = \"\";\n        if(ind_unit == 0) iu = \"H\";\n        else if(ind_unit == 1) iu = \"mH\";\n        else if(ind_unit == 2) iu = \"uH\";\n        else if(ind_unit == 3) iu = \"nH\";\n        else iu = \"\"\n        $(\"#balun_L_value\").val(ind.toFixed(3).toString(10) + iu)\n        $(\"#balun_C_value\").val(cap.toFixed(3).toString(10) + cu)\n    }\n\n"},{"title":"C语言宏的图灵完备","url":"/2024/09/19/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/","content":"\n这里讨论的C语言宏系统仅关于#define，不包含#include, #if，#ifdef，#elif，#else，#endif等。\n\nC语言宏的可选参数前段时间在某个嵌入式软件项目中涉及一个这样的功能，需要将一个wav音频文件嵌入式到二进制固件中，这样可以方便获取音频文件数据且不需要文件系统等复杂的组件。以前的做法是将音频文件写入到Flash中固定的地址下，然后再软件代码中从该地址访问相关的数据。但是这样的做法存在一定的灵活性问题，比如文件是否可能和固件重叠、无法统一烧录等问题。\n后面我想到可以使用gcc汇编中的一条命令来实现在代码中包含一个文件，那就是.incbin指令。该指令在手册的描述如下：\n.incbin &quot;file&quot;[,skip[,count]]The incbin directive includes file verbatim at the current location. You can control the search paths used with the ‘-I’ command-line option (see Command-Line Options). Quotation marks are required around file.The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user’s responsibility to make sure that proper alignment is provided both before and after the incbin directive.\n\n将这个命令简单的使用宏封装一下，就可以在C代码文件中非常轻松的嵌入一个音频文件了。\n#define INCFILE(name, file)                             \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;\\n&quot;                        \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;);                                   \\    extern int __##name##_start;                        \\    extern int __##name##_end;#define FILEPTR(name) ((void*)&amp;(__##name##_start))#define FILESIZE(name) ((char*)&amp;(__##name##_end) - (char*)&amp;(__##name##_start))\n\n封装之后，就可以在C代码中直接使用如下方式来嵌入音频文件：\nINCFILE(audio, &quot;audio.wav&quot;);int main()&#123;    printf(&quot;audio size: %d\\n&quot;, FILESIZE(audio));    printf(&quot;audio ptr: %p\\n&quot;, FILEPTR(audio));    return 0;&#125;\n\n再后来的使用过程中发现wav音频文件前的44字节是音频文件头，可以忽略，只需要使用后面的PCM数据即可。这样就需要将incbin中skip选项了，但是上面涉及的INCFILE()宏没有提供这个功能，所有又需要重新写一个宏。\n#define INCFILE_PART(name, file, offset, count)         \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset)        \\        &quot;,&quot; INCF_STR(count) &quot;\\n&quot;                        \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;);                                   \\    extern int __##name##_start;                        \\    extern int __##name##_end;\n\n这样的写法似乎也不太复合要求，因为这里不需要count参数，需要包含文件的全部内容，所以需要再封装一个宏？\n类似的操作为什么需要写多个宏？这样的操作似乎就太不优雅了。\n能不能实现一个这样的宏，能够提供多个可选参数呢？根据参数个数生成不同的代码。\nINCFILE(audio, &quot;audio.wav&quot;)INCFILE(audio, &quot;audio.wav&quot;, 44)INCFILE(audio, &quot;audio.wav&quot;, 44 1024)\n\n这样就引入了一个非常关键的问题，C语言的宏定义如何根据参数个数来动态生成代码呢？\n#define INCFILE(...) \\    if (NUM(__VA_ARGS__) == 2) &#123; INCFILE(__VA_ARGS__)&#125; else &#123; INCFILE_PART(__VA_ARGS__) &#125;\n\n可以很明确的说，上面的代码是错误的，C语言的宏定义无法执行条件判断，所以无法实现这个功能。\n宏定义如何实现条件分支流程呢？我们从一个简单的需求开始，请设计一个宏，判断宏参数列表中的参数个数是0个还是1个。\n#define PARA_FOLLOW(...) 0, ##__VA_ARGS__, 1, 0\n\n我们来看看这段宏填入一些参数后展开的情况：\n/* PARA_FOLLOW(a) -&gt;    0, a, 1, 0PARA_FOLLOW() -&gt;    0, 1, 0 */\n\n仔细观察可以发现展开后的结果中第三个数据就是该宏输入的参数个数。这似乎就解决了参数条件判断的问题，那如何进行分支流程呢？将PARA_FOLLOW宏中跟随的0和1替换为分支语句，这样就完成了完整的条件分支。\n#define GET_P4(p1, p2, p3, p4, ...) p4#define SELECT_012_PARA(p0, p1, p2, ...) GET_P4(0, ##__VA_ARGS__, p2, p1, p0)/* SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);) -&gt;    printf(&quot;hello world\\n&quot;);SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);, 1) -&gt;    printf(&quot;hello macro\\n&quot;);SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);, a, b) -&gt;    printf(&quot;hello hexo\\n&quot;); */\n\nSELECT_012_PARA()宏可以根据可以参数列表中参数的数量来生成不同的代码，而不关心参数具体的值。\n据此，我重新设计了INCFILE()宏：\n#define INCFILE_OFFSET(file, offset)                    \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset) &quot;\\n&quot;        #define INCFILE_COUNT(file, offset, count, ...)         \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset)        \\        &quot;,&quot; INCF_STR(count) &quot;\\n&quot;#define INCFILE_PARA(name, file, offset, ...)           \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        SELECT_012_PARA(                                \\            INCFILE_OFFSET(file, 0),                    \\            INCFILE_OFFSET(file, offset),               \\            INCFILE_COUNT (file, offset, ##__VA_ARGS__, 0), \\            ##__VA_ARGS__)                              \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;                                     \\    )#define INCFILE(name, file, ...)                        \\    INCFILE_PARA(name, file, ##__VA_ARGS__, 0);         \\    extern int __##name##_start;                        \\    extern int __##name##_end;\n\nINCFILE可以使用不同的参数数量，来选择是否需要跳过头部数据。\n// hello.txt content is 12345678hellohello12345INCFILE(file1, &quot;hello.txt&quot;)INCFILE(file2, &quot;hello.txt&quot;, 8)INCFILE(file3, &quot;hello.txt&quot;, 8, 10)int main(void)&#123;     assert(memcmp(FILEPTR(file1), &quot;12345678hellohello12345&quot;,          FILESIZE(file1)) == 0);     assert(memcmp(FILEPTR(file2), &quot;hellohello12345&quot;, FILESIZE(file2)) == 0);     assert(memcmp(FILEPTR(file3), &quot;hellohello&quot;, FILESIZE(file3)) == 0);     return 0;&#125;\n一个宏函数实现了多种功能，看起来有点多态的性质。\n至此，一个在嵌入式软件开发过程中一个不起眼的问题就被成功解决了。\n宏定义是否可以实现递归？完成条件分支功能后，我进行了进一步的思考，在宏定义中能否实现递归呢？\n请设计一个宏，该宏可以传入任意个整数，返回一个表达式，表示其最大值。\nC语言的初学者可能都写过这样的宏：\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))/* MAX(1, 2) -&gt;    ((1) &gt; (2) ? (1) : (2)) */\n这只能接受2个参数，如果传入3个参数，就会报错。任意个参数的递归版本也许是这样的：\n#define MAX(a, ...) (a &gt; MAX(__VA_ARGS__) ? a : MAX(__VA_ARGS__))\n\n实际展开情况呢？\n/* MAX(1, 2, 3) -&gt;    (1 &gt; MAX(2, 3) ? 1 : MAX(2, 3)) */\n\n宏定义看起来无法正常的递归展开。这时候去检索相关的资料发现，C语言的宏定义确实无法直接实现递归。\n但是在查询资料的时候，我发现通过一种通过延迟求值的技巧，可以做到有限的递归。\n说到延迟求值，那就有必要先回顾一下C语言宏定义的求值规则。\n宏定义的求值规则先展开内层实参，再展开外层宏函数。如果形参前有#、#@或者形参前后有##，则对应实参不展开。\n宏函数求值规则特别复杂，简单来说，先计算实参的值，替换到宏函数中，然后重新进行计算。\n每当宏展开为非宏的标识符后，将触发重新扫描，从开始处重新计算。当对宏函数A()求值时遇到A，会将其标记为非宏标识符以避免递归，即使从外层重新对其进行扫描也无法对其继续展开。\n一个例子进行求值说明：\n#define A(p1, p2, p3, p4, p5) p5#define B() 1, 2, 3#define C(a) A(a, 0, B())#define A_I(...) A(__VA_ARGS__)#define C_I(a) A_I(a, 0, B())C(1) -&gt;      // 先计算内层参数值，1无需计算C(1) -&gt;      // 展开外层宏函数A(1, 0, B()) // Error, 展开后只有三个参数，无法匹配宏定义，直接报错C_I(1) -&gt;    // 先计算内层参数值，1无需计算C_I(1) -&gt;    // 展开外层宏函数A_I(1, 0, B()) -&gt;   // A_I为不定参数个数的宏，可以展开，先计算内层参数值，需要计算B()A_I(1, 0, 1, 2, 3) -&gt;  // 展开外层宏函数A(1, 0, 1, 2, 3)   -&gt;  // 计算内层参数值，所有参数都无需计算，直接展开外层宏函数3// 看一个特别的例子#define A_I2(...) A(##__VA_ARGS__)#define C_I2(a) A_I2(a, 0, B())C_I2(1) -&gt;   // 先计算内层参数值，1无需计算C_I2(1) -&gt;   // 展开外层宏函数A_I2(1, 0, B()) -&gt;  // 此时本应该先展开内层参数，也就是B()，但A_I2参数中的##阻止                    // 了1, 0, B()这个整体被求值。所以继续展开外层宏函数A(1, 0, B()) // Error, 参数数量不匹配，报错// 可以仔细对比C_I()和C_I2()的差异，唯一的区别就是__VA_ARGS__多了一个##// 正常情况下__VA_ARGS__前的##表示忽略可选参数带来的额外空格。// 在大多数情况下影响不大，但在遇到宏嵌套复合求值时会导致宏展开顺序不一致的问题。\n\n再看一个许多网友都没有正确理解的例子：\n#define  cat(a,b)     a ## b#define  xcat(x, y)   cat(x, y)xcat ( xcat ( 1 , 2 ) , 3 ) -&gt; xcat ( cat ( 1 , 2 ) , 3 ) -&gt;xcat ( 12 , 3 ) -&gt;cat ( 12 , 3 ) -&gt;123// 有部分文章在使用这个例子介绍宏嵌套求值顺序时写错了。大家不要被错误的信息误导。// 如果你对此表示怀疑，那么你可以使用ppstep工具去查看宏展开过程中的细节。\n\n在编写宏函数是注意一个技巧，在描述宏嵌套时，对于外层的宏函数实现来说，其参数不能直接含有#、#@、##，需要通过另一个宏函数间接实现。在编写宏函数时注意这一点可以避免很多意料之外的求值顺序问题。\n以上这样的宏定义求值简直太简单了。真正的大招在后面~\n对宏定义递归的探索在StackOverflow上，有人提出是否可以实现这样的递归宏定义：\n#define pr(n) ((n==1)? 1 : pr(n-1))\n\n我们可以根据之前学习的规则来尝试展开pr(5):\n/* pr(5) -&gt; ((5==1)? 1 : pr(5-1)) -&gt; ?此时这个结果将无法进一步展开，为什么呢?在一次宏函数求值过程中，无法访问宏定义本身。此时pr(5-1)将被宏处理器记住，它在后续永远也不会展开。 */\n\n为了避免这个问题，大佬们提出了一种延时求值的技巧。\n#define EMPTY(...)#define DEFER(...) __VA_ARGS__ EMPTY()#define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()#define EXPAND(...) __VA_ARGS__#define pr_id() pr#define pr(n) ((n==1)? 1 : DEFER(pr_id)()(n-1))\n\n可以尝试再一次展开pr(5):\n/* pr(5) -&gt; // 展开外层宏函数((5==1)? 1 : DEFER(pr_id)()(5 -1))     -&gt; // 展开外层函数时存在DEFER()需展开，注意pr_id后面没有括号，所以pr_id不展开((5==1)? 1 : pr_id()(5 -1))            // 这就是最终的结果，因为此时外层没有宏函数包裹，宏处理器不会进一步进行求值// 如果在外面包裹一个EXPAND，那就能进一步展开EXPAND(pr(5)) -&gt;...     // 省略一些过程EXPAND(((5==1)? 1 : pr_id()(5 -1))) -&gt; // 外层存在一个宏函数，内层需要求值。需要计算pr_id()EXPAND(((5==1)? 1 : pr(5 -1)))      -&gt; // 注意，此时内层已经展开完成了。开始展开外层宏函数((5==1)? 1 : pr(5 -1))  -&gt; 展开外层宏函数后，重新求值发现存在一个pr()需要进一步展开((5==1)? 1 : ((5 -1==1)? 1 : pr_id ()(5 -1 -1)))    // 这就是最终的结果 */\n\nEXPAND()的作用就是进行一次展开。显然上面的递归定义需要多次展开。所以可以将多个EXPAND叠加在一起组合为一个新的宏函数。\n#define EVAL(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))#define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))#define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))#define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))#define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))#define EVAL5(...) __VA_ARGS__\n调用EVAL()可以进行多少次求值呢？243次。\n这里通过一次DEFER操作实现了对pr的延时求值，使得在外部通过调用EXPAND来在外部展开，避免了无法直接递归的问题。但是很显然，在外部手动调用EXAND的次数也是有限的，不能无限递归。\n至此，到这里仅仅完成了递归嵌套的定义，对于递归来说，最重要的是递归中止条件，这才是用宏函数实现递归的一大难点。在进一步探索递归前，我们学习一下大佬们实现的用宏函数完成的循环语句。\n使用宏定义实现循环语句参考内容：Is the C99 preprocessor Turing complete?\n有大佬实现了一个循环语句，通过宏定义实现。这里把其中的关键代码整理如下：\n#define EMPTY(...)#define DEFER(...) __VA_ARGS__ EMPTY()#define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()#define EXPAND(...) __VA_ARGS__#define EVAL(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))#define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))#define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))#define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))#define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))#define EVAL5(...) __VA_ARGS__#define CAT(a, ...) PRIMITIVE_CAT(a, __VA_ARGS__)#define PRIMITIVE_CAT(a, ...) a ## __VA_ARGS__#define INC(x) PRIMITIVE_CAT(INC_, x)#define INC_0 1#define INC_1 2#define INC_2 3#define INC_3 4#define INC_4 5#define INC_5 6#define INC_6 7#define INC_7 8#define INC_8 9#define INC_9 9#define DEC(x) PRIMITIVE_CAT(DEC_, x)#define DEC_0 0#define DEC_1 0#define DEC_2 1#define DEC_3 2#define DEC_4 3#define DEC_5 4#define DEC_6 5#define DEC_7 6#define DEC_8 7#define DEC_9 8#define CHECK_N(x, n, ...) n#define CHECK(...) CHECK_N(__VA_ARGS__, 0,)#define NOT(x) CHECK(PRIMITIVE_CAT(NOT_, x))#define NOT_0 ~, 1,#define COMPL(b) PRIMITIVE_CAT(COMPL_, b)#define COMPL_0 1#define COMPL_1 0#define BOOL(x) COMPL(NOT(x))#define IIF(c) PRIMITIVE_CAT(IIF_, c)#define IIF_0(t, ...) __VA_ARGS__#define IIF_1(t, ...) t#define IF(c) IIF(BOOL(c))#define EAT(...)#define EXPAND(...) __VA_ARGS__#define WHEN(c) IF(c)(EXPAND, EAT)#define REPEAT(count, macro, ...) \\    WHEN(count) \\    ( \\        OBSTRUCT(REPEAT_INDIRECT) () \\        ( \\            DEC(count), macro, __VA_ARGS__ \\        ) \\        OBSTRUCT(macro) \\        ( \\            DEC(count), __VA_ARGS__ \\        ) \\    )#define REPEAT_INDIRECT() REPEAT\n\n来看看其强大之处：\n#define M(i, _) i,int nums[] = &#123;EVAL(REPEAT(8, M, ~))&#125;;// -&gt; int nums[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,&#125;;#define OPR(i, _) i _int sum = EVAL(REPEAT(9, OPR, +)) 0;// -&gt; int sum = 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 0;int product = EVAL(REPEAT(9, OPR, *)) 1;// -&gt; int product = 0 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 1;\n\n这个循环的内在逻辑这里就不多解释了，多看看就会了，有很多的技巧。\n当我掌握了这里面的一些技巧后，我开始设计一个求多个数求最大值的宏函数。这并不容易，需要使用递归实现并完成递归中止条件的处理。\n宏函数递归实现求最大值思路如下：\n\n1.采用延时求值表达式完成正常的递归表达；\n2.完成递归中止条件，通过判断参数个数来判断是否递归结束；\n3.递归内部分支流程，中止条件完成后需要进行分支流程，一种是继续递归，一种是当只有一个参数时直接返回。\n\n首先是递归表达式：\n#define MAX_NUM(a, ...) \\    ( \\        a &gt; DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) ? \\        a : DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) \\    )#define MAX_INDIRECT(...) MAX_NUM\n这里应用了延时求值的技巧。\n接下来是递归中止条件，需要判断参数个数是否为1，先实现一个判断宏参数是否存在的宏函数：\n#define GET_P64_I(\\    p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\\    p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,\\    p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,\\    p31, p32, p33, p34, p35, p36, p37, p38, p39, p40,\\    p41, p42, p43, p44, p45, p46, p47, p48, p49, p50,\\    p51, p52, p53, p54, p55, p56, p57, p58, p59, p60,\\    p61, p62, p63, p64, ... \\    ) p64// 避免内层参数未展开导致参数数量不匹配的问题#define GET_P64(...) GET_P64_I(__VA_ARGS__)#define ONE_X62 \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1// 避免直接使用带有##__VA_ARGS__的宏，影响求值顺序#define CHECK_ARGS_I(...) \\    GET_P64(~, ##__VA_ARGS__, \\        ONE_X62, 0)#define CHECK_ARGS(...) CHECK_ARGS_I(__VA_ARGS__)/* CHECK_ARGS(1) -&gt; 1CHECK_ARGS() -&gt; 0CHECK_ARGS(1,2) -&gt; 1CHECK_ARGS(1,2,3) -&gt; 1 */\nCHECK_ARGS()宏函数可以判断宏参数个数，如果有一个或多个参数则返回1，参数列表为空则返回0。\n接下来使用CHECK_ARGS()来实现一个判断参数是否只有一个的宏(处理递归结束)：\n#define EAT_FIRST(x, ...) __VA_ARGS__#define CHECK_ARGS1(...) CHECK_ARGS(EAT_FIRST(__VA_ARGS__))/* CHECK_ARGS1(1) -&gt; 0CHECK_ARGS1(1, 2) -&gt; 1CHECK_ARGS1() -&gt; Error, 无法求值 */\n\n接下来通过CHECK_ARGS1()配合CAT()宏，拼接出MAX_1和MAX_0两个分支：\n#define MAX_NUM(a, ...) \\    ( \\        a &gt; DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) ? \\        a : DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) \\    )#define MAX_INDIRECT(...) MAX_BRANCH(CHECK_ARGS1(__VA_ARGS__))#define MAX_BRANCH(n) PRIMITIVE_CAT(MAX_, n)#define FIRST(a, ...) a#define MAX_1 MAX_NUM#define MAX_0 FIRST\n\n至此MAX_NUM()就能够完成主要的功能，由于延迟求值的原因，需要在外层再套一个EVAL()。每多一个参数就多一层递归，也就多一次延迟求值。前面写的EVAL()可以处理243次延迟求值。\n#define MAX(...) EVAL(MAX_NUM(__VA_ARGS__))/* MAX(1, 2) -&gt;    ( 1 &gt; 2 ? 1 : 2 )MAX(1, 2, 3) -&gt;    ( 1 &gt; ( 2 &gt; 3 ? 2 : 3 ) ? 1 : ( 2 &gt; 3 ? 2 : 3 ) )MAX(1, 2, 3, 4) -&gt;    ( 1 &gt; ( 2 &gt; ( 3 &gt; 4 ? 3 : 4 ) ? 2 : ( 3 &gt; 4 ? 3 : 4 ) ) ? 1 :         ( 2 &gt; ( 3 &gt; 4 ? 3 : 4 ) ? 2 : ( 3 &gt; 4 ? 3 : 4 ) ) )MAX(a, b, c, d, e, f) -&gt;    ( a &gt; ( b &gt; ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e :     f ) ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) )     ) ? b : ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f )     ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) ) ) )     ? a : ( b &gt; ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e :     f ) ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) )     ) ? b : ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f )     ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) ) ) ) )int max3(v1, v3, v3)&#123;    return MAX(v1, v2, v3);&#125; -&gt;    int max3(v1, v3, v3)&#123;        return ( v1 &gt; ( v2 &gt; v3 ? v2 : v3 ) ? v1 : ( v2 &gt; v3 ? v2 : v3 ) );    &#125;----Error:MAX() -&gt; ( &gt; ? : )MAX(1) -&gt; ( 1 &gt; ? 1 : ) */\n\n可以看出，递归展开后呈二次增长。无论生成的表达式多复杂，结果都是正确的。受限于CHECK_ARGS()，这只能处理不超过63个数的最大值计算。\n这里还存在一点点瑕疵，前面是先递归再分支判断，所以传入一个或零个参数时的结果不正确。可以先直接调用MAX_INDIRECT()做一次分支判断，当只有一个参数时就直接返回。\n#define MAX(...) EVAL(MAX_INDIRECT(__VA_ARGS__)(__VA_ARGS__))/* MAX(1) -&gt; 1MAX(1, 2) -&gt; ( 1 &gt; 2 ? 1 : 2 )----MAX() -&gt; 返回为空MAX_INDIRECT为什么有两个参数列表？    第一个参数列表用于去判断参数数量做分支处理，第二个参数列表是实际待处理数据。 */\n\n数值系统MAX()真正意义上来说没有得到一个数列的最大值，原因是C语言的宏定义没有数值计算系统。所以这里返回了一个表示最大值表达式。\n进一步思考一下，宏定义能不能实现数值计算？\n#define ADD(a, b) (a+b)\n\n这并不是我想要的，这仅仅返回了一个表达式。我需要的是能够直接返回计算结果。\n/* ADD(1, 2) -&gt; (1+2) // ErrorADD(1, 2) -&gt; 3     // It&#x27;s OK. How to implement it? */\n\n注意前文的两个宏函数INC()、DEC()，它们能够实现一个数的加1或减1：\n/* INC(5) -&gt; 6INC(0) -&gt; 1DEC(1) -&gt; 0DEC(9) -&gt; 8INC(DEC(1)) -&gt; 1 */\n\n那么ADD(a, b)函数可以表达为需要调用a次的INC(b)。或者说a+b&#x3D;(a-1)+(b+1)，ADD(a, b)&#x3D;ADD(DEC(a), INC(b))。这看起来又是一种递归的形式了，当a等于0时结束递归。这是一种尾递归的形式，可以使用表达为循环。来看看C语言的形式：\nint add(int a, int b)&#123;    if(a)&#123;        return add(a - 1, b + 1);    &#125;else&#123;        return b;    &#125;&#125;\n这样的形式就很容易使用宏定义表达：\n#define ADD_INDIRECT() ADD#define ADD(a, b) \\    WHEN(a) (OBSTRUCT(ADD_INDIRECT)() (DEC(a), INC(b))) \\    WHEN(NOT(a)) (b)/* 这里使用OBSTRUCT()来进行延时求值，所以最终的表达式需要使用EVAL()进行展开求值。EVAL(ADD(1,2)) -&gt; 3EVAL(ADD(2,2)) -&gt; 4EVAL(ADD(5,0)) -&gt; 5EVAL(ADD(0,5)) -&gt; 5EVAL(ADD(0,0)) -&gt; 0EVAL(ADD(2,EVAL(ADD(2,2)))) -&gt; 6 */\n\n思考一下，能不能实现一个数值版本的MAX()宏函数？它能真正计算出数列的最大值。\n/* MAX(1, 2)    -&gt; 2MAX(3, 2, 1) -&gt; 3 */\n\n这似乎是一个新的挑战，需要完成宏定义中没有的数值比较功能。后面有时间再研究。😅\n总结仅用#define功能就完成了条件语句、循环、递归的实现。这是不是意味着C语言的宏是图灵完备的呢？\n我查阅了很多网友的讨论，大部分人的看法是有限个数的宏标识符无法完成尽可能大的递归深度。通过C语言宏实现的counter机制要求每个值都需要一个宏标识符，这就限制了宏的复杂性。因为C语言的规范中限定了单次宏处理标识符的最大数量。这和其它图灵机的无限内存是有本质区别的。\n此外，前面所实现的循环和递归都是有限深度的。无法实现无限循环和无穷递归就不具备完整的图灵完备性。但它确实完成了迭代、条件等类似的结构，这是不是意味着它是存在有限的图灵完备性。\n本文仅讨论C语言宏的一些内在性质，并不推荐在实际的开发中使用如此复杂的代码。\n参考1.theory - 什么是图灵完备？2.C&#x2F;C++ 宏的图灵完备性3.Is the C99 preprocessor Turing complete?4.Dave Prosser’s C Preprocessing Algorithm5.Best abuse of the C preprocessor\n"}]
[{"title":"ARM嵌入式开发中的栈回溯机制","url":"/2022/11/12/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%A0%88%E5%9B%9E%E6%BA%AF%E6%9C%BA%E5%88%B6/","content":"两种ABI规范根据编译器的实现不同，存在两种ABI机制，分别为APCS(ARM Procedure Call Standard)和AAPCS(ARM Archtecture Procedure Call Standard)。两种机制存在明显的区别，且单独APCS和AAPCS又有很多变种，这里就不详细展开叙述其本质。本文主要讨论分析栈帧相关的内容，所以这里仅仅介绍这两种ABI机制下栈帧的区别。\nAPCS规范下函数调用和栈帧相关寄存器APCS中规定了几个别名寄存器，分别是fp、ip、sp、lr、pc寄存器，它们实际对应的寄存器及含有有下表：\n\n\n\nAPCS\nReg\n意义\n\n\n\nfp\nr11\n栈帧指针寄存器\n\n\nip\nr12\n临时变量寄存器\n\n\nsp\nr13\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧函数调用入口处将pc、lr、sp、fp寄存器依次入栈。入栈前先将sp保存到ip，入栈后再将ip的值给fp，这样fp的值就是当前栈帧的起始位置。后续如果需要使用局部变量，就将sp减一个值实现在栈空间上开辟局部变量的空间。函数退出前将sp寄存器处理到堆栈平衡状态，再通过fp寄存器找到当前函数的栈帧位置，通过栈帧找到返回函数的fp寄存器和sp寄存器、lr寄存器。简要的代码如下：\n&lt;func1&gt;:mov ip, sppush &#123;fp, ip, lr, pc&#125;sub fp, ip, #4sub sp, sp, #8      ;8 字节局部变量空间;...sub sp, fp, #12ldm sp, &#123;fp, sp, pc&#125;\n\n通过分析栈帧格式我们能够知道在函数任意位置，都能够通过fp寄存器找到当前栈帧位置，而不必考虑当前使用了多少局部变量空间，栈帧中能够得到当前函数的返回地址(lr)，当前运行地址(pc)，栈地址(sp)，同时根据栈帧中上一个函数的fp寄存器再找到上一层函数的栈帧数据，这样层层回溯就实现了栈的回溯。\n如何使用APCSgcc手册上对使用APCS有相关的描述和控制选项，-mapcs-frame选项编译出来的代码就是使用APCS规范，默认情况是-mno-apcs-frame，关于这个选项的描述GCC手册原文是：\nGenerate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying -fomit-frame-pointer with this option causes the stack frames not to be generated for leaf functions. The default is -mno-apcs-frame. This option is deprecated.\n\n这里说明了使用相关选项可以保证APCS的栈帧格式，如果不适用这个选项则不保证。APCS为1993年推出的标准，在后续推出AAPCS相关版本后它已经显得太旧了。在gcc5.0之后，该选项已经被遗弃，所以新版本的编译器已经不能使用APCS调用方式进行栈回溯。\nAAPCS下函数的调用相关寄存器AAPCS相比于APCS少了几个别名寄存器。它有sp、lr、pc寄存器，对应表如下：\n\n\n\nAPCS\nReg\n意义\n\n\n\nsp\nr13(ARM)&#x2F;r7(THUMB)\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧在这种调用规范下，栈的回溯要比APCS下要复杂的多，函数的调用过程中不保存栈帧的指针，而且栈帧中也没有固定的格式，所以不能通过当前的栈帧层层返回数据。所以仅仅通过堆栈数据是不能进行栈回溯的。那么这种模式下如何保证堆栈平衡，能不能通过汇编代码的堆栈平衡实现栈回溯呢？\n我们知道APCS模式下函数进入到退出时的堆栈平衡时通过保存sp寄存器和恢复sp寄存器实现的。而AAPCS模式下堆栈平衡是直接依靠pop和push平衡实现的，即不会直接修改sp来实现堆栈平衡。但如果我们能够准确知道每个函数关于栈的操作，这样也能够实现栈的跟踪。\n通过适当的编译选项，我们能够将这部信息收集到一起，这就是arm exception handler index，简称ARM.exidx，这段数据就能指导我们实现栈回溯，把这种栈回溯方式称为unwind。\nARM.exidx位置和结构不同的编译器如何编译出exidx表具有不同的方式，但是如果可执行文件中包括exidx表，那么使用readelf -S file.elf 能够看到可执行文件中存在一个名为.ARM.exidx，类型为ARM_EXIDX的段。这就表示编译器已经生产的exidx段。\n关于exidx的结构及其含义这里做一个简单介绍，详细信息可以参考ARM官方网站。exidx是一个由多个相同单元组成的表，每个单元由两个uint32_t的数据构成，结构类似于：\nstruct &#123;    uint32_t offset;    uint32_t world;&#125;\n其中offset表示目标函数到当前位置的偏移，它的最高位固定为0。而world中存放了编码数据，它表示了对栈的不同操作，通过操作它就能够知道目标函数上关于栈的操作。\nLinux中的栈回溯Linux中关于ARM架构的栈回溯就是使用的exidx表实现的，这里以linux5.3版本内核中关于unwind frame的代码进行演示。涉及的主要代码文件有arch&#x2F;arm&#x2F;kernel&#x2F;unwind.c arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;unwind.h arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;ptrace.h stacktrace.h等。主要将unwind.c移植到我们的嵌入式平台就能够使用unwind栈回溯了。\n代码移植由于linux中存在内核空间和用户空间，两种空间下存在各种的exidx表，而通常我们的代码没有所谓的两个地址空间。所以需要将涉及到地址空间判断的全部判断为是否为代码空间段，linux对于用户空间段的exidx表是通过链表由用户手动添加的，内核段的exidx表是直接由编译符号完成的。其他的代码修改主要是涉及到Linux平台特性的。下面介绍的相关修改都是基于gcc编译器(ver&gt;5.0)实现的。\n\n1.实现两个关键的函数： #define core_kernel_text(addr)    ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)#define kernel_text_address(addr) ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)\n2.添加日志输出的相关接口，主要就是两个，其中pr_debug日志可以选择不输出。 #define pr_debug(...) printf(__VA_ARGS__)#define pr_warn(...)  printf(__VA_ARGS__)\n3.关于分支预测的代码，可能在某些arm平台下不支持分支预测，所以这里的移植就把这个特性关闭掉。 #define likely(c)   (c)#define unlikely(c) (c)\n4.字节对齐函数，用于把某个数据按多少字节对齐。 #define ALIGN(x,a) (((x)+(a)-1)&amp;~(a-1))\n5.内存操作的相关接口，这里其实并不会使用到内存相关申请，它只是在添加用户空间exidx表时才使用，而我们的嵌入式平台上是显然是用不到的。 #define kmalloc(size, flag)  malloc(size)#define kfree(ptr)           free(ptr)\n6.exidx表的位置，不同的编译器在链接脚本中关于exidx表的起始终止位置的描述可能不一样，这里需要重新定义一下。 #define __start_unwind_idx __exidx_start#define __stop_unwind_idx  __exidx_end\n7.实现获取关键寄存器的操作，主要是获取sp寄存器，如果不是在gcc编译器中，还需要实现获取lr寄存器和sp寄存器 register char * stack_ptr asm(&quot;sp&quot;);#define current_stack_pointer ((unsigned long) stack_ptr)\n8.linux中针对部分代码使用了spinlock进行保护，在我们的嵌入式平台上通常是不需要的，当然如果有必要可以进行选择性的实现类似spinlock的操作。\n9.关于代码是arm模式还是thumb模式，如果代码是thumb模式，还需要定义一个宏，他将决定fp寄存器是r7还是r11 #define CONFIG_THUMB2_KERNEL\n10.对于.h文件，主要是是保留unwind.h文件，删除其中不相干的代码，其他头文件中可能只是会引用部分数据和数据结构可以直接拷贝到unwind.h文件中。\n11.可以选择是否保留关于添加unwind_table的相关函数，这些函数通常不会使用。\n\n除了上述代码的移植外，编译时需要开启-funwind-tables选项，使编译器能够正常生产exidx段。在连接时要保证链接脚本中有存放exidx段的位置，以及预留出索引exidx段的起止符号，类似这样的链接脚本：\n.ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH.ARM : &#123;  __exidx_start = .;  *(.ARM.exidx*)  __exidx_end = .;&#125; &gt;FLASH\n\n将代码移植到ARMCC编译器中keil作为一个应用在嵌入式开发领域的一个重要软件，如果能够将这个功能应用到ARMCC编译器环境下，那这个功能将显得更加具有现实意义。前面的移植主要是在gcc编译平台下完成的，下面介绍如何将这段代码和功能移植到ARMCC编译平台下。\n\n1.编译环境相关的设置 要使编译器能够正常编译出代码exidx数据段的代码需要开启特别的选项 –exceptions –exceptions-unwind，它的意义是开启异常处理机制，因为最初exidx段设计来就是用于处理类型c++中的异常机制的。在开启了这些选项后编译出的代码就会包含exidx段，可以使用指令进行检验查看，如readelf -S main.o，其中就能够看到相关的数据段。当然不同的文件中的exidx段还没有链接到一起，要把它们链接到一起还比较麻烦。 因为ARMCC的优化策略，未使用的数据段都会在链接阶段被优化掉，而我们由不能直接使用到exidx中的数据(没有相关的符号指向这里)，所以正常情况下，即使开启的前面的编译选项，最终编译出来的文件也没有任何区别。在链接阶段添加选项–keep *(.ARM.exidx)，这个选项的意思就是在链接时保留exidx段(注意.ARM.exidx是exidx段的标准名称，前面没有提到，不同的编译器编译出来都是这个段名，且段类型都是未ARM_EXIDX)，这样链接出来的文件可以发现会比未加这个选项的文件大了些，这就新增的exidx段数据导致的。 但是这时候还是存在一个问题，编译出的文件包含了exidx段的数据，但是却没在我们想要的地方，或者说没没办法确定这段数据在哪儿。readelf -S能够看到段的结构没有增加，而ER_IROM1段的数据变多了，这就说明exidx段的数据与代码数据放入了同一个段，这显然不是我们想要的。 修改分散加载文件，在链接选项中指定使用自定义分散加载文件。我们起始可以看到原sct文件的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n\n 我们在这里添加exidx段的声明后的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    ER_EXIDX +0 0x00020000 &#123;        .ANY (.ARM.exidx)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n\n 经过对编译器链接器的设置，我们终于将exidx段的数据放到了期望的地方，在编译器中使用符号Image$$ER_EXIDX$$Base和Image$$ER_EXIDX$$Limit就能访问到exidx段的数据(编译器特性)。\n2.处理完成了编译器的相关内容，还需要修改源代码以适应ARMCC编译器，需要修改的地方主要体现在使用到了gcc内建函数的地方，以及gcc支持的一些拓展语法上，具体如何修改这里不做详细的介绍了。以上包括gcc和keil平台下的移植都经过测试，能够非常准确的回溯函数的调用链，包括在使用函数指针的地方都能进行准确的回溯，对于分析软件bug具有一定的帮助。\n\n技术参考本文中所设计到的内容主要来自于ARM官方的技术文档库，GCC编译手册，Linux内核源码等。可自行检索参考。\n"},{"title":"C语言宏的图灵完备","url":"/2024/09/19/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E7%9A%84%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/","content":"\n这里讨论的C语言宏系统仅关于#define，不包含#include, #if，#ifdef，#elif，#else，#endif等。\n\nC语言宏的可选参数前段时间在某个嵌入式软件项目中涉及一个这样的功能，需要将一个wav音频文件嵌入式到二进制固件中，这样可以方便获取音频文件数据且不需要文件系统等复杂的组件。以前的做法是将音频文件写入到Flash中固定的地址下，然后在软件代码中从该地址访问相关的数据。但是这样的做法存在一定的灵活性问题，比如文件是否可能和固件重叠、无法统一烧录等问题。\n后面我想到可以使用gcc汇编中的一条命令来实现在代码中包含一个文件，那就是.incbin指令。该指令在手册的描述如下：\n.incbin &quot;file&quot;[,skip[,count]]The incbin directive includes file verbatim at the current location. You can control the search paths used with the ‘-I’ command-line option (see Command-Line Options). Quotation marks are required around file.The skip argument skips a number of bytes from the start of the file. The count argument indicates the maximum number of bytes to read. Note that the data is not aligned in any way, so it is the user’s responsibility to make sure that proper alignment is provided both before and after the incbin directive.\n\n将这个命令简单的使用宏封装一下，就可以在C代码文件中非常轻松的嵌入一个音频文件了。\n#define INCFILE(name, file)                             \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;\\n&quot;                        \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;);                                   \\    extern int __##name##_start;                        \\    extern int __##name##_end;#define FILEPTR(name) ((void*)&amp;(__##name##_start))#define FILESIZE(name) ((char*)&amp;(__##name##_end) - (char*)&amp;(__##name##_start))\n\n封装之后，就可以在C代码中直接使用如下方式来嵌入音频文件：\nINCFILE(audio, &quot;audio.wav&quot;);int main()&#123;    printf(&quot;audio size: %d\\n&quot;, FILESIZE(audio));    printf(&quot;audio ptr: %p\\n&quot;, FILEPTR(audio));    return 0;&#125;\n\n在后来的使用过程中发现wav音频文件前的44字节是音频文件头，可以忽略，只需要使用后面的PCM数据即可。这样需要使用incbin指令的skip选项，但是上面涉及的INCFILE()宏没有提供这个功能，所以需要重新写一个宏。\n#define INCFILE_PART(name, file, offset, count)         \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset)        \\        &quot;,&quot; INCF_STR(count) &quot;\\n&quot;                        \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;);                                   \\    extern int __##name##_start;                        \\    extern int __##name##_end;\n\n这样的写法似乎也不太符合要求，因为这里不需要count参数，而是需要包含文件的全部内容，所以需要再封装一个宏？\n类似的操作为什么需要写多个宏？这样的操作似乎就太不优雅了。\n能不能实现一个这样的宏，能够提供多个可选参数呢？根据参数个数生成不同的代码。\nINCFILE(audio, &quot;audio.wav&quot;)INCFILE(audio, &quot;audio.wav&quot;, 44)INCFILE(audio, &quot;audio.wav&quot;, 44 1024)\n\n这样就引入了一个非常关键的问题，C语言的宏定义如何根据参数个数来动态生成代码呢？\n#define INCFILE(...) \\    if (NUM(__VA_ARGS__) == 2) &#123; INCFILE(__VA_ARGS__)&#125; else &#123; INCFILE_PART(__VA_ARGS__) &#125;\n\n可以很明确的说，上面的代码是错误的，C语言的宏定义无法执行条件判断，所以无法实现这个功能。\n宏定义如何实现条件分支流程呢？我们从一个简单的需求开始，请设计一个宏，判断宏参数列表中的参数个数是0个还是1个。\n#define PARA_FOLLOW(...) 0, ##__VA_ARGS__, 1, 0\n\n我们来看看这段宏填入一些参数后展开的情况：\n/* PARA_FOLLOW(a) -&gt;    0, a, 1, 0PARA_FOLLOW() -&gt;    0, 1, 0 */\n\n注意力惊人的人已经注意到展开后的结果中第三个数据就是该宏输入的参数个数。这似乎就解决了参数条件判断的问题，那如何进行分支流程呢？\n将PARA_FOLLOW()宏中跟随的0和1替换为分支语句，这样就完成了完整的条件分支。\n#define GET_P4(p1, p2, p3, p4, ...) p4#define SELECT_012_PARA(p0, p1, p2, ...) GET_P4(0, ##__VA_ARGS__, p2, p1, p0)/* SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);) -&gt;    printf(&quot;hello world\\n&quot;);SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);, 1) -&gt;    printf(&quot;hello macro\\n&quot;);SELECT_012_PARA( \\    printf(&quot;hello world\\n&quot;);, \\    printf(&quot;hello macro\\n&quot;);, \\    printf(&quot;hello hexo\\n&quot;);, a, b) -&gt;    printf(&quot;hello hexo\\n&quot;); */\n\nSELECT_012_PARA()宏可以根据可以参数列表中参数的数量来生成不同的代码，而不关心参数具体的值。\n据此，我重新设计了INCFILE()宏：\n#define INCFILE_OFFSET(file, offset)                    \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset) &quot;\\n&quot;        #define INCFILE_COUNT(file, offset, count, ...)         \\        &quot;.incbin \\&quot;&quot; file &quot;\\&quot;,&quot; INCF_STR(offset)        \\        &quot;,&quot; INCF_STR(count) &quot;\\n&quot;#define INCFILE_PARA(name, file, offset, ...)           \\    __asm(                                              \\        &quot;.global __&quot; INCF_STR(name) &quot;_start\\n&quot;          \\        &quot;.type __&quot; INCF_STR(name) &quot;_start, %object\\n&quot;   \\        &quot;.global __&quot; INCF_STR(name) &quot;_end\\n&quot;            \\        &quot;.type __&quot; INCF_STR(name) &quot;_end, %object\\n&quot;     \\        &quot;__&quot; INCF_STR(name) &quot;_start:\\n&quot;                 \\        SELECT_012_PARA(                                \\            INCFILE_OFFSET(file, 0),                    \\            INCFILE_OFFSET(file, offset),               \\            INCFILE_COUNT (file, offset, ##__VA_ARGS__, 0), \\            ##__VA_ARGS__)                              \\        &quot;__&quot; INCF_STR(name) &quot;_end:\\n&quot;                   \\        &quot;.word 0\\n&quot;                                     \\    )#define INCFILE(name, file, ...)                        \\    INCFILE_PARA(name, file, ##__VA_ARGS__, 0);         \\    extern int __##name##_start;                        \\    extern int __##name##_end;\n\nINCFILE()可以使用不同的参数数量，来选择是否需要跳过头部数据。\n// hello.txt content is 12345678hellohello12345INCFILE(file1, &quot;hello.txt&quot;)INCFILE(file2, &quot;hello.txt&quot;, 8)INCFILE(file3, &quot;hello.txt&quot;, 8, 10)int main(void)&#123;     assert(memcmp(FILEPTR(file1), &quot;12345678hellohello12345&quot;,          FILESIZE(file1)) == 0);     assert(memcmp(FILEPTR(file2), &quot;hellohello12345&quot;, FILESIZE(file2)) == 0);     assert(memcmp(FILEPTR(file3), &quot;hellohello&quot;, FILESIZE(file3)) == 0);     return 0;&#125;\n一个宏函数实现了多种功能，看起来有点多态的性质。\n至此，一个在嵌入式软件开发过程中一个不起眼的问题就被成功解决了。\n宏定义是否可以实现递归？完成条件分支功能后，我进行了进一步的思考，在宏定义中能否实现递归呢？\n请设计一个宏，该宏可以传入任意个整数，返回一个表达式，表示其最大值。\nC语言的初学者可能都写过这样的宏：\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))/* MAX(1, 2) -&gt;    ((1) &gt; (2) ? (1) : (2)) */\n这只能接受2个参数，如果传入3个参数，就会报错。任意个参数的递归版本也许是这样的：\n#define MAX(a, ...) (a &gt; MAX(__VA_ARGS__) ? a : MAX(__VA_ARGS__))\n\n实际展开情况呢？\n/* MAX(1, 2, 3) -&gt;    (1 &gt; MAX(2, 3) ? 1 : MAX(2, 3)) */\n\n宏定义看起来无法正常的递归展开。这时候去检索相关的资料发现，C语言的宏定义确实无法直接实现递归。\n但是在查询资料的时候，我发现通过一种通过延迟求值的技巧，可以做到有限的递归。\n说到延迟求值，那就有必要先回顾一下C语言宏定义的求值规则。\n宏定义的求值规则先展开内层实参，再展开外层宏函数。如果形参前有#、#@或者形参前后有##，则对应实参不展开。\n宏函数求值规则特别复杂，简单来说，先计算实参的值，替换到宏函数中，然后重新进行计算。\n每当宏展开为非宏的标识符后，将触发重新扫描，从开始处重新计算。当对宏函数A()求值时遇到A，会将其标记为非宏标识符以避免递归，即使从外层重新对其进行扫描也无法对其继续展开。\n一个例子进行求值说明：\n#define A(p1, p2, p3, p4, p5) p5#define B() 1, 2, 3#define C(a) A(a, 0, B())#define A_I(...) A(__VA_ARGS__)#define C_I(a) A_I(a, 0, B())C(1) -&gt;      // 先计算内层参数值，1无需计算C(1) -&gt;      // 展开外层宏函数A(1, 0, B()) // Error, 展开后只有三个参数，无法匹配宏定义，直接报错C_I(1) -&gt;    // 先计算内层参数值，1无需计算C_I(1) -&gt;    // 展开外层宏函数A_I(1, 0, B()) -&gt;   // A_I为不定参数个数的宏，可以展开，先计算内层参数值，需要计算B()A_I(1, 0, 1, 2, 3) -&gt;  // 展开外层宏函数A(1, 0, 1, 2, 3)   -&gt;  // 计算内层参数值，所有参数都无需计算，直接展开外层宏函数3// 看一个特别的例子#define A_I2(...) A(##__VA_ARGS__)#define C_I2(a) A_I2(a, 0, B())C_I2(1) -&gt;   // 先计算内层参数值，1无需计算C_I2(1) -&gt;   // 展开外层宏函数A_I2(1, 0, B()) -&gt;  // 此时本应该先展开内层参数，也就是B()，但A_I2参数中的##阻止                    // 了1, 0, B()这个整体被求值。所以继续展开外层宏函数A(1, 0, B()) // Error, 参数数量不匹配，报错// 可以仔细对比C_I()和C_I2()的差异，唯一的区别就是__VA_ARGS__多了一个##// 正常情况下__VA_ARGS__前的##表示忽略可选参数带来的额外空格。// 在大多数情况下影响不大，但在遇到宏嵌套复合求值时会导致宏展开顺序不一致的问题。\n\n再看一个许多网友都没有正确理解的例子：\n#define  cat(a,b)     a ## b#define  xcat(x, y)   cat(x, y)xcat ( xcat ( 1 , 2 ) , 3 ) -&gt; xcat ( cat ( 1 , 2 ) , 3 ) -&gt;xcat ( 12 , 3 ) -&gt;cat ( 12 , 3 ) -&gt;123// 有部分文章在使用这个例子介绍宏嵌套求值顺序时写错了。大家不要被错误的信息误导。// 如果你对此表示怀疑，那么你可以使用ppstep工具去查看宏展开过程中的细节。\n\n在编写宏函数时需要掌握一个技巧，在涉及到宏嵌套和需要在代码中直接访问的宏函数来说，其参数不能直接含有#、#@、##，需要通过另一个宏函数间接访问。在编写宏函数时注意这一点可以避免很多意料之外的求值顺序问题。\n#define _STR2(x) #x#define _STR(x) _STR2(x)/* #define A 123_STR2(A) -&gt; A    // Error, 不符合预期_STR(A) -&gt; &quot;123&quot; // OK */\n\n以上这样的宏定义求值都太简单了。真正的大招在后面~\n对宏定义递归的探索在StackOverflow上，有人提出是否可以实现这样的递归宏定义：\n#define pr(n) ((n==1)? 1 : pr(n-1))\n\n我们可以根据之前学习的规则来尝试展开pr(5):\n/* pr(5) -&gt; ((5==1)? 1 : pr(5-1)) -&gt; ?此时这个结果将无法进一步展开，为什么呢?在一次宏函数求值过程中，无法访问宏定义本身。此时pr(5-1)将被宏处理器记住，它在后续永远也不会展开。 */\n\n为了避免这个问题，大佬们提出了一种延时求值的技巧。\n#define EMPTY(...)#define DEFER(...) __VA_ARGS__ EMPTY()#define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()#define EXPAND(...) __VA_ARGS__#define pr_id() pr#define pr(n) ((n==1)? 1 : DEFER(pr_id)()(n-1))\n\n可以尝试再一次展开pr(5):\n/* pr(5) -&gt; // 展开外层宏函数((5==1)? 1 : DEFER(pr_id)()(5 -1))     -&gt; // 展开外层函数时存在DEFER()需展开，注意pr_id后面没有括号，所以pr_id不展开((5==1)? 1 : pr_id()(5 -1))            // 这就是最终的结果，因为此时外层没有宏函数包裹，宏处理器不会进一步进行求值// 如果在外面包裹一个EXPAND，那就能进一步展开EXPAND(pr(5)) -&gt;...     // 省略一些过程EXPAND(((5==1)? 1 : pr_id()(5 -1))) -&gt; // 外层存在一个宏函数，内层需要求值。需要计算pr_id()EXPAND(((5==1)? 1 : pr(5 -1)))      -&gt; // 注意，此时内层已经展开完成了。开始展开外层宏函数((5==1)? 1 : pr(5 -1))  -&gt; 展开外层宏函数后，重新求值发现存在一个pr()需要进一步展开((5==1)? 1 : ((5 -1==1)? 1 : pr_id ()(5 -1 -1)))    // 这就是最终的结果 */\n\nEXPAND()的作用就是进行一次展开。显然上面的递归定义需要多次展开。所以可以将多个EXPAND叠加在一起组合为一个新的宏函数。\n#define EVAL(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))#define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))#define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))#define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))#define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))#define EVAL5(...) __VA_ARGS__\n调用EVAL()可以进行多少次求值呢？243次。\n这里通过一次DEFER操作实现了对pr的延时求值，使得在外部通过调用EXPAND来在外部展开，避免了无法直接递归的问题。但是很显然，在外部手动调用EXPAND的次数是有限的，不能无限递归。\n至此，到这里仅仅完成了递归嵌套的定义，对于递归来说，最重要的是递归中止条件，这才是用宏函数实现递归的一大难点。在进一步探索递归前，我们学习一下大佬们实现的用宏函数完成的循环语句。\n使用宏定义实现循环语句参考内容：Is the C99 preprocessor Turing complete?\n有大佬实现了一个循环语句，通过宏定义实现。这里把其中的关键代码整理如下：\n#define EMPTY(...)#define DEFER(...) __VA_ARGS__ EMPTY()#define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()#define EXPAND(...) __VA_ARGS__#define EVAL(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))#define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))#define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))#define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))#define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))#define EVAL5(...) __VA_ARGS__#define CAT(a, ...) PRIMITIVE_CAT(a, __VA_ARGS__)#define PRIMITIVE_CAT(a, ...) a ## __VA_ARGS__#define INC(x) PRIMITIVE_CAT(INC_, x)#define INC_0 1#define INC_1 2#define INC_2 3#define INC_3 4#define INC_4 5#define INC_5 6#define INC_6 7#define INC_7 8#define INC_8 9#define INC_9 9#define DEC(x) PRIMITIVE_CAT(DEC_, x)#define DEC_0 0#define DEC_1 0#define DEC_2 1#define DEC_3 2#define DEC_4 3#define DEC_5 4#define DEC_6 5#define DEC_7 6#define DEC_8 7#define DEC_9 8#define CHECK_N(x, n, ...) n#define CHECK(...) CHECK_N(__VA_ARGS__, 0,)#define NOT(x) CHECK(PRIMITIVE_CAT(NOT_, x))#define NOT_0 ~, 1,#define COMPL(b) PRIMITIVE_CAT(COMPL_, b)#define COMPL_0 1#define COMPL_1 0#define BOOL(x) COMPL(NOT(x))#define IIF(c) PRIMITIVE_CAT(IIF_, c)#define IIF_0(t, ...) __VA_ARGS__#define IIF_1(t, ...) t#define IF(c) IIF(BOOL(c))#define EAT(...)#define EXPAND(...) __VA_ARGS__#define WHEN(c) IF(c)(EXPAND, EAT)#define REPEAT(count, macro, ...) \\    WHEN(count) \\    ( \\        OBSTRUCT(REPEAT_INDIRECT) () \\        ( \\            DEC(count), macro, __VA_ARGS__ \\        ) \\        OBSTRUCT(macro) \\        ( \\            DEC(count), __VA_ARGS__ \\        ) \\    )#define REPEAT_INDIRECT() REPEAT\n\n来看看其强大之处：\n#define M(i, _) i,int nums[] = &#123;EVAL(REPEAT(8, M, ~))&#125;;// -&gt; int nums[] = &#123;0, 1, 2, 3, 4, 5, 6, 7,&#125;;#define OPR(i, _) i _int sum = EVAL(REPEAT(9, OPR, +)) 0;// -&gt; int sum = 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 0;int product = EVAL(REPEAT(9, OPR, *)) 1;// -&gt; int product = 0 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 1;\n\n这个循环的内在逻辑这里就不多解释了，多看看就会了，有很多的技巧。\n当我掌握了这里面的一些技巧后，我开始设计一个求多个数最大值的宏函数。这并不容易，需要使用递归实现并完成递归中止条件的处理。\n宏函数递归实现求最大值思路如下：\n\n1.采用延时求值表达式完成正常的递归表达；\n2.完成递归中止条件，通过计算参数个数来判断递归是否结束；\n3.处理递归内部分支流程，中止条件完成后需要进行分支流程，一种是继续递归，一种是当只有一个参数时直接返回。\n\n首先是递归表达式：\n#define MAX_NUM(a, ...) \\    ( \\        a &gt; DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) ? \\        a : DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) \\    )#define MAX_INDIRECT(...) MAX_NUM\n这里应用了延时求值的技巧。\n接下来是递归中止条件，需要判断参数个数是否为1，先实现一个判断宏参数是否存在的宏函数：\n#define GET_P64_I(\\    p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,\\    p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,\\    p21, p22, p23, p24, p25, p26, p27, p28, p29, p30,\\    p31, p32, p33, p34, p35, p36, p37, p38, p39, p40,\\    p41, p42, p43, p44, p45, p46, p47, p48, p49, p50,\\    p51, p52, p53, p54, p55, p56, p57, p58, p59, p60,\\    p61, p62, p63, p64, ... \\    ) p64// 避免内层参数未展开导致参数数量不匹配的问题#define GET_P64(...) GET_P64_I(__VA_ARGS__)#define ONE_X62 \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\    1, 1// 避免直接使用带有##__VA_ARGS__的宏，影响求值顺序#define CHECK_ARGS_I(...) \\    GET_P64(~, ##__VA_ARGS__, \\        ONE_X62, 0)#define CHECK_ARGS(...) CHECK_ARGS_I(__VA_ARGS__)/* CHECK_ARGS(1) -&gt; 1CHECK_ARGS() -&gt; 0CHECK_ARGS(1,2) -&gt; 1CHECK_ARGS(1,2,3) -&gt; 1 */\nCHECK_ARGS()宏函数可以判断宏参数个数，如果有一个或多个参数则返回1，参数列表为空则返回0。\n接下来使用CHECK_ARGS()来实现一个判断参数是否只有一个的宏(处理递归结束)：\n#define EAT_FIRST(x, ...) __VA_ARGS__#define CHECK_ARGS1(...) CHECK_ARGS(EAT_FIRST(__VA_ARGS__))/* CHECK_ARGS1(1) -&gt; 0CHECK_ARGS1(1, 2) -&gt; 1CHECK_ARGS1() -&gt; Error, 无法求值 */\n\n接下来通过CHECK_ARGS1()配合CAT()宏，拼接出MAX_1和MAX_0两个分支：\n#define MAX_NUM(a, ...) \\    ( \\        a &gt; DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) ? \\        a : DEFER(MAX_INDIRECT)(__VA_ARGS__)(__VA_ARGS__) \\    )#define MAX_INDIRECT(...) MAX_BRANCH(CHECK_ARGS1(__VA_ARGS__))#define MAX_BRANCH(n) PRIMITIVE_CAT(MAX_, n)#define FIRST(a, ...) a#define MAX_1 MAX_NUM#define MAX_0 FIRST\n\n至此MAX_NUM()就能够完成主要的功能，由于延迟求值的原因，需要在外层再套一个EVAL()。每多一个参数就多一层递归，也就多一次延迟求值。前面写的EVAL()可以处理243次延迟求值。\n#define MAX(...) EVAL(MAX_NUM(__VA_ARGS__))/* MAX(1, 2) -&gt;    ( 1 &gt; 2 ? 1 : 2 )MAX(1, 2, 3) -&gt;    ( 1 &gt; ( 2 &gt; 3 ? 2 : 3 ) ? 1 : ( 2 &gt; 3 ? 2 : 3 ) )MAX(1, 2, 3, 4) -&gt;    ( 1 &gt; ( 2 &gt; ( 3 &gt; 4 ? 3 : 4 ) ? 2 : ( 3 &gt; 4 ? 3 : 4 ) ) ? 1 :         ( 2 &gt; ( 3 &gt; 4 ? 3 : 4 ) ? 2 : ( 3 &gt; 4 ? 3 : 4 ) ) )MAX(a, b, c, d, e, f) -&gt;    ( a &gt; ( b &gt; ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e :     f ) ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) )     ) ? b : ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f )     ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) ) ) )     ? a : ( b &gt; ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e :     f ) ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) )     ) ? b : ( c &gt; ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f )     ) ? c : ( d &gt; ( e &gt; f ? e : f ) ? d : ( e &gt; f ? e : f ) ) ) ) )int max3(v1, v3, v3)&#123;    return MAX(v1, v2, v3);&#125; -&gt;    int max3(v1, v3, v3)&#123;        return ( v1 &gt; ( v2 &gt; v3 ? v2 : v3 ) ? v1 : ( v2 &gt; v3 ? v2 : v3 ) );    &#125;----Error:MAX() -&gt; ( &gt; ? : )MAX(1) -&gt; ( 1 &gt; ? 1 : ) */\n\n可以看出，递归展开后呈二次增长。无论生成的表达式多复杂，结果都是正确的。受限于CHECK_ARGS()，这只能处理不超过63个数的最大值计算。\n这里还存在一点点瑕疵，前面是先递归再分支判断，所以传入一个或零个参数时的结果不正确。可以先直接调用MAX_INDIRECT()做一次分支判断，当只有一个参数时就直接返回。\n#define MAX(...) EVAL(MAX_INDIRECT(__VA_ARGS__)(__VA_ARGS__))/* MAX(1) -&gt; 1MAX(1, 2) -&gt; ( 1 &gt; 2 ? 1 : 2 )----MAX() -&gt; 返回为空MAX_INDIRECT为什么有两个参数列表？    第一个参数列表用于去判断参数数量做分支处理，第二个参数列表是实际待处理数据。 */\n\n数值系统MAX()真正意义上来说没有得到一个数列的最大值，原因是C语言的宏定义没有数值计算系统。所以这里返回了一个表示最大值表达式。\n进一步思考一下，宏定义能不能实现数值计算？\n#define ADD(a, b) (a+b)\n\n这并不是我想要的，这仅仅返回了一个表达式。我需要的是能够直接返回计算结果。\n/* ADD(1, 2) -&gt; (1+2) // ErrorADD(1, 2) -&gt; 3     // It&#x27;s OK. How to implement it? */\n\n注意前文的两个宏函数INC()、DEC()，它们能够实现一个数的加1或减1：\n/* INC(5) -&gt; 6INC(0) -&gt; 1DEC(1) -&gt; 0DEC(9) -&gt; 8INC(DEC(1)) -&gt; 1 */\n\n那么ADD(a, b)函数可以表达为需要调用a次的INC(b)。或者说a+b&#x3D;(a-1)+(b+1)，ADD(a, b)&#x3D;ADD(DEC(a), INC(b))。这看起来又是一种递归的形式了，当a等于0时结束递归。这是一种尾递归的形式，可以使用表达为循环。来看看C语言的形式：\nint add(int a, int b)&#123;    if(a)&#123;        return add(a - 1, b + 1);    &#125;else&#123;        return b;    &#125;&#125;\n这样的形式就很容易使用宏定义表达：\n#define ADD_INDIRECT() ADD#define ADD(a, b) \\    WHEN(a) (OBSTRUCT(ADD_INDIRECT)() (DEC(a), INC(b))) \\    WHEN(NOT(a)) (b)/* 这里使用OBSTRUCT()来进行延时求值，所以最终的表达式需要使用EVAL()进行展开求值。EVAL(ADD(1,2)) -&gt; 3EVAL(ADD(2,2)) -&gt; 4EVAL(ADD(5,0)) -&gt; 5EVAL(ADD(0,5)) -&gt; 5EVAL(ADD(0,0)) -&gt; 0EVAL(ADD(2,EVAL(ADD(2,2)))) -&gt; 6 */\n\n思考一下，能不能实现一个数值版本的MAX()宏函数？它能真正计算出数列的最大值。\n/* MAX(1, 2)    -&gt; 2MAX(3, 2, 1) -&gt; 3 */\n\n这似乎是一个新的挑战，需要完成宏定义中没有的数值比较功能。后面有时间再研究。😅\n总结仅用#define功能就完成了条件语句、循环、递归的实现。这是不是意味着C语言的宏是图灵完备的呢？\n我查阅了很多网友的讨论，大部分人的看法是有限个数的宏标识符无法完成尽可能大的递归深度。通过C语言宏实现的counter机制要求每个值都需要一个宏标识符，这就限制了宏的复杂性。因为C语言的规范中限定了单次宏处理标识符的最大数量。这和其它图灵机的无限内存是有本质区别的。\n此外，前面所实现的循环和递归都是有限深度的。无法实现无限循环和无穷递归就不具备完整的图灵完备性。但它确实完成了迭代、条件等类似的结构，这是不是意味着它是存在有限的图灵完备性。\n本文仅讨论C语言宏的一些内在性质，并不推荐在实际的开发中使用如此复杂的代码。\n参考1.theory - 什么是图灵完备？2.C&#x2F;C++ 宏的图灵完备性3.Is the C99 preprocessor Turing complete?4.Dave Prosser’s C Preprocessing Algorithm5.Best abuse of the C preprocessor\n"},{"title":"Exception Failure - Breaking the STM32F1 Read-Out Protection","url":"/2022/03/28/Exception%20Failure%20-%20Breaking%20the%20STM32F1%20Read-Out%20Protection/","content":"Marc Schink &amp; Johannes Obermaier Tuesday, 17 March 2020\n\nThe firmware of microcontrollers usually contains valuable data such as intellectual property and, in some cases, even cryptographic material. In order to protect the confidentiality of these assets, most microcontrollers feature some kind of firmware read-out protection. This security feature shall prevent adversaries with physical access to a device from reading out the internal flash memory. Nevertheless, security researchers as well as hobbyists showed repeatedly that these security features can be circumvented. In this research article, we examine the flash read-out protection (RDP) of the STM32F1 series from STMicroelectronics. We discuss a novelly discovered vulnerability whose exploitation would be the first non-invasive way to circumvent the feature. The issue results from an insufficient access restriction: flash data reads via the debug interface are blocked but the CPU’s exception handling process is still able to read from flash memory via the ICode bus. We explain in detail why and how this vulnerability exposes major parts of the internal memory, thereby affecting device security.\n\n\n\n\n\nIntroductionFor the protection of intellectual property and other sensitive data such as cryptographic material, securing the internal flash memory of a microcontroller is of utmost importance. If an attacker gains access to the firmware, they can clone the product, alter its functionality or extract security credentials. Thus, the hardening of microcontroller plays a major role in today’s embedded system security — not only for high-security devices but also for commercial microcontrollers.\nThe deactivation of the debug interface is one usual way to prevent adversaries from gaining access to the flash memory, however, the implementation differs between microcontrollers. For example, the debug interface of the STM32F0 series can be entirely switched off. In contrast, the STM32F1 series does not directly support this, but relies on another approach. One of its main security features is the flash memory read-out protection (RDP). This security feature blocks all data accesses to the flash memory via the debug interface once a debug probe is attached to the microcontroller. This means that an attacker is able to attach a debug probe to the microcontroller but cannot read out the flash memory content.\nHowever, research has shown for some microcontrollers that this protection mechanism is flawed. For the STM32F0 series, for instance, Johannes Obermaier and Stefan Tatschner presented an attack in Shedding too much Light on a Microcontroller’s Firmware Protection that is able to extract protected data from flash memory. Some researchers assumed that this vulnerability might also affect other series such as the STM32F1. However, one of the authors contradicted that the STM32F1 microcontroller family exhibits the same vulnerability in the debug interface. Until now, the flash read-out protection mechanism of the STM32F1 series was considered as being secure and there was no evidence that it can be circumvented. In this article, we discuss a vulnerability (CVE-2020-8004) that leads to the first non-invasive attack against the flash protection mechanism of the STM32F1 family.\nDiscovering the VulnerabilityThe STM32F1 series does not provide a feature to permanently disable the debug interface. For that reason, an attacker with physical access to the debug interface is always able to gain debug access to the microcontroller. However, the integrated flash read-out protection prevents any data access to the flash memory once a debug probe is attached to the microcontroller.\nIn order to examine the flash read-out protection feature, we use an STM32 Nucleo-64 development board with an STM32F103RB microcontroller. The read-out protection of the microcontroller is enabled which means that the flash memory is not accessible via the debug interface. The microcontroller is attached via the SWD debug interface to an external SEGGER J-Link debug probe, as depicted in Figure 1.\n\n\n Figure 1: STM32 Nucleo-64 development board with attached SEGGER J-Link debug probe.\n\n\nWe begin our examination by establishing a debug connection to the target microcontroller. For that, we start OpenOCD with the following command:\nopenocd -f interface/jlink.cfg -c &quot;transport select swd&quot; -f target/stm32f1x.cfg\n\nAfter that, we open a Telnet session on OpenOCD such that we can control the microcontroller. Finally, we perform a device reset with the command and get the following output in our Telnet session:reset halt\ntarget halted due to debug-request, current mode: ThreadxPSR: 0x01000000 pc: 0x08000268 msp: 0x20005000\n\nAt a first glance, there is nothing special with this output. However, when you take a closer look at the second line, especially one value should pop into your eyes: the program counter (PC) value is a valid address located in flash memory. This is of major importance because a reset is a special kind of exception. Every time an exception is generated, the processor loads the corresponding exception entry address from the vector table into the PC. This procedure is sometimes referred to as vector fetch. After a device reset, the vector table is located in flash memory. Hence, this observation implies that the processor fetches the reset vector from flash memory even though the read-out protection is enabled.0x08000268\nBut why is the exception entry process able to read the reset vector from flash memory? The STM32F1 reference manual provides a hint:\n\nThe Cortex®-M3 CPU always fetches the reset vector on the ICode bus, which implies to have the boot space available only in the code area (typically, Flash memory).\n\nThe reset vector is fetched via the ICode bus and thus handled like instruction fetches which are allowed despite the activated read-out protection. The read-out protection seems to take care of data accesses via the data bus (DCode bus) only and hence the reset vector can still be fetched over the ICode bus. The Cortex-M3 Technical Reference Manual provides additional information regarding vector fetches in general:\n\nThe vector fetch is performed over either the System bus or the ICode bus depending on where the vector table is located […]\n\nIn summary, the flash read-out protection of the STM32F1 does not block memory accesses via the ICode bus. Once an exception takes place, the corresponding entry address stored in flash memory is fetched through the ICode bus and thereby exposes the memory content through the PC.\nExploitationOur observation shows that once an exception takes place, the vector fetch exposes protected flash memory content through the PC. In this section, we discuss how this behaviour can be exploited to bypass the read-out protection of the STM32F1.\nWe already mentioned the vector table: it contains the initialization value of the main stack pointer (MSP) followed by an entry address for every exception. The vector table for microcontrollers based on the ARMv7-M architecture is shown in Table 1. The table lists the exceptions with their memory offset relative to the beginning of the vector table. The first 16 exceptions of the vector table are mandatory and specified by the ARMv7-M architecture. All other exceptions are so called external interrupts, they are optional and device specific.\n\n\n\n\n\nException number\nException\nOffset\n\n\n\n-\nMain stack pointer (MSP) initialization value\n0x0\n\n\n1\nReset\n0x4\n\n\n2\nNMI\n0x8\n\n\n3\nHardFault\n0xc\n\n\n4\nMemManage\n0x10\n\n\n5\nBusFault\n0x14\n\n\n6\nUsageFault\n0x18\n\n\n7-10\nReserved\n0x1c\n\n\n11\nSVCall\n0x20\n\n\n12\nDebugMonitor\n0x24\n\n\n13\nReserved\n0x28\n\n\n14\nPendSV\n0x2c\n\n\n15\nSysTick\n0x30\n\n\n16\nExternal Interrupt 0\n0x34\n\n\n…\n…\n…\n\n\n\n\nTable 1: Vector table for microcontrollers implementing the ARMv7-M architecture.\n\n\nThe basic exploitation idea is to deliberately generate exceptions such that the corresponding vector table entry is fetched from flash memory and exposed through the PC. However, Table 1 shows that some entries are reserved and are not mapped to an exception, namely the entries 7 to 10 and 13. Also needless to say, the initialization value for the MSP is not mapped to an exception. For that reason, the corresponding table entries cannot be extracted via this approach. We ignore this for the moment and address these limitations in more detail later in this article.\nVector Table OffsetAt this point, the following question may arise: why should I care about the confidentiality of the vector table content?\nIndeed, the content of the vector table is usually not confidential as it only contains the exception entry addresses. But note that the ARMv7-M architecture specifies a Vector Table Offset Register (VTOR) that determines the location of the vector table inside the address space. This feature is usually used to relocate the vector table when there are multiple applications on the microcontroller, for example, a bootloader and a main application. With that, both applications can have their own vector table and exception handlers. The crucial point here is again, that we have debug access to the entire device except for the flash memory. With help of the VTOR, we are able to relocate the vector table within the flash memory region and extract large amount of its data.\nIn order to use the vector table relocation, we split the flash memory into equally sized blocks of 32 words, as depicted in Figure 2. The block size is related to the vector table size and, as required by the ARMv7-M specification, must be a power of 2. For example, the STM32F103 has 59 exceptions and therefore the actual vector table size is 64. However, this means that we do not have enough exceptions to access all its table entries. For that reason, we use the largest possible vector table that fits in 59 which is 32.\n\n\nFigure 2: Relocation of the vector table within the flash memory. Inaccessible table entries are highlighted.\n\n\nThe seven highlighted memory words in Figure 2 cannot be extracted. The first two words are the initialization value for the MSP and the reset vector. The other words correspond to the reserved entries of the vector table. The MSP initialization value and the reset vector are special and can only be extracted when the vector table is located at the beginning the of the flash memory, its default location. The reason is that a device reset is necessary to extract these value, however, this also resets the VTOR and relocates the vector table to the beginning of the flash memory region.\nThese limitations can be reduced by using exceptions that exceed the vector table size. In this case, exceptions with a number greater than 31. According to section 4.4.4 of the STM32F1 programming manual, the vector table location must be aligned to the actual vector table size, 64 in case of the STM32F103. But what happens when our vector table is unaligned and we generate exceptions with numbers greater than the vector table size? It turns out that these exceptions are mapped to the beginning of the vector table. Figure 3 illustrates this wrap-around behaviour for an unaligned vector table with 32 entries. On the left-hand side, the regular vector table with its inaccessible entries highlighted is depicted. On the right-hand side, the figure shows how the wrap-around behaviour makes the inaccessible parts of the vector table accessible. The highlighted vector table entries are now accessible by exceptions that exceed the vector table size.\n\n\nFigure 3: Wrap-around behaviour of an unaligned vector table. Inaccessible entries (red) become accessible (blue) when an exception exceeds the table size.\n\n\nNote that in Figure 3, the focus is on the inaccessible parts of the vector table. The other entries can also be extracted via the wrap-around behaviour, however, this is not necessary since they can be extracted regularly. With the help of the wrap-around, we are now able to extract vector table entries that were reserved or inaccessible before. Even the first two entries which were only extractable when the vector table is located at the beginning of the flash memory region. The only limitation that remains is that we can use this approach only for unaligned vector tables. Nevertheless, we reduced the number of inaccessible memory words by a factor of two. Note that this approach is one way to make use of the additional external interrupts. We use this way because it is very convenient to implement.\nNow, we have almost everything we need to extract nearly arbitrary parts of the flash memory. In the next section, we describe the last missing piece: how to generate exceptions on purpose.\nException GenerationTo generate each individual exception for firmware extraction, we continue as follows. We need three steps to trigger an exception:\n\nPerform a device reset such that the microcontroller is in a defined state and to recover it from possible faults and lockups.\nConfigure the microcontroller such that the indented exception is pending.\nPerform a single step to make the pending exception active.\n\nThe Non-Maskable Interrupt (NMI), PendSV and SysTick exception can easily made pending by setting the corresponding bits , and respectively. These bits can be found in the Interrupt Control and State Register (ICSR). The same holds for the DebugMonitor exception which can be made pending by setting the bit in the Debug Exception and Monitor Control Register (DEMCR).NMIPENDSETPENDSVSETPENDSTSETMON_PEND\nFor example, the following OpenOCD commands makes the PendSV exception pending:\nmww 0xe000ed04 0x10000000\n\nSince the processor is in debug mode and halted, we need to give it the chance to execute the exception. For that, we use the command to execute only a single instruction. In order to avoid side-effects by the executed instruction, we execute a single instruction placed in SRAM at address .stepnop0x20000000\nmwh 0x20000000 0xbf00reg pc 0x20000000\n\nNote that it is necessary to disable interrupt masking. This feature is enabled by default and can be deactivated with the following command:\ncortex_m maskisr off\n\nThis command changes the single-stepping behaviour and controls the bit in the Debug Halting Control and Status Register (DHCSR). This bit determines whether PendSV, SysTick and all external interrupts shall be masked. By default, is set to auto which means that a command first allows pending interrupt handlers to execute and then steps over the desired instruction.C_MASKINTSmaskisrstep\nNote\nThe command is not available for so called high-level adapters (HLA) in OpenOCD. For that reason, we do not use the integrated ST-LINK debug probe of the Nucleo-64 development board.maskisr\nOnce an exception is generated, you may experience that there is a mismatch between the exception entry address in the vector table and the PC value. The least-significant bit (LSB) may be incorrect. The reason is that the LSB of the exception entry address is not loaded into the PC but used as Thumb state of the processor. Since the Thumb state is encoded in the Execution Program State Register (EPSR), we are able to recover the entire exception entry address by combining the PC and the Thumb state bit.\nWe have all building blocks required to extract vector table entries. In the following, we elaborate how to generate the remaining exceptions. For simplicity, we omit the first and last step of the exception generation process throughout the remainder of this article.\nBusFaultA BusFault exception occurs, for example, when a memory instruction accesses an invalid memory region. Hence, we can generate a BusFault by executing a load instruction that performs a read access on an invalid memory region.\nFor that, we place an into the SRAM at address and configure the base register and the PC accordingly:ldr r0, [r1, #0]0x20000000r1\nmwh 0x20000000 0x0868reg r1 0xf0000000reg pc 0x20000000\n\nThe address stored in is part of the vendor-specific memory region. In case of the STM32F1, this address is not mapped in the memory space. Therefore, every memory operation on this address is illegal and thus suitable to generate a BusFault exception. All other addresses that are not mapped work as well.0xf0000000r1\nBefore we are able to generate a BusFault exception, we need to enable it by setting the bit in the System Handler Control and State Register (SHCSR):BUSFAULTENA\nmww 0xe000ed24 0x20000\n\nThis step is necessary because otherwise priority escalation would take place and the processor would generate a HardFault exception instead of a BusFault.\nMemManageThe MemManage exception is generated whenever a memory protection fault occurs. Among others, this happens when the processor attempts to execute code in a memory region that is marked as eXecute Never (XN).\nIn order to cause a memory protection violation, we configure the processor such that it attempts to execute code on a memory region marked as XN. In our case, we chose the first address of the system memory address space which is at the address .0xe0000000\nreg pc 0xe0000000\n\nAs for the BusFault exception, the MemManage exception needs to be enabled. We do this by setting the bit in the SHCSR:MEMFAULTENA\nmww 0xe000ed24 0x10000\n\nUsageFaultUsageFault exceptions can occur for a variety of reasons. One reason is, for example, when an unaligned memory load or store operation is performed.\nHowever, the straightforward way is to execute an undefined instruction such as . We place this instruction in SRAM at address and configure the PC accordingly:0xffff0x20000000\nmwh 0x20000000 0xffffreg pc 0x20000000\n\nAs for the other exceptions, the UsageFault exception needs to be enabled. This can be done by setting the bit in the SHCSR:USGFAULTENA\nmww 0xe000ed24 0x40000\n\nHardFaultA HardFault is a generic fault that is generated whenever a fault cannot be handled by any other exception.\nThere are different means to generate a HardFault exception manually. A straightforward way is to generate one of the previously mentioned exceptions without enabling it. As explained before, this causes a priority escalation and the HardFault exception gets generated.\nSVCallA Supervisor Call (SVCall) is used by software to call the operating system. This exception is generated whenever the processor executes an instruction.svc\nWe generate this exception by placing an instruction in SRAM and execute it with a single step.svc #0\nmwh 0x20000000 0xdf00reg pc 0x20000000\n\nSince we are only interested in generating an SVCall exception, the immediate value is not important and can be arbitrarily chosen. In contrast to the former two exceptions, a supervisor call is permanently enabled.#imm\nExternal InterruptsThe Nested Vectored Interrupt Controller (NVIC) handles all the external interrupts. It provides two set of registers: one to enable external interrupts and a second one to make them pending. In order to trigger an external interrupt, we set the corresponding bits in both registers to enable the interrupt and make it pending. Every bit corresponds to an external interrupt.\nFor example, in case of the STM32F1 series, the first external interrupt is the window watchdog (WWDG) interrupt. In order to trigger this interrupt, we set the first bit in both registers:\nmww 0xe000e100 0x1mww 0xe000e200 0x1\n\nAll other external interrupts can be generated accordingly.\nThe number of external interrupts varies a lot among the different devices of the STM32F1 family. Additionally, the documentation is sometimes not accurate. For example, according to the STM32F1 reference manual, the external interrupts 43 to 49 of connectivity line devices are reserved. However, we found out that they can be generated like all the other interrupts. The importance of the available external interrupts will be seen in the next section.\nPerformanceThe amount of extractable memory content and the extraction speed are key indicators whether the identified vulnerability undermines the security of the read-out protection in field applications.\nIn order to asses the severity of this vulnerability, we implemented a Python script that generates exceptions in an automated fashion to extract firmware from a read-out protected microcontroller. We evaluated the presented attack on three different devices of the STM32F1 series. In all cases, we aimed to extract 128 KiB of flash memory from the devices. The evaluation results are listed in Table 2.\n\n\n\n\n\nDevice\nExternal interrupts\nExtraction time\n\n\n\nSTM32F100\n55\n48.8 min\n\n\nSTM32F103\n43\n48.2 min\n\n\nSTM32F107\n68\n51.0 min\n\n\nTable 2: Extraction time and coverage for three devices of the STM32F1 series.\n\n\nThe results show that the amount of flash memory that can be extracted correlates with number of external interrupts. The most data can be extracted from the STM32107 microcontroller with its 68 external interrupts. The table also shows that the extraction time slightly increases with the increasing amount of extracted data.\nWe used a SEGGER J-Link debug probe with an adapter speed of 3500 kHz for the performance evaluation. Note that the adapter speed of your debug probe is an important factor for the extraction time and might also be influenced by further factors in your setup, for example, your computer system.\nIn a nutshell, these results show that the attack is indeed practically feasible as it can be executed in reasonable time: in less than one hour.\nConclusionIn this article, we discussed a vulnerability in the flash read-out protection mechanism of the STM32F1 microcontroller series. We showed that the exploitation is non-invasive and requires only access to the microcontroller’s debug interface. Hence, this attack is clearly within the typical attacker models of flash readout protection mechanisms.\nThe presented attack has certain limitations and does not allow an attacker to read out the entire flash memory. However, depending on the device, an attacker is able to read out up to 94.5 percent of the flash memory content in less than an hour. For that reason, we consider this read-out protection mechanism as broken and we do not recommand to rely on this feature anymore. Since the STM32F1 series has no other firmware protection mechanism, the only way known to the authors to avoid exploitation and thus keep the entire flash memory content confidential is to physically prevent an attacker from gaining access to the debug interface.\nAvailabilityIn order to encourage discussions and make our research results comprehensible and replicable, we publish the source code that was developed during our research. The source code is licensed under the GPLv3+ and can be found on https://gitlab.zapb.de/zapb/stm32f1-firmware-extractor.\nCoordinated DisclosureThe publication of our findings was preceded by a coordinated vulnerability disclosure process. We informed STMicroelectronics more than 100 days prior to the publication of this article.\n\n28 November 2019: Technical details about the vulnerability and the disclosure timeline provided to STMicroelectronics.\n08 December 2019: No response from STMicroelectronics so far. Reminder with technical details and disclosure timeline.\n23 December 2019: Still no response from STMicroelectronics. Reminder without technical details.\n06 January 2020: Reminder from CERT Bund and immediate response from STMicroelectronics.\n10 January 2020: Conference call with STMicroelectronics and CERT Bund as mediator.\n15 January to 07 February 2020: Further discussions between STMicroelectronics and CERT Bund.\n01 February 2020: Public announcement of the vulnerability without technical details.\n17 March 2020: Publication of this article and supplementary materials.\n\nAbout the AuthorsMarc Schink and Johannes Obermaier are two embedded system security researchers with a background in computer science and electrical engineering. They focus especially on microcontrollers that both encounter in their everyday live. With their research and publications they aim at improving security by an open discussion about the strength of security features and wish for improvements.\n\nExcept where otherwise noted, content on this site is licensed under a Creative Commons BY-NC-SA 4.0 license.\n"},{"title":"FreeRTOS上实现swap机制","url":"/2022/08/11/FreeRTOS%E4%B8%8A%E5%AE%9E%E7%8E%B0swap%E6%9C%BA%E5%88%B6/","content":"为什么需要引入SWAP机制在小容量SRAM的单片机上使用RTOS是一种很尴尬的事情，因为每个任务都需要分配独立的线程栈，栈空间少则512字节，复杂任务的栈空间则达到了几千字节的大小，这对于仅有8k字节SRAM的单片机来说显得压力太大了，两三个任务就导致内存不足。\n使用协程方案在在小容量单片机上是一个不错的方案，但是协程相比于实时操作系统具有很多的缺点。比如任务实时性不足、在用法上不灵活等。\n根据现代操作系统的SWAP机制，我在FreeRTOS操作系统上也实现了任务栈的swap机制，通过外部存储设备扩展单片机内的可用栈空间大小，可显著降低片内SRAM空间的消耗。同时该方案对任务来说是无感的，也就是说它和普通任务一样在用法上没有区别，可以按照传统的RTOS任务进行设计，这对于任务的移植来说能够降低复杂性。\n方案介绍使用SWAP机制一个重要前提是需要一个大容量的片外存储设备来进行内存交换。比如说片外的PSRAM，通过SPI总线访问的那种。一个基本的设想是先分配一段实际的物理空间，这将作为所有线程的栈空间，线程A在使用完这段空间后，切换到线程B时，先将线程A的栈空间数据存放到外部分配的SWAP空间上，同时将线程B保存在外部SWAP空间上的栈数据恢复到共享的栈空间上。通过预留在FreeRTOS内的HOOK接口很容易就能实现这些功能，且对FreeRTOS的原有代码没有明显的入侵。\n具体实现的要点\n1.任务创建为了指定任务运行时实际的栈空间地址，使得栈空间数据可控，需要使用xTaskCreateStatic()接口创建任务。此外，创建任务时会对栈空间数据进行必要的初始化操作，所有创建任务时的上下文栈空间不能处于共享栈空间上，否则会出现数据冲突。任务的删除也需要特别设计，任务删除仅仅需要删除分配的TCB块空间，栈空间不会收，但是需要释放外部分配的SWAP空间。\n\n2.任务切换时栈空间存储将当前任务的栈空间存储到SWAP空间时，没有必要将整个栈空间都进行存储，因为栈的使用是线性连续的，通常使用栈底的部分数据，所以仅需保存部分数据到SWAP空间即可，这样可以提升线程的切换速度。在任务切换时还需要做适当的判断，避免无效的栈空间交换。我们仅仅需要在从一个共享栈任务切换到另一个共享栈任务时需要触发SWAP机制，其它情况都不需要进行内存交换。例如，Tiemr线程的栈时独立分配的，那么从timer切换到共享栈任务A在切换到timer过程中，显然都是不需要进行栈交换的。可以使用traceTASK_SWITCHED_IN()作为内存交换点。\n\n3.SWAP存储作为栈的交换存储空间，读写速度是非常关键的，将一次栈切换的时间控制在1ms以内时非常有必要的。所有内存交换的机制应当尽量设计的简单可靠，避免使用文件等复杂的存储过程。存储空间的大小和访问方式也很关键，最好是字符设备，块设备的读写在这里是低效的。存储空间应当能够覆盖所有共享的内存数据以及管理这些数据的额外数据开销。\n\n\n方案测试我选择了STM32L051C8T6单片机(8k字节SRAM)配合APS6404L片外的PSRAM进行测试，PSRAM使用16Mhz的SPI总线连接。创建了Timer任务、IDLE任务和一个普通的用户任务，这三个任务使用了独立的栈空间分配，分别为512、512、1024字节。此外还分配了3个栈空间共享的任务，栈空间大小均为1024字节。在这种情况下，所有任务运行起来后FreeRTOS的heap剩余空间仍然超过了1k。额外创建一个栈空间共享的任务开销约100字节左右。\n缺陷\n无法在栈共享任务上创建一个新的栈共享任务，这个在实现要点1上已经解释了。\n任务栈内的局部变量数据无法传递到栈外，这是特别关键的。通常栈内的数据通过邮箱等传递到其它线程后，通过阻塞的方式等待响应，所以该栈内的局部变量数据传递到其它线程后依然有效。但是对于栈共享的任务来说是无法实现的。\n栈共享的任务实时性无法得到保障，因为它在线程唤醒时需要进行栈空间的恢复操作，任务响应时间肯定比栈独立的任务要长。所有对于需要快速响应的任务任然可以使用一般的任务创建方式创建任务，因为从栈共享任务切换到一般任务是不需要触发SWAP机制的。\n\n"},{"title":"FreeRTOS中协程支持低功耗吗","url":"/2022/09/06/FreeRTOS%E4%B8%AD%E5%8D%8F%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BD%8E%E5%8A%9F%E8%80%97%E5%90%97/","content":"FreeRTOS协程FreeRTOS除了支持多线程外，还支持另外一种多任务机制-协程(coroutine)。它和线程不一样，每个协程不需要独立的运行空间，它依靠编程语法技巧在逻辑上实现了多任务的机制。它避免的一般RTOS带来的栈切换开销，仅仅依靠极小的开销就能保存任务的中间状态并在适当的时刻快速恢复任务。简单来说就是任务需要切换时先记录当前执行的位置并返回，重新进入该任务时根据保存的位置恢复任务执行，所以它不支持任务间抢占，所以任务的实时性也比较有限，但是它多任务时的低开销特性在许多场景下具有比较明显的优势。\nFreeRTOS使用C语言提供的switch-case语法作为实现协程的关键，switch-case能够进行非常灵活的跳转，这个真的超乎一般人对switch用法的理解(点名达夫设备)。此外由于多个协程任务共享同一个栈空间，所以协程中无法使用生命周期比较长的局部变量，即定义的局部变量在使用的整个生命周期内不能进行协程的任务调度，一旦发生任务调度，则局部变量的数据就有可能丢失，所以在设计协程时通常使用全局变量来避免使用栈空间内的局部变量数据。\n在设计协程任务时需要根据一定的代码模板来设计，因为协程的核心是由语法来实现的，所以代码无法设计的足够的灵活，存在许多的设计和用法限制。\n低功耗特性协程意味着任务过程简单，在现实应用场景下，简单任务和低功耗特性通常一起出现，那使用FreeRTOS的协程支持低功耗吗？根据FreeRTOS的参考文档来看，官方并没有提及协程+低功耗的用法，但是这两个特性正好是FreeRTOS都支持的，这两个特性能够独立正常工作。那合并到一起呢？\n冲突官方推荐的协程调度方案是这样的：\nvoid vApplicationIdleHook( void )&#123;    for( ;; )    &#123;        vCoRoutineSchedule();    &#125;&#125;\n使用IDLE任务的hook来进行协程的调度。那进一步看看该hook在Idle任务中的执行位置：\n// ...#if ( configUSE_IDLE_HOOK == 1 )&#123;    extern void vApplicationIdleHook( void );    /* Call the user defined function from within the idle task.  This     * allows the application designer to add background functionality     * without the overhead of a separate task.     * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,     * CALL A FUNCTION THAT MIGHT BLOCK. */    vApplicationIdleHook();&#125;#endif /* configUSE_IDLE_HOOK *//* This conditional compilation should use inequality to 0, not equality * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when * user defined low power mode  implementations require * configUSE_TICKLESS_IDLE to be set to a value other than 1. */#if ( configUSE_TICKLESS_IDLE != 0 )&#123;    TickType_t xExpectedIdleTime;    /* It is not desirable to suspend then resume the scheduler on     * each iteration of the idle task.  Therefore, a preliminary     * test of the expected idle time is performed without the     * scheduler suspended.  The result here is not necessarily     * valid. */    xExpectedIdleTime = prvGetExpectedIdleTime();    // ...&#125;#endif /* configUSE_TICKLESS_IDLE */\n到这里应该发现问题了吧。vApplicationIdleHook比TICKLESS处理要先执行，而协程的调度实现是一个死循环，这意味着idle任务没有时机来进行TICKLESS处理，导致系统无法进入低功耗状态。\n这里解释一下vCoRoutineSchedule()为什么需要放到一个无限循环中，这是该协程框架决定的，该调度函数需要一直执行，该函数并不返回一些调度状态，导致我们无法决定协程调度的时机，为了协程的正常运行，所以协程就必须要一直进行调度。而最终的结果就是使用协程后，FreeRTOS的低功耗特性就失效了。\n曙光分析到这里的时候，我突然有一个疑惑，FreeRTOS已经设计了非常完善的配置机制，为什么它没有考虑到这两个功能的用法冲突，进而在配置上进行处理呢。比如说开启协程后就禁止使用低功耗特性。这是不是意味着有什么方法能够突破这个限制，所以官方故意在配置上留下了同时启用两种功能的可能性。\n我重新开始梳理了FreeRTOS的协程和低功耗实现方案，发现现有的设计是无法实现的。将协程调度放入到单独的线程中是最接近的一个实现方案：\nvoid CoRoutineTask(void *p)&#123;    for(;;)&#123;        vCoRoutineSchedule();        // vTaskDelay(?);    &#125;&#125;\n该任务的优先级如何确定呢？协程中的延时是否需要？延时多长？只要优先级比idle任务高且存在任意时间的延时，低功耗的tickless就可执行。但是难点是无法确定延时时间。\n协程没有实现计算下一次协程调度的时机函数。对于任务来说，prvGetExpectedIdleTime()函数能够计算出下一次进行任务调度的期望时间。所以我们也需要一个这样的函数，计算下一次进行协程调度的期望时间。实现了这个函数将是在协程下实现低功耗的希望。\n下一次协程调度到底需要多长时间检索这些数据就能知道答案：\n\n1.等待任务列表(pxDelayedCoRoutineList)\n2.就绪任务列表(pxReadyCoRoutineLists)\n3.即将就绪任务列表(xPendingReadyCoRoutineList)\n\n最后一个是很容易忽视的，在进行协程间通信时，任务并不是直接切换到就绪任务列表中，而是添加到了待就绪任务列表(这是为了保证就绪任务列表不在中断中进行修改)。所以在检索任务时该列表中的任务可以看作时任务已经就绪了。\n当就绪任务列表非空或者即将就绪任务列表非空意味着协程需要立即调度。当等待任务列表中的任务已经超时了也要立即调度。否则就根据等待任务列表中等待时间最少的任务来计算下一次协程调度的时间。此外，还需要注意所有列表为空的情况，这可以认为下一次调度的时间为无限长。\nTickType_t xGetExpectedIdleTime( void )&#123;    CRCB_t * pxCRCB;    UBaseType_t uxPriority;    TickType_t xIdleTime;    if( listLIST_IS_EMPTY( &amp;xPendingReadyCoRoutineList ) == pdFALSE )    &#123;        xIdleTime = 0u;    &#125;    else    &#123;        xIdleTime = portMAX_DELAY;        for( uxPriority = 0; uxPriority &lt; configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )        &#123;            if( listLIST_IS_EMPTY( &amp;( pxReadyCoRoutineLists[ uxPriority ] ) ) == pdFALSE )            &#123;                xIdleTime = 0u;                break;            &#125;        &#125;        if(xIdleTime &gt; 0u)        &#123;            if( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )            &#123;                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );                if(xCoRoutineTickCount &lt; listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )))                &#123;                    xIdleTime = listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )) - xCoRoutineTickCount;                &#125;                else                &#123;                    xIdleTime = 0u;                &#125;            &#125;            else            &#123;                mtCOVERAGE_TEST_MARKER();            &#125;        &#125;    &#125;    return xIdleTime;&#125;\n\n在代码风格上参考了FreeRTOS相类似的代码风格。这里检查了所有优先级的就绪任务列表(从高优先级到低优先级应该会更快)，可以考虑仅仅检查uxTopCoRoutineReadyPriority优先级的列表，这样在优先级较多的时候可以执行的更快。\n协程运行在可休眠的线程中能够计算协程的调度时机后，我们就能将协程放入到一个可休眠的线程中，而不是在阻塞的无限循环中执行。\nvoid vCoScheduleTask( void )&#123;    // ...    for( ;; )    &#123;        vCoRoutineSchedule();        uint32_t idle_time = xGetExpectedIdleTime();        if(idle_time &gt; 0)        &#123;            vTaskDelay(idle_time);        &#125;    &#125;&#125;\n该线程的优先级比Idle线程略高。这样在保证正常的协程调度的情况下，系统也能够正常的运行idle线程，保证tickless中的prvGetExpectedIdleTime()函数能够计算出合理的系统线程调度休眠时间，进而实现了协程和低功耗特性的共存。\n最后xGetExpectedIdleTime()函数需要直接实现在croutine.c和.h文件中，所以会对FreeRTOS代码源文件进行修改，但是这没有对现存的代码进行进行逻辑上的更改，所以这样的修改是可控的。\n上面还有一点未提及，如果在中断中同协程进行通信，协程还能够响应吗？需要如何修改才能实现在中断中同协程通信且不影响现有的低功耗特性？其实只需要做简单的修改即可，欢迎讨论。\n"},{"title":"FreeRTOS内核窥探","url":"/2024/01/06/FreeRTOS%E5%86%85%E6%A0%B8%E7%AA%A5%E6%8E%A2/","content":"\n在多任务环境下调试代码需要一定的代码调试经验，尤其是涉及到异步的任务流程时，单步执行可能无法跟踪到需要的执行流程。如果代码全速运行时虽然可以通过日志来梳理执行流程，但是涉及到FreeRTOS内核中的内容时，一般的日志显得比较鸡肋了。比如说我想检查某个时刻所有任务的运行状态，包括任务是运行还是阻塞、阻塞的延时有多久、阻塞在某个信号量上等等，或者更进一步检查任务的调用栈等等。如果能够实现这些功能来窥视FreeRTOS的运行过程，这显然能够帮助我们更加清晰的了解代码的运行过程，方便解决一些棘手的问题。\n\n获取当前系统所有任务的详细信息FreeRTOS提供了uxTaskGetSystemState()方法，可以获取所有任务的一些简单信息，主要包括任务的TCB句柄、任务名称、运行状态、优先级、栈起始地址已经栈空间的最大使用量。这些信息是FreeRTOS直接暴露出来的信息，但是这些信息并不能够方便我们了解任务的运行过程，尤其是任务的细节状态。\n我们想要获取的关键详细信息包括任务当前的SP指针，即实时的栈地址。还需要获取任务的阻塞时长，主要是对于处于阻塞状态的任务来说的。最关键的是需要获取任务阻塞的事件是什么，一般在RTOS中会使用很多的信号量、邮箱等同步机制，如果系统假死后能够看到每个任务的阻塞情况，那么可以最大程度的方便我们定位故障点。\n非常遗憾的是以上这些信息都不能显式的从某个内核接口中获取，同时FreeRTOS执行非常严格数据隐藏策略，外部的应用代码是无法直接访问FreeRTOS内核的数据以及数据结构。但是FreeRTOS为开发人员预留了一组虚拟数据结构的定义，该虚拟数据结构的形式同FreeRTOS中实际的数据结构是一致的，FreeRTOS的初衷是通过这些虚拟结构来计算内核数据结构的大小，但是我们在这里通过这些数据结构的索引就能够突破内核的数据隐藏策略来间接访问内核数据。\n虚拟数据结构的定义都是形如“struct xSTATIC_xxx”的定义，都位于FeeRTOS.h文件中。获取任务的SP指针现在就很容易了，SP指针的值位于TCB数据结构的第一项，虽然不能直接使用TCB的数据结构，但是struct xSTATIC_TCB的结构同它是一致的，所以我们访问任务SP指针的方法是这样的：\nvoid * pvGetTaskMSP(TaskHandle_t xTask)&#123;    return ((StaticTask_t*)(xTask))-&gt;pxDummy1;&#125;\n\n任务需要阻塞多长的时间？这个问题稍微复杂一点，首先这个问题仅仅针对处于阻塞状态的任务，尤其是有限时长阻塞状态的任务。看看vTaskDelay()中的实现，当一个任务需要阻塞时，就将其放入到等待任务列表中，通过函数prvAddCurrentTaskToDelayedList()实现的。首先将当前时刻和需要延时的时长进行计算得到唤醒的时刻，将该时间点记录到任务的xStateListItem变量内部，同时该函数将xStateListItem变量作为一个列表项插入到了pxDelayedTaskList链表的中，这是一个有序的插入过程，即根据任务唤醒时间在链表上进行排序，到这里都比较好理解。通过任务TCB的xStateListItem就能够得到任务延时的时间。但是这里最关键的一点来了，如果任务时无限时长阻塞呢？这种情况是将变得比较麻烦，内核的实现是将其放入到了挂起任务列表(xSuspendedTaskList)中了，我们无法直接访问到xSuspendedTaskList，怎么确定任务是否处于无限阻塞状态呢？\n到这里我确实没有比较好的办法，我选择直接修改内核代码，将处于挂起任务的xStateListItem值设为最大值以标记该任务没有明确的唤醒时间，这里需要思考有没有更简单的方法。\nif( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )&#123;    /* Add the task to the suspended task list instead of a delayed task     * list to ensure it is not woken by a timing event.  It will block     * indefinitely. */    listINSERT_END( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );    listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), 0xffffffff );&#125;\n\n任务等待的事件是什么？不是所有在阻塞的任务都在等待事件，如果任务只是一般的延时，这就表明任务没有等待任何事件。任务的事件机制是依靠TCB中xEventListItem来实现的，比如说等一个任务等待一个队列(queue)，任务就将该TCB中的xEventListItem加入到该队列内部相关的一个链表上。FreeRTOS中的队列(queue)用来实现消息队列、邮箱、信号量等，queue内部有两个链表，一个等待接收链表、一个等待发送链表，这是FreeRTOS内核允许发送数据阻塞导致的，所以队列内部需要两个链表来维护任务的阻塞关系，但实际上这两个队列大多数情况是仅使用其中一个。\n通过xEventListItem中的pxContainer可以反向定位到任务所关联的链表，但是问题来了，queue上有两个链表，我们怎么确定任务所属的链表到底是哪一个呢？因为不能确定的话就不能反向索引到queue的指针，如果假设任务所述链表是queue内的第一个链表，通过containerof方法就能够定位到queue的地址，但万一是另一个链表呢？\n队列中预留了一个有意思的成员uxQueueNumber，它并没有实际的功能，但通过它我们就能够将队列打上特殊标记，进而检索出队列的地址，找到了任务等待的队列地址，这样就确定了任务到达在等待什么事件了。\n#define QUEUE_TRACK_FLAG (0xab123456)void vQueueFlagSet(void* queue)&#123;    vQueueSetQueueNumber((QueueHandle_t)queue, QUEUE_TRACK_FLAG);&#125;void *pvGetTaskEvent(TaskHandle_t xTask, int *type)&#123;    List_t * const pxList = ((StaticTask_t*)(xTask))-&gt;xDummy3[1].pvDummy3[3];    if(pxList == NULL)&#123;        *type = 0;  // no event        return NULL;    &#125;    StaticQueue_t *queue = containerof(pxList, StaticQueue_t, xDummy3[0]);    if(uxQueueGetQueueNumber((QueueHandle_t)queue) == QUEUE_TRACK_FLAG)&#123;        *type = 1;        return queue; // wait tx    &#125;    queue = containerof(pxList, StaticQueue_t, xDummy3[1]);    if(uxQueueGetQueueNumber((QueueHandle_t)queue) == QUEUE_TRACK_FLAG)&#123;        *type = 2;        return queue; // wait rx    &#125;    *type = 3; // unknow    return NULL;&#125;\nvQueueFlagSet()方法需要使用queue的创建HOOK进行调用，这样内核上创建的所有queue都将被打上特殊标记以方便我们跟踪。\n分析队列事件上面得到的仅仅是队列的地址，队列的详细信息其实也能够获取到，包括该队列的类型(一般队列、互斥量、计数信号量、二进制信号量)、等待该队列事件的其它所以任务列表以及该队列内部数据量、数据尺寸的信息等待。方法任然是通过内核上的虚拟数据结构来间接访问。\n利用SP指针回溯调用栈最前面我们获取到了任务的SP地址，这是任务在丢失CPU执行权限后由内核任务调度器更新的最新的SP地址，所以它不是简单的SP指针，因为栈内还有任务调度时保存的数据。\n分析调用栈除了需要实际的sp指针外，还需要最近一次的PC指针、LR指针。内核调度器在最后时刻将R4-R11寄存器、R14寄存器存入了栈内，如果还有浮点数，这还保存了S16-S31这16个浮点数寄存器。\n简单来说，可以简化为两个结构体\ntypedef struct&#123;    uint32_t r4[8];    uint32_t r14;    uint32_t s16[16];    uint32_t r0[4];    uint32_t r12;    uint32_t lr;    uint32_t pc;    uint32_t xPSR;    uint32_t s0[16];    uint32_t fpscr;&#125; rtos_cm7_msp_fp_t;typedef struct&#123;    uint32_t r4[8];    uint32_t r14;    uint32_t r0[4];    uint32_t r12;    uint32_t lr;    uint32_t pc;    uint32_t xPSR;&#125; rtos_cm7_msp_t;\n\n如果存在浮点数则使用rtos_cm7_msp_fp_t，如果不存在浮点数则使用rtos_cm7_msp_t，是否使用浮点数可以使用r14进行判断，这里的r14就是FreeRTOS进行到任务调度时的异常中断中的LR寄存器。有了这个数据结构，再配合栈分析机制就能够非常方便的得到任务的调用栈了。\n总结通过以上的方法，我们就能够非常方便的分析出FreeRTOS运行时的细节信息了，配合日志系统或者shell功能在适当的时候检索出这些信息对分析实时运行过程比较方便。此外，UCOSII等操作系统也能实现类似的操作。\n"},{"title":"Macro returning the number of arguments it is given in C?","url":"/2022/11/12/Macro%20returning%20the%20number%20of%20arguments%20it%20is%20given%20in%20C/","content":"一个简单的实现能否使用一个简单的宏在C语言中计算不定参数的数量，例如这样:\nfoo(1) -&gt; 1foo(cat, dog) -&gt; 2foo(red, green, blue) -&gt; 3\n一个比较简单的实现是这样的：\n#define PP_NARG(...) (sizeof((const void*[])&#123;__VA_ARGS__&#125;)/sizeof(void*))\n当参数为空时可能在某些编译器下不能正常的工作，但是稍微修改一下就行了。\n#define PP_NARG(...) (sizeof((int[])&#123;0, ##__VA_ARGS__&#125;)/sizeof(int) - 1)#pragma GCC diagnostic ignored &quot;-Wint-conversion&quot; /* Ignore warning */\n\n这里使用了sizeof()关键字，就意味着它不是在预处理阶段计算不定参数的长度。同时要求参数必须为有意义的符号。这就限制了它的使用场景，比如说将不定参数的个数作为数组定义时的长度。\n另外一种有趣的写法这是我从网上找到的一种写法，它能够处理1~64个不定产生的情况，没有依赖于编译器的关键字，仅仅靠预处理就完成了参数的计数。\n#ifndef JLSS_ID_NARG_H#define JLSS_ID_NARG_H/*** http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5?pli=1****    Newsgroups: comp.std.c**    From: Laurent Deniau &lt;laurent.deniau@cern.ch&gt;**    Date: Mon, 16 Jan 2006 18:43:40 +0100**    Subject: __VA_NARG__****    A year ago, I was asking here for an equivalent of __VA_NARG__ which**    would return the number of arguments contained in __VA_ARGS__ before its**    expansion. In fact my problem at that time (detecting for a third**    argument) was solved by the solution of P. Mensonides. But I was still**    thinking that the standard should have provided such a facilities rather**    easy to compute for cpp.****    This morning I had to face again the same problem, that is knowing the**    number of arguments contained in __VA_ARGS__ before its expansion (after**    its expansion can always be achieved if you can do it before). I found a**    simple non-iterative solution which may be of interest here as an answer**    to who will ask in the future for a kind of __VA_NARG__ in the standard**    and I post it for archiving. May be some more elegant-efficient solution**    exists?****    Returns NARG, the number of arguments contained in __VA_ARGS__ before**    expansion as far as NARG is &gt;0 and &lt;64 (cpp limits):****    #define PP_NARG( ...) PP_NARG_(__VA_ARGS__,PP_RSEQ_N())**    #define PP_NARG_(...) PP_ARG_N(__VA_ARGS__)**    #define PP_ARG_N(_1,_2,_3,_4,_5,_6,_7,_8,_9,[..],_61,_62,_63,N,...) N**    #define PP_RSEQ_N() 63,62,61,60,[..],9,8,7,6,5,4,3,2,1,0****    [..] stands for the continuation of the sequence omitted here for**    lisibility.****    PP_NARG(A) -&gt; 1**    PP_NARG(A,B) -&gt; 2**    PP_NARG(A,B,C) -&gt; 3**    PP_NARG(A,B,C,D) -&gt; 4**    PP_NARG(A,B,C,D,E) -&gt; 5**    PP_NARG(A1,A2,[..],A62,A63) -&gt; 63**** ======****    Newsgroups: comp.std.c**    From: Roland Illig &lt;roland.il...@gmx.de&gt;**    Date: Fri, 20 Jan 2006 12:58:41 +0100**    Subject: Re: __VA_NARG__****    Laurent Deniau wrote:**    &gt; This morning I had to face again the same problem, that is knowing the**    &gt; number of arguments contained in __VA_ARGS__ before its expansion (after**    &gt; its expansion can always be achieved if you can do it before). I found a**    &gt; simple non-iterative solution which may be of interest here as an answer**    &gt; to who will ask in the future for a kind of __VA_NARG__ in the standard**    &gt; and I post it for archiving. May be some more elegant-efficient solution**    &gt; exists?****    Thanks for this idea. I really like it.****    For those that only want to copy and paste it, here is the expanded version:**** // Some test cases** PP_NARG(A) -&gt; 1** PP_NARG(A,B) -&gt; 2** PP_NARG(A,B,C) -&gt; 3** PP_NARG(A,B,C,D) -&gt; 4** PP_NARG(A,B,C,D,E) -&gt; 5** PP_NARG(1,2,3,4,5,6,7,8,9,0,    //  1..10**         1,2,3,4,5,6,7,8,9,0,    // 11..20**         1,2,3,4,5,6,7,8,9,0,    // 21..30**         1,2,3,4,5,6,7,8,9,0,    // 31..40**         1,2,3,4,5,6,7,8,9,0,    // 41..50**         1,2,3,4,5,6,7,8,9,0,    // 51..60**         1,2,3) -&gt; 63****Note: using PP_NARG() without arguments would violate 6.10.3p4 of ISO C99.*//* The PP_NARG macro returns the number of arguments that have been** passed to it.*/#define PP_NARG(...) \\    PP_NARG_(__VA_ARGS__,PP_RSEQ_N())#define PP_NARG_(...) \\    PP_ARG_N(__VA_ARGS__)#define PP_ARG_N( \\     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\    _61,_62,_63,  N, ...) N#define PP_RSEQ_N() \\    63,62,61,60,                   \\    59,58,57,56,55,54,53,52,51,50, \\    49,48,47,46,45,44,43,42,41,40, \\    39,38,37,36,35,34,33,32,31,30, \\    29,28,27,26,25,24,23,22,21,20, \\    19,18,17,16,15,14,13,12,11,10, \\     9, 8, 7, 6, 5, 4, 3, 2, 1, 0#endif /* JLSS_ID_NARG_H */\n注释中也提到，当参数为空时需要编译器的特殊支持。但是我发现做适当的修改就能够避免这种尴尬的局面。\n#define PP_NARG(...)   (PP_NARG_(0, ##__VA_ARGS__, PP_RSEQ_N()) - 1)\n只要参数不超过64个，它都能很好的工作，而且在预处理阶段就能计算出参数的个数。\n总结我参考了大量其他人的写法，其中的基本原理大都是基于这两种思想。在C++中我还看到其它的解法，但是我目前还没有想到在C++中需要统计不定参数个数的地方。\n#include &lt;tuple&gt;#define MACRO(...) \\    std::cout &lt;&lt;&quot;num args:&quot; \\    &lt;&lt; std::tuple_size&lt;decltype(std::make_tuple(__VA_ARGS__))&gt;::value \\    &lt;&lt; std::endl;/* Another way */#define VA_COUNT(...) detail::va_count(__VA_ARGS__)namespace detail&#123;    template&lt;typename ...Args&gt;    constexpr std::size_t va_count(Args&amp;&amp;...) &#123; return sizeof...(Args); &#125;&#125;\n\n应用能够计算不定参数个数对于实现函数静态优化有一定意义，在代码中判断参数个数调用不同的函数实现，相当于实现了函数多态的一种特性。\n"},{"title":"Black Magic Debug与CMSIS-DAP合体","url":"/2024/10/15/Black%20Magic%20Debug%E4%B8%8ECMSIS-DAP%E5%90%88%E4%BD%93/","content":"移植Black Magic Probe固件虽然BMP官方已经支持了许多的芯片，但是我决定做一些不一样的尝试，我最开始将Black Magic Probe的代码移植到了STM32H750芯片平台上，希望它较高的主频可以实现更快的调试速度。但实际测试下来发现或许是因为相同的USB2.0FS，性能并不比STM32F411平台有特别明显的优势。后来又将其移植到CH32V307平台上，该芯片拥有USB2.0HS接口，传输速度将不是它的性能瓶颈，但是该芯片的主频与F411类似，综合权衡后，我决定采用CH32V307芯片重新设计一版Black Magic Probe。但是正当我把硬件原理图设计完成后，我突然想到一个更合适的选择，那就是RP2040芯片。\n为什么选择RP2040芯片选择它的主要原因是它的PIO模块可以实现较高效率的SWD时序，可以不必依赖与处理器去模拟SWD时序。对于SWD信号的准确性和稳定性都是非常关键的，所以选择RP2040就比较合适。我本来已经完成了SWD时序的PIO代码以及和Black Magic Probe的适配工作，但是我发现树莓派官方推出了基于rp2040芯片的CMSIS-DAP调试器，其中使用PIO完成的SWD时序也比较符合我的预期。所以我决定将Black Magic Probe固件代码移植到rp2040芯片上，并保留CMSIS-DAP调试器的支持,使得一个硬件拥有两种调试能力。\n设计硬件最开始打算使用树莓派官方的Debug Probe硬件，但是60多元的售价将我劝退。而且为了满足Black Magic Probe的一些特殊功能，Debug Probe硬件并不是最理想的硬件。所以我决定自行设计一个硬件。主要是增加3.3V电源输出管理和电源监测功能，需要添加ADC电路和功率开关电路。\n\n主要的外围接口和我上一个制作的Black Magic Probe保持相同的接口布局。原理图可参考树莓派的Debug Probe。\n硬件上添加了一个拨动开关，可以用于控制3.3V的电源的输出，3.3V的电源输出也可以由BMP软件控制打开。\n让我感到非常意外的是RP2040的ADC性能不太理想，采样时间固定到了2us，没有调整的空间。手册上说ADC的输入阻抗可达100kΩ，但实际我使用100kΩ加47kΩ的分压电路都导致ADC测量结果严重偏低(偏低0.15v)，最终我将分压电阻的值缩小了10倍后ADC的测量结果才有所好转。如果采样时间可以修改或许可以提高采样精度。\n除PCB成本外，元器件的成本约20元。\n代码完整的代码已经放到github。\n代码采用rp2040芯片最新的2.0版SDK，构建工具依赖的picotools已经生成了一个Windows的本地版本。如果你在Windows下进行rp2040芯片软件开发，这个二进制版本的picotools将对你有一定帮助。构建这个Win版本的picotools有许多曲折的经历，不过最后还是弄好了，不然的话只能转向Linux开发了。\n代码在树莓派debugprobe固件的基础上移植了比较完整的Black Magic Probe固件(除了BMP-bootloader)。JTAG调试接口由于原版树莓派没有支持，所以BMP上的JTAG adapter还未完成。\n该版本的BMP相比于其它版本有一些优点，准确且高效的SWD时序模拟，时钟频率理论可达30MHz，时序由PIO驱动，时钟精度比较高。相比于采用处理器模拟SWD时序，它的时钟稳定性更佳。使用逻辑分析仪测量波形：\n\n从图中可以看到CLK时序还算比较规整。由于在底层设计中PIO需要和处理器做同步交互，使得在SWD时序中CMD-ACK-DATA之间存在不可避免的时序空闲时间。\n下面看看STM32F411使用指令模拟SWD时序的波形：\n\n可以看出CLK的占空比不稳定，这种现象称为时钟抖动(Jitter)，它主要影响信号的采样过程，过大的抖动可能导致传输误码。\n该版本代码还有一些其它优化，重构了cdc-uart的代码，串口改为DMA驱动，配合应用层的FIFO，实现了串口驱动到USB协议栈之间数据的零拷贝。\n此外，为了实现debugprobe代码和BMP的代码同时运行，debugprobe代码在保证功能性的前提下做了一些细节部分的调整，具体内容可以参考代码提交记录。\n我还启用了FreeRTOS的多核特性，以充分利用rp2040的2个核心。这部分代码还未提交，我还需要进一步测试。\nPIO驱动SWD原理先给出Raspberrypi的PIO代码，如果对PIO还不够深入了解可以看看我之前的文章。\n.program probe.side_set 1 optpublic write_cmd:public turnaround_cmd:                      ; Alias of write, used for probe_oen.pio    pullwrite_bitloop:    out pins, 1             [1]  side 0x0   ; Data is output by host on negedge    jmp x-- write_bitloop   [1]  side 0x1   ; ...and captured by target on posedge                                            ; Fall through to next command.wrap_targetpublic get_next_cmd:    pull                         side 0x0   ; SWCLK is initially low    out x, 8                                ; Get bit count    out pindirs, 1                          ; Set SWDIO direction    out pc, 5                               ; Go to command routineread_bitloop:    nop                                     ; Additional delay on taken loop branchpublic read_cmd:    in pins, 1              [1]  side 0x1   ; Data is captured by host on posedge    jmp x-- read_bitloop         side 0x0    push.wrap                                       ; Wrap to next command\n\n代码非常简短，共11条指令。代码的入口在get_next_cmd，从输入fifo中得到需要执行的指令，执行分为4种(读、写、next、turnaround)，读和写就是构建基本的数据传输波形，next相当于一条nop指令，但是可以用于直接切换DIO的方向，turnaround将产生一个额外的时钟周期并切换DIO方向。\n处理器将指令偏移压入fifo中，pio将fifo中的数据放入到pc寄存器实现指令的跳转。\nPIO练习在使用debugprobe的代码之前，我自己练习写了一份SWD的时序代码，该代码的优点是在数据传输过程中自动进行DIO的方向切换不需要单独占用一个fifo空间。该代码需要较多的指令空间，由于篇幅有限且代码质量一般，这里仅列出in时序相关内容。\n.program swdptap_seq_in.side_set 1 opt.wrap_targetstart:    pull            ; 获取待处理的数据    out x, 1        ; 检查是否需要Trn切换    jmp !x no_turnaround    set pindirs 0 side 1 [1] ; 切换DIO到输入模式no_turnaround:    out x, 5        ; 获取输入数据长度    out y, 1        ; 是否获取校验位    jmp loop2loop:    nop [3]loop2:    in pins, 1    side 0 [4]    jmp x-- loop  side 1    push                     ; 将采集到的数据写入FIFO    jmp !y start             ; 如果y==0则不校验返回到起始位置    nop [1]    in pins, 1    side 0 [4] ; 获取校验信息    nop           side 1 [4] ; 一个Trn周期    set pindirs 1 side 0     ; 切换DIO到输出模式    push                     ; 将校验bit写入FIFO.wrap% c-sdk &#123;#include &quot;hardware/clocks.h&quot;#include &quot;hardware/gpio.h&quot;static inline void swdptap_seq_in_program_init(PIO pio, uint sm, uint offset, uint pin_swclk, uint pin_swdio, uint freq)&#123;    pio_gpio_init(pio, pin_swclk);    pio_gpio_init(pio, pin_swdio);    pio_sm_set_pindirs_with_mask(pio, sm, (1u &lt;&lt; pin_swclk), (1u &lt;&lt; pin_swclk));    pio_sm_set_pindirs_with_mask(pio, sm, 0, (1u &lt;&lt; pin_swdio));    pio_sm_config c = swdptap_seq_in_program_get_default_config(offset);    sm_config_set_in_pins(&amp;c, pin_swdio);    sm_config_set_sideset_pins(&amp;c, pin_swclk);    sm_config_set_set_pins(&amp;c, pin_swdio, 1);    sm_config_set_fifo_join(&amp;c, PIO_FIFO_JOIN_NONE);    float div = (float)clock_get_hz(clk_sys) / (freq * 2) / 5;    sm_config_set_clkdiv(&amp;c, div);    sm_config_set_out_shift(&amp;c, true, false, 8);    sm_config_set_in_shift(&amp;c, true, false, 32);    pio_sm_init(pio, sm, offset, &amp;c);    pio_sm_set_enabled(pio, sm, true);&#125;%&#125;\n\nuint32_t swdptap_seq_in(size_t clock_cycles)&#123;    if(clock_cycles == 0)&#123;        return 0;    &#125;    int ret;    ret = cros_sem_pend(swdptap_lock, 1000u);    if(ret)&#123;        return 0;    &#125;    uint32_t has_trn = 0;    if(dio_dir != SWDIO_STATUS_FLOAT)&#123;        dio_dir = SWDIO_STATUS_FLOAT;        has_trn = 1;    &#125;    if(seq_out_count &gt; 0)&#123;        pio_sm_get_blocking(SWD_PIO, SWD_OUT_SM);        seq_out_count--;    &#125;        pio_sm_put_blocking(SWD_PIO, SWD_IN_SM, has_trn | ((clock_cycles - 1) &lt;&lt; 1));    ret = pio_sm_get_blocking(SWD_PIO, SWD_IN_SM) &gt;&gt; (32U - clock_cycles);    cros_sem_post(swdptap_lock);    return ret;&#125;bool swdptap_seq_in_parity(uint32_t *ret, size_t clock_cycles)&#123;    if(clock_cycles == 0)&#123;        return false;    &#125;    if(cros_sem_pend(swdptap_lock, 1000u))&#123;        return false;    &#125;    uint32_t has_trn = 0;    if(dio_dir != SWDIO_STATUS_FLOAT)&#123;        dio_dir = SWDIO_STATUS_FLOAT;        has_trn = 1;    &#125;    if(seq_out_count &gt; 0)&#123;        pio_sm_get_blocking(SWD_PIO, SWD_OUT_SM);        seq_out_count--;    &#125;    pio_sm_put_blocking(SWD_PIO, SWD_IN_SM, has_trn | ((clock_cycles - 1) &lt;&lt; 1) | (1 &lt;&lt; 6));    uint32_t value = pio_sm_get_blocking(SWD_PIO, SWD_IN_SM) &gt;&gt; (32U - clock_cycles);    uint32_t parity = pio_sm_get_blocking(SWD_PIO, SWD_IN_SM) &gt;&gt; 31;    dio_dir = SWDIO_STATUS_DRIVE;    cros_sem_post(swdptap_lock);    *ret = value;    return __builtin_parity(value) == parity;&#125;\n\n该代码完成的时序效果如下，可以得到更紧凑的CLK波形，CLK空闲时间更短。\n\n一个额外的软件很多人喜欢Jlink除了它性能强大外，还因为它用于丰富的上位机软件支持，比如J-Flash，实现固件烧录比较方便。对于CMSIS-DAP来说，上位机软件选择似乎不多，除了IDE内部集成外，只有openocd这个选择。但是openocd没有官方支持的GUI程序，使用命令行在一些效率上还是不及J-Flash这种图形界面来的方便，毕竟openocd的命令太多了。\n所以我开发了一个用于CMSIS-DAP的上位机工具叫DFlash，支持大部分Cortex单片机(底层采用openocd，所以就是openocd支持的芯片)。支持固件的上传和下载，支持elf、hex、bin文件，可以显示文件的二进制数据视图。文件支持拖拽打开，大部分逻辑和jflash类似。打开bin文件时会弹出对话框提示输入下载地址，hex和elf文件可以自动识别下载地址。\n支持v1和v2版本的CMSIS-DAP，可以搜索本机连接的多个CMSIS-DAP，并选择下载器。\n\n目前软件的主要功能已经完成，还需要添加unlock等chip操作功能。此外还需要完善下载进度和UI上的一些调整。\n功能完善后会发布并开源该软件。\n"},{"title":"PT协程的一个小扩展","url":"/2023/08/28/PT%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%89%A9%E5%B1%95/","content":"在之前的文章中介绍了使用链表来更加优雅的使用PT协程。我最近发现了当初实现的一个错误，现在已经修复了。\n这里不是为了讨论之前的实现，而是介绍一个更有意思的东西。我在之前的实现基础上，实现了一个更加优雅的函数来利用协程，这应该是一种异步编程的技巧，或者说这是C语言的花活😂。\nShow code!\n/** * Declare a pt thread in a simple way. *  * Example usage: * @code&#123;c&#125; * PT_THREAD_DECL(thread1, &#123; *     while(1)&#123; *         printf(&quot;hello pt!\\r\\n&quot;); *         OS_TASK_DELAY(pt, 100); *     &#125; * &#125;); *  * // OS_TASK_RUN(thread1); * @endcode */#define PT_THREAD_DECL(name, body) \\    PT_THREAD(name(struct pt *pt))&#123;PT_BEGIN(pt);PT_YIELD(pt);body;PT_END(pt);&#125;/**  * Asynchronous execution. Only used in threads, similar to OS_TASK_DELAY() function. *  * Example usage: * @code&#123;c&#125; * PT_THREAD_DECL(invok_test, &#123; *     static int cnt; *  *     cnt = 0; *  *     PT_INVOK(&#123; *         static int i; *         for(i = 0; i &lt; 10; i++)&#123; *             printf(&quot;async invok %d\\r\\n&quot;, i); *             cnt += i; *             OS_TASK_DELAY(pt, 1000); *         &#125; *         // Automatically exit this asynchrony at end of PT_INVOK(); *     &#125;); *  *     PT_INVOK(&#123; *         while(1)&#123; *             printf(&quot;hello invok, cnt = %d\\r\\n&quot;, cnt); *             OS_TASK_DELAY(pt, 300); *         &#125; *     &#125;); * &#125;); *  * // OS_TASK_RUN(invok_test); * @endcode */#define PT_INVOK(body)                             \\    do                                             \\    &#123;                                              \\        static pt_item_t pt_invok;                 \\        static char pt_anchor;                     \\        pt_invok.task =                            \\            containerof(pt, pt_item_t, pt)-&gt;task;  \\        list_add_head(&amp;pt_pool, &amp;(pt_invok.list)); \\        pt_anchor = 0;                             \\        LC_SET(pt_invok.pt.lc);                    \\        if (pt_anchor)                             \\        &#123;                                          \\            body;                                  \\            PT_EXIT(pt);                           \\        &#125;                                          \\        pt_anchor = 1;                             \\    &#125; while (0)\n\nPT_INVOK可以在不阻塞当前函数执行流程的情况下，从原地开辟出一个并行的执行流，有意思的一点是多个INVOK执行流之间是可以共享上层局部变量的，这就实现了多个执行流之间的通信或同步。\n这个宏扩展看起来相当的有用，它解决了编程中一个常见的问题，即在一个不能被阻塞的执行流程中执行一个耗时的操作。\nPT协程的实现本身就是一个很花哨东西，这个宏定义成功的把C语言的宏用法上升到了一个新的高度。我怀疑某些编译器根本不能处理这段代码😅。\n这里需要注意，PT_INVOK内的代码不能重入，或者说PT_INVOK内的代码还未执行完成时，不能再次在这里执行同一段PT_INVOK，这是代码的静态性导致的。如果有重入的风险，可以在外部添加一些重入保护的机制。\n"},{"title":"Recommended C style and coding rules","url":"/2021/01/21/Recommended%20C%20style%20and%20coding%20rules/","content":"This document describes C code style used by Tilen MAJERLE in his projects and libraries.\nTable of Contents\nThe single most important rule\nRecommended C style and coding rules\nGeneral rules\nComments\nFunctions\nVariables\nStructures, enumerations, typedefs\nCompound statements\nSwitch statement\n\n\nMacros and preprocessor directives\nDocumentation\nHeader&#x2F;source files\nArtistic Style configuration\nEclipse formatter\n\nThe single most important ruleLet’s start with the quote from GNOME developer site.\n\nThe single most important rule when writing code is this: check the surrounding code and try to imitate it.\nAs a maintainer it is dismaying to receive a patch that is obviously in a different coding style to the surrounding code. This is disrespectful, like someone tromping into a spotlessly-clean house with muddy shoes.\nSo, whatever this document recommends, if there is already written code and you are patching it, keep its current style consistent even if it is not your favorite style.\n\nGeneral rulesHere are listed most obvious and important general rules. Please check them carefully before you continue with other chapters.\n\nUse C99 standard\n\nDo not use tabs, use spaces instead\n\nUse 4 spaces per indent level\n\nUse 1 space between keyword and opening bracket\n\nDo not use space between function name and opening bracket\nint32_t a = sum(4, 3);              /* OK */int32_t a = sum (4, 3);             /* Wrong */\n\nNever use __ or _ prefix for variables&#x2F;functions&#x2F;macros&#x2F;types. This is reserved for C language itself\n\nPrefer prv_ name prefix for strictly module-private functions\n\n\nUse only lowercase characters for variables&#x2F;functions&#x2F;macros&#x2F;types with optional underscore _ char\n\nOpening curly bracket is always at the same line as keyword (for, while, do, switch, if, …)\nsize_t i;for (i = 0; i &lt; 5; ++i) &#123;           /* OK */&#125;for (i = 0; i &lt; 5; ++i)&#123;            /* Wrong */&#125;for (i = 0; i &lt; 5; ++i)             /* Wrong */&#123;&#125;\n\nUse single space before and after comparison and assignment operators\nint32_t a;a = 3 + 4;              /* OK */for (a = 0; a &lt; 5; ++a) /* OK */a=3+4;                  /* Wrong */a = 3+4;                /* Wrong */for (a=0;a&lt;5;++a)       /* Wrong */\n\nUse single space after every comma\nfunc_name(5, 4);        /* OK */func_name(4,3);         /* Wrong */\n\nDo not initialize static and global variables to 0 (or NULL), let compiler do it for you\nstatic int32_t a;       /* OK */static int32_t b = 4;   /* OK */static int32_t a = 0;   /* Wrong */voidmy_func(void) &#123;    static int32_t* ptr;/* OK */    static char abc = 0;/* Wrong */&#125;\n\nDeclare all local variables of the same type in the same line\nvoidmy_func(void) &#123;    char a;             /* OK */    char a, b;          /* OK */    char b;             /* Wrong, variable with char type already exists */&#125;\n\nDeclare local variables in order\n\nCustom structures and enumerations\nInteger types, wider unsigned type first\nSingle&#x2F;Double floating pointintmy_func(void) &#123;    /* 1 */    my_struct_t my;     /* First custom structures */    my_struct_ptr_t* p; /* Pointers too */    /* 2 */    uint32_t a;    int32_t b;    uint16_t c;    int16_t g;    char h;    /* ... */    /* 3 */    double d;    float f;&#125;\n\n\nAlways declare local variables at the beginning of the block, before first executable statement\n\nDeclare counter variables in for loop\n/* OK */for (size_t i = 0; i &lt; 10; ++i)/* OK, if you need counter variable later */size_t i;for (i = 0; i &lt; 10; ++i) &#123;    if (...) &#123;        break;    &#125;&#125;if (i == 10) &#123;&#125;/* Wrong */size_t i;for (i = 0; i &lt; 10; ++i) ...\n\nAvoid variable assignment with function call in declaration, except for single variables\nvoida(void) &#123;    /* Avoid function calls when declaring variable */    int32_t a, b = sum(1, 2);    /* Use this */    int32_t a, b;    b = sum(1, 2);    /* This is ok */    uint8_t a = 3, b = 4;&#125;\n\nExcept char, float or double, always use types declared in stdint.h library, eg. uint8_t for unsigned 8-bit, etc.\n\nDo not use stdbool.h library. Use 1 or 0 for true or false respectively\n/* OK */uint8_t status;status = 0;/* Wrong */#include &lt;stdbool.h&gt;bool status = true;\n\nNever compare against true, eg. if (check_func() == 1), use if (check_func()) &#123; ... &#125;\n\nAlways compare pointers against NULL value\nvoid* ptr;/* ... *//* OK, compare against NULL */if (ptr == NULL || ptr != NULL) &#123;&#125;/* Wrong */if (ptr || !ptr) &#123;&#125;\n\nAlways use pre-increment (and decrement respectively) instead of post-increment (and decrement respectively)\nint32_t a = 0;...a++;            /* Wrong */++a;            /* OK */for (size_t j = 0; j &lt; 10; ++j) &#123;&#125;  /* OK */\n\nAlways use size_t for length or size variables\n\nAlways use const for pointer if function should not modify memory pointed to by pointer\n\nAlways use const for function parameter or variable, if it should not be modified\n/* When d could be modified, data pointed to by d could not be modified */voidmy_func(const void* d) &#123;&#125;/* When d and data pointed to by d both could not be modified */voidmy_func(const void* const d) &#123;&#125;/* Not required, it is advised */voidmy_func(const size_t len) &#123;&#125;/* When d should not be modified inside function, only data pointed to by d could be modified */voidmy_func(void* const d) &#123;&#125;\n\nWhen function may accept pointer of any type, always use void *, do not use uint8_t *\n\nFunction must take care of proper casting in implementation/* * To send data, function should not modify memory pointed to by `data` variable * thus `const` keyword is important * * To send generic data (or to write them to file) * any type may be passed for data, * thus use `void *` *//* OK example */voidsend_data(const void* data, size_t len) &#123; /* OK */    /* Do not cast `void *` or `const void *` */    const uint8_t* d = data;/* Function handles proper type for internal usage */&#125;voidsend_data(const void* data, int len) &#123;    /* Wrong, not not use int */&#125;\n\n\nAlways use brackets with sizeof operator\n\nNever use Variable Length Array (VLA). Use dynamic memory allocation instead with standard C malloc and free functions or if library&#x2F;project provides custom memory allocation, use its implementation\n\nTake a look at LwMEM, custom memory management library/* OK */#include &lt;stdlib.h&gt;voidmy_func(size_t size) &#123;    int32_t* arr;    arr = malloc(sizeof(*arr) * n); /* OK, Allocate memory */    arr = malloc(sizeof *arr * n);  /* Wrong, brackets for sizeof operator are missing */    if (arr == NULL) &#123;        /* FAIL, no memory */    &#125;    free(arr);  /* Free memory after usage */&#125;/* Wrong */voidmy_func(size_t size) &#123;    int32_t arr[size];  /* Wrong, do not use VLA */&#125;\n\n\nAlways compare variable against zero, except if it is treated as boolean type\n\nNever compare boolean-treated variables against zero or one. Use NOT (!) instead\nsize_t length = 5;  /* Counter variable */uint8_t is_ok = 0;  /* Boolean-treated variable */if (length)         /* Wrong, length is not treated as boolean */if (length &gt; 0)     /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (length == 0)    /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (is_ok)          /* OK, variable is treated as boolean */if (!is_ok)         /* OK, -||- */if (is_ok == 1)     /* Wrong, never compare boolean variable against 1! */if (is_ok == 0)     /* Wrong, use ! for negative check */\n\nAlways use /* comment */ for comments, even for single-line comment\n\nAlways include check for C++ with extern keyword in header file\n\nEvery function must include doxygen-enabled comment, even if function is static\n\nUse English names&#x2F;text for functions, variables, comments\n\nUse lowercase characters for variables\n\nUse underscore if variable contains multiple names, eg. force_redraw. Do not use forceRedraw\n\nNever cast function returning void *, eg. uint8_t* ptr = (uint8_t *)func_returning_void_ptr(); as void * is safely promoted to any other pointer type\n\nUse uint8_t* ptr = func_returning_void_ptr(); instead\n\n\nAlways use &lt; and &gt; for C Standard Library include files, eg. #include &lt;stdlib.h&gt;\n\nAlways use &quot;&quot; for custom libraries, eg. #include &quot;my_library.h&quot;\n\nWhen casting to pointer type, always align asterisk to type, eg. uint8_t* t = (uint8_t*)var_width_diff_type\n\nAlways respect code style already used in project or library\n\n\nComments\nComments starting with // are not allowed. Always use /* comment */, even for single-line comment\n//This is comment (wrong)/* This is comment (ok) */\n\nFor multi-line comments use space+asterisk for every line\n/* * This is multi-line comments, * written in 2 lines (ok) *//** * Wrong, use double-asterisk only for doxygen documentation *//** Single line comment without space before asterisk (wrong)*//* * Single line comment in multi-line configuration (wrong) *//* Single line comment (ok) */\n\nUse 12 indents (12 * 4 spaces) offset when commenting. If statement is larger than 12 indents, make comment 4-spaces aligned (examples below) to next available indent\nvoidmy_func(void) &#123;    char a, b;    a = call_func_returning_char_a(a);          /* This is comment with 12*4 spaces indent from beginning of line */    b = call_func_returning_char_a_but_func_name_is_very_long(a);   /* This is comment, aligned to 4-spaces indent */&#125;\n\nFunctions\nEvery function which may have access from outside its module, must include function prototype (or declaration)\n\nFunction name must be lowercase, optionally separated with underscore _ character\n/* OK */void my_func(void);void myfunc(void);/* Wrong */void MYFunc(void);void myFunc();\n\nWhen function returns pointer, align asterisk to return type\n/* OK */const char* my_func(void);my_struct_t* my_func(int32_t a, int32_t b);/* Wrong */const char *my_func(void);my_struct_t * my_func(void);\nAlign all function prototypes (with the same&#x2F;similar functionality) for better readability\n/* OK, function names aligned */void        set(int32_t a);my_type_t   get(void);my_ptr_t*   get_ptr(void);/* Wrong */void set(int32_t a);const char * get(void);\n\nFunction implementation must include return type and optional other keywords in separate line\n/* OK */int32_tfoo(void) &#123;    return 0;&#125;/* OK */static const char*get_string(void) &#123;    return &quot;Hello world!\\r\\n&quot;;&#125;/* Wrong */int32_t foo(void) &#123;    return 0;&#125;\n\nWhen function returns pointer, asterisk character must be aligned to return type (char*)\n/* OK */const char*foo(void) &#123;    return &quot;test&quot;;&#125;/* Wrong */const char*foo(void) &#123;    return &quot;test&quot;;&#125;\n\nVariables\nMake variable name all lowercase with optional underscore _ character\n/* OK */int32_t a;int32_t my_var;int32_t myvar;/* Wrong */int32_t A;int32_t myVar;int32_t MYVar;\n\nGroup local variables together by type\nvoidfoo(void) &#123;    int32_t a, b;   /* OK */    char a;    char b;         /* Wrong, char type already exists */&#125;\n\nDo not declare variable after first executable statement\nvoidfoo(void) &#123;    int32_t a;    a = bar();    int32_t b;      /* Wrong, there is already executable statement */&#125;\n\nYou may declare new variables inside next indent level\nint32_t a, b;a = foo();if (a) &#123;    int32_t c, d;   /* OK, c and d are in if-statement scope */    c = foo();    int32_t e;      /* Wrong, there was already executable statement inside block */&#125;\n\nDeclare pointer variables with asterisk aligned to type\n/* OK */char* a;/* Wrong */char *a;char * a;\n\nWhen declaring multiple pointer variables, you may declare them with asterisk aligned to variable name\n/* OK */char *p, *n;\n\nStructures, enumerations, typedefs\nStructure or enumeration name must be lowercase with optional underscore _ character between words\nStructure or enumeration may contain typedef keyword\nAll structure members must be lowercase\nAll enumeration members must be uppercase\nStructure&#x2F;enumeration must follow doxygen documentation syntax\n\nWhen structure is declared, it may use one of 3 different options:\n\nWhen structure is declared with name only, it must not contain _t suffix after its name.struct struct_name &#123;    char* a;    char b;&#125;;\nWhen structure is declared with typedef only, it has to contain _t suffix after its name.typedef struct &#123;    char* a;    char b;&#125; struct_name_t;\nWhen structure is declared with name and typedef, it must not contain _t for basic name and it has to contain _t suffix after its name for typedef part.typedef struct struct_name &#123;    char* a;    char b;    char c;&#125; struct_name_t;\n\nExamples of bad declarations and their suggested corrections\n/* a and b must be separated to 2 lines *//* Name of structure with typedef must include _t suffix */typedef struct &#123;    int32_t a, b;&#125; a;/* Corrected version */typedef struct &#123;    int32_t a;    int32_t b;&#125; a_t;/* Wrong name, it must not include _t suffix */struct name_t &#123;    int32_t a;    int32_t b;&#125;;/* Wrong parameters, must be all uppercase */typedef enum &#123;    MY_ENUM_TESTA,    my_enum_testb,&#125; my_enum_t;\n\n\nWhen initializing structure on declaration, use C99 initialization style\n/* OK */a_t a = &#123;    .a = 4,    .b = 5,&#125;;/* Wrong */a_t a = &#123;1, 2&#125;;\n\nWhen new typedef is introduced for function handles, use _fn suffix\n/* Function accepts 2 parameters and returns uint8_t *//* Name of typedef has `_fn` suffix */typedef uint8_t (*my_func_typedef_fn)(uint8_t p1, const char* p2);\n\nCompound statements\nEvery compound statement must include opening and closing curly bracket, even if it includes only 1 nested statement\n\nEvery compound statement must include single indent; when nesting statements, include 1 indent size for each nest\n/* OK */if (c) &#123;    do_a();&#125; else &#123;    do_b();&#125;/* Wrong */if (c)    do_a();else    do_b();/* Wrong */if (c) do_a();else do_b();\n\nIn case of if or if-else-if statement, else must be in the same line as closing bracket of first statement\n/* OK */if (a) &#123;&#125; else if (b) &#123;&#125; else &#123;&#125;/* Wrong */if (a) &#123;&#125;else &#123;&#125;/* Wrong */if (a) &#123;&#125;else&#123;&#125;\n\nIn case of do-while statement, while part must be in the same line as closing bracket of do part\n/* OK */do &#123;    int32_t a;    a = do_a();    do_b(a);&#125; while (check());/* Wrong */do&#123;/* ... */&#125; while (check());/* Wrong */do &#123;/* ... */&#125;while (check());\n\nIndentation is required for every opening bracket\nif (a) &#123;    do_a();&#125; else &#123;    do_b();    if (c) &#123;        do_c();    &#125;&#125;\n\nNever do compound statement without curly bracket, even in case of single statement. Examples below show bad practices\nif (a) do_b();else do_c();if (a) do_a(); else do_b();\n\nEmpty while, do-while or for loops must include brackets\n/* OK */while (is_register_bit_set()) &#123;&#125;/* Wrong */while (is_register_bit_set());while (is_register_bit_set()) &#123; &#125;while (is_register_bit_set()) &#123;&#125;\n\nIf while (or for, do-while, etc) is empty (it can be the case in embedded programming), use empty single-line brackets\n/* Wait for bit to be set in embedded hardware unituint32_t* addr = HW_PERIPH_REGISTER_ADDR;/* Wait bit 13 to be ready */while (*addr &amp; (1 &lt;&lt; 13)) &#123;&#125;        /* OK, empty loop contains no spaces inside curly brackets */while (*addr &amp; (1 &lt;&lt; 13)) &#123; &#125;       /* Wrong */while (*addr &amp; (1 &lt;&lt; 13)) &#123;         /* Wrong */&#125;while (*addr &amp; (1 &lt;&lt; 13));          /* Wrong, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */\nAlways prefer using loops in this order: for, do-while, while\n\nAvoid incrementing variables inside loop block if possible, see examples\n\n\n/* Not recommended */int32_t a = 0;while (a &lt; 10) &#123;    .    ..    ...    ++a;&#125;/* Better */for (size_t a = 0; a &lt; 10; ++a) &#123;&#125;/* Better, if inc may not happen in every cycle */for (size_t a = 0; a &lt; 10; ) &#123;    if (...) &#123;        ++a;    &#125;&#125;\n\nSwitch statement\nAdd single indent for every case statement\n\nUse additional single indent for break statement in each case or default\n/* OK, every case has single indent *//* OK, every break has additional indent */switch (check()) &#123;    case 0:        do_a();        break;    case 1:        do_b();        break;    default:        break;&#125;/* Wrong, case indent missing */switch (check()) &#123;case 0:    do_a();    break;case 1:    do_b();    break;default:    break;&#125;/* Wrong */switch (check()) &#123;    case 0:        do_a();    break;      /* Wrong, break must have indent as it is under case */    case 1:    do_b();     /* Wrong, indent under case is missing */    break;    default:        break;&#125;\n\nAlways include default statement\n/* OK */switch (var) &#123;    case 0:        do_job();        break;    default: break;&#125;/* Wrong, default is missing */switch (var) &#123;    case 0:        do_job();        break;&#125;\n\nIf local variables are required, use curly brackets and put break statement inside.\n\nPut opening curly bracket in the same line as case statementswitch (a) &#123;    /* OK */    case 0: &#123;        int32_t a, b;        char c;        a = 5;        /* ... */        break;    &#125;    /* Wrong */    case 1:    &#123;        int32_t a;        break;    &#125;    /* Wrong, break shall be inside */    case 2: &#123;        int32_t a;    &#125;    break;&#125;\n\n\n\nMacros and preprocessor directives\nAlways use macros instead of literal constants, specially for numbers\n\nAll macros must be fully uppercase, with optional underscore _ character, except if they are clearly marked as function which may be in the future replaced with regular function syntax\n/* OK */#define MY_MACRO(x)         ((x) * (x))/* Wrong */#define square(x)           ((x) * (x))\n\nAlways protect input parameters with parentheses\n/* OK */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))/* Wrong */#define MIN(x, y)           x &lt; y ? x : y\n\nAlways protect final macro evaluation with parenthesis\n/* Wrong */#define MIN(x, y)           (x) &lt; (y) ? (x) : (y)#define SUM(x, y)           (x) + (y)/* Imagine result of this equation using wrong SUM implementation */int32_t x = 5 * SUM(3, 4);  /* Expected result is 5 * 7 = 35 */int32_t x = 5 * (3) + (4);  /* It is evaluated to this, final result = 19 which is not what we expect *//* Correct implementation */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))#define SUM(x, y)           ((x) + (y))\n\nWhen macro uses multiple statements, protect it using do-while (0) statement\ntypedef struct &#123;    int32_t px, py;&#125; point_t;point_t p;                  /* Define new point *//* Wrong implementation *//* Define macro to set point */#define SET_POINT(p, x, y)  (p)-&gt;px = (x); (p)-&gt;py = (y)    /* 2 statements. Last one should not implement semicolon */SET_POINT(&amp;p, 3, 4);        /* Set point to position 3, 4. This evaluates to... */(&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); /* ... to this. In this example this is not a problem. *//* Consider this ugly code, however it is valid by C standard (not recommended) */if (a)                      /* If a is true */    if (b)                  /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    else        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 *//* Evaluates to code below. Do you see the problem? */if (a)    if (b)        (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6);/* Or if we rewrite it a little */if (a)    if (b)        (&amp;p)-&gt;px = (3);        (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5);        (&amp;p)-&gt;py = (6);/* * Ask yourself a question: To which `if` statement `else` keyword belongs? * * Based on first part of code, answer is straight-forward. To inner `if` statement when we check `b` condition * Actual answer: Compilation error as `else` belongs nowhere *//* Better and correct implementation of macro */#define SET_POINT(p, x, y)  do &#123; (p)-&gt;px = (x); (p)-&gt;py = (y); &#125; while (0)    /* 2 statements. No semicolon after while loop *//* Or even better */#define SET_POINT(p, x, y)  do &#123;    \\   /* Backslash indicates statement continues in new line */    (p)-&gt;px = (x);                  \\    (p)-&gt;py = (y);                  \\&#125; while (0)                             /* 2 statements. No semicolon after while loop *//* Now original code evaluates to */if (a)    if (b)        do &#123; (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); &#125; while (0);    else        do &#123; (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); &#125; while (0);/* Every part of `if` or `else` contains only `1` inner statement (do-while), hence this is valid evaluation *//* To make code perfect, use brackets for every if-ifelse-else statements */if (a) &#123;                    /* If a is true */    if (b) &#123;                /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    &#125; else &#123;        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 */    &#125;&#125;\n\nAlways write macro documentation as regular function with additional hideinitializer doxygen keyword\n#define MY_MACRO(x)         ((x) * 2)\n\nAvoid using #ifdef or #ifndef. Use defined() or !defined() instead\n#ifdef XYZ/* do something */#endif /* XYZ */\n\nAlways document if/elif/else/endif statements\n/* OK */#if defined(XYZ)/* Do if XYZ defined */#else /* defined(XYZ) *//* Do if XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)/* Do if XYZ defined */#else/* Do if XYZ not defined */#endif\n\nDo not indent sub statements inside #if statement\n/* OK */#if defined(XYZ)#if defined(ABC)/* do when ABC defined */#endif /* defined(ABC) */#else /* defined(XYZ) *//* Do when XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)    #if defined(ABC)        /* do when ABC defined */    #endif /* defined(ABC) */#else /* defined(XYZ) */    /* Do when XYZ not defined */#endif /* !defined(XYZ) */\n\nDocumentationDocumented code allows doxygen to parse and general html&#x2F;pdf&#x2F;latex output, thus it is very important to do it properly.\n\nUse doxygen-enabled documentation style for variables, functions and structures/enumerations\n\nAlways use \\ for doxygen, do not use @\n\nAlways use 5x4 spaces (5 tabs) offset from beginning of line for text\n/** * \\brief           Holds pointer to first entry in linked list *                  Beginning of this text is 5 tabs (20 spaces) from beginning of line */statictype_t* list;\n\nEvery structure&#x2F;enumeration member must include documentation\n\nUse 12x4 spaces offset for beginning of comment\n/** * \\brief           This is point struct * \\note            This structure is used to calculate all point *                      related stuff */typedef struct &#123;    int32_t x;                                  /*!&lt; Point X coordinate */    int32_t y;                                  /*!&lt; Point Y coordinate */    int32_t size;                               /*!&lt; Point size.                                                    Since comment is very big,                                                    you may go to next line */&#125; point_t;/** * \\brief           Point color enumeration */typedef enum &#123;    COLOR_RED,                                  /*!&lt; Red color. This comment has 12x4                                                    spaces offset from beginning of line */    COLOR_GREEN,                                /*!&lt; Green color */    COLOR_BLUE,                                 /*!&lt; Blue color */&#125; point_color_t;\n\nDocumentation for functions must be written in function implementation (source file usually)\n\nFunction must include brief and all parameters documentation\n\nEvery parameter must be noted if it is in or out for input and output respectively\n\nFunction must include return parameter if it returns something. This does not apply for void functions\n\nFunction can include other doxygen keywords, such as note or warning\n\nUse colon : between parameter name and its description\n/** * \\brief           Sum `2` numbers * \\param[in]       a: First number * \\param[in]       b: Second number * \\return          Sum of input values */int32_tsum(int32_t a, int32_t b) &#123;    return a + b;&#125;/** * \\brief           Sum `2` numbers and write it to pointer * \\note            This function does not return value, it stores it to pointer instead * \\param[in]       a: First number * \\param[in]       b: Second number * \\param[out]      result: Output variable used to save result */voidvoid_sum(int32_t a, int32_t b, int32_t* result) &#123;    *result = a + b;&#125;\n\nIf function returns member of enumeration, use ref keyword to specify which one\n/** * \\brief           My enumeration */typedef enum &#123;    MY_ERR,                                     /*!&lt; Error value */    MY_OK                                       /*!&lt; OK value */&#125; my_enum_t;/** * \\brief           Check some value * \\return          \\ref MY_OK on success, member of \\ref my_enum_t otherwise */my_enum_tcheck_value(void) &#123;    return MY_OK;&#125;\n\nUse notation (`NULL` &#x3D;&gt; NULL) for constants or numbers\n/** * \\brief           Get data from input array * \\param[in]       in: Input data * \\return          Pointer to output data on success, `NULL` otherwise */const void *get_data(const void* in) &#123;    return in;&#125;\n\nDocumentation for macros must include hideinitializer doxygen command\n/** * \\brief           Get minimal value between `x` and `y` * \\param[in]       x: First value * \\param[in]       y: Second value * \\return          Minimal value between `x` and `y` * \\hideinitializer */#define MIN(x, y)       ((x) &lt; (y) ? (x) : (y))\n\nHeader&#x2F;source files\nLeave single empty line at the end of file\n\nEvery file must include doxygen annotation for file and brief description followed by empty line (when using doxygen)\n/** * \\file            template.h * \\brief           Template include file */                    /* Here is empty line */\n\nEvery file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen)\n\nUse the same license as already used by project&#x2F;library\n/** * \\file            template.h * \\brief           Template include file *//* * Copyright (c) year FirstName LASTNAME * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the &quot;Software&quot;), to deal in the Software without restriction, * including without limitation the rights to use, copy, modify, merge, * publish, distribute, sublicense, and/or sell copies of the Software, * and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. * * This file is part of library_name. * * Author:          FirstName LASTNAME &lt;optional_email@example.com&gt; */\n\nHeader file must include guard #ifndef\n\nHeader file must include C++ check\n\nInclude external header files outside C++ check\n\nInclude external header files with STL C files first followed by application custom files\n\nHeader file must include only every other header file in order to compile correctly, but not more (.c should include the rest if required)\n\nHeader file must only expose module public variables&#x2F;types&#x2F;functions\n\nUse extern for global module variables in header file, define them in source file later\n/* file.h ... */#ifndef ...extern int32_t my_variable; /* This is global variable declaration in header */#endif/* file.c ... */int32_t my_variable;        /* Actually defined in source */\nNever include .c files in another .c file\n\n.c file should first include corresponding .h file, later others, unless otherwise explicitly necessary\n\nDo not include module private declarations in header file\n\nHeader file example (no license for sake of an example)\n/* License comes here */#ifndef TEMPLATE_HDR_H#define TEMPLATE_HDR_H/* Include headers */#ifdef __cplusplusextern &quot;C&quot; &#123;#endif /* __cplusplus *//* File content here */#ifdef __cplusplus&#125;#endif /* __cplusplus */#endif /* TEMPLATE_HDR_H */\n\nArtistic style configurationAStyle is a great piece of software that canhelp with formatting the code based on input configuration.\nThis repository contains astyle-code-format.cfg file which can be used with AStyle software.\nastyle --options=&quot;astyle-code-format.cfg&quot; &quot;input_path/*.c,*.h&quot; &quot;input_path2/*.c,*.h&quot;\n\nEclipse formatterRepository contains eclipse-ext-kr-format.xml file that can be used witheclipse-based toolchains to set formatter options.\nIt is based on K&amp;R formatter with modifications to respect above rules.You can import it within eclipse settings, Preferences -&gt; LANGUAGE -&gt; Code Style -&gt; Formatter tab.\n"},{"title":"STM32H7性能问题优化实践","url":"/2024/03/07/STM32H7%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","content":"最近开发一个项目，采用STM32H7单片机，遇到了一个我以前没有遇到过的一个性能问题，通过分析解决该问题的过程让我对STM32高性能数据传输有更加深刻的理解。\n\n关键字：总线、DMA、FIFO\n\n\n项目背景某项目开发中需要将Linux的数据通过USB传输到单片机，数据在单片机中经过适当的处理后再将数据传输到硬件外设上。\n第一次性能瓶颈 - USBUSB的理论带宽有480MHz，使用批量传输模式可实现较高的传输速度。最开始选用的是Tinyusb协议栈，在使用了一段时间后才发现该协议栈不支持DMA，这导致在进行高带宽数据传输时导致CPU占用非常高，接近40%的CPU资源都用于协议栈传输数据。过高的CPU占用将会为后续的数据处理阶段带来较大的隐患，所以必须要解决DMA支持的问题。\n将协议栈更换为CherryUSB后，DMA的问题解决了。在CPU仅占用1%的情况下，可达到30MB&#x2F;s的传输速度。\n内存带宽限制最开始我认为将USB的数据缓存放在靠近USB外设的区域，也就是AHB总线矩阵附近会有更多优势，但是我却忽略了一个带宽问题。这里的内存带宽是32bit的，在后续数据处理阶段，CPU访问这里的数据会有一定的性能瓶颈。将USB的缓存切换到AXI矩阵下，CPU的处理性能提高了一倍，且对USB的传输性能基本上没有太大的影响。\n除了带宽问题外，AHB矩阵下的Cache策略也有一定的影响，这里是关闭了DCache的。将数据缓存放到AXI-SARM后也需要面临DCache的问题。\n这里有两个选择，1：开启DCache，但是需要在适当的时候进行内存同步。2：关闭该区域的DCache，这样不需要额外的内存同步操作。分别测试了两种情况，最终开启DCache的方案性能要好得多(优50%以上)。这看起来是不太合理的，因为这里涉及到了USB的DMA，该区域的Cache特性反而是一种负担。但是关闭Cache后性能却大受影响。\n外设传输性能的优化将数据传输到外设中基本上没什么特别的选择，只有DMA能够胜任。但是在落实到具体的配置上有很多优化的地方需要注意，这都是影响性能的关键点。\n外设上的FIFO，我最开始并没有意识到外设FIFO的作用，因为这里已经使用了DMA，外设上的FIFO作用并不明显。但该FIFO能够提高总线的利用率，通过FIFO缓存数据后，可用将数据位宽进行压缩传输，目标外设为16bit时，通过将两次传输压缩为32bit进行一次传输到FIFO内，从而提高传输性能。\n此外，利用DMA上的FIFO配合突发模式能够进一步提高传输性能，这对总线性能提高非常明显，因为前面的USB数据和该外设数据会经过同一条数据总线，使用突发模式传输数据可用在适当情况下避免总线发生抢占而导致CPU或USB发生不必要的等待。总线上的访问模式优化将系统的整体性能提高了10%，效果非常的明显。\n数据处理上需要注意的地方本次开发过程中涉及到了许多的非完整宽度的数据类型，例如12bit、14bit的有符号数，在C语言中一般使用位域能够非常轻松的处理这种数据类型。但是在实践的过程中发现，使用位域赋值时会存在一定的性能问题，导致数据处理的效率降低。因为处理器每次对一个非完整宽度的数据赋值时需要先从内存中加载一部分数据，这可能导致不必要的内存IO开销，因为LDR、STR指令是拖慢系统运行的关键因素。在算法的实践中需要减少IO的访问，将一部分数据算法使用寄存器进行处理，之后再将寄存器的数据写入到内存中。\n在开发C代码过程中，可能很多人无法靠直觉想到一段C代码有多少LDR、STR指令，但在经过一定程度的练习后还是能够这种天赋的。推荐一个网站Compiler Explorer ，该网站能够将C代码转为汇编，并提供可选的编译选项，可以作为学习的平台和工具。想要编写出真正的高性能代码，掌握基本的汇编语言也是比不可少的，理解各种汇编指令的时钟周期对编写高性能代码更加重要，这里就不展开了。\n总结单片机内部数据总线在平时开发过程中并没有特别注意，因为没有直接对内核或外设产生影响，但是在面临大数据带宽、多个外设并行时，合理的配置以优化总线的利用将有助于系统整体的优化。在本次开发过程中，还研究了总线矩阵上的一下其它配置，如Qos、总线优先级等等，但由于本次开发时间有限且项目已满足设计要求，没有进一步的深入探究，在这些地方应该还有优化的空间。\n"},{"title":"SVC系统调用的编程使用方法","url":"/2021/11/06/SVC%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"SVC称为系统服务调用(SuperVisorCall)，异常类型为11，通过svc指令可用触发异常，SVC在触发异常后必须立即得到相应(触发异常后在执行异常前不能执行其它代码)，除非有更高优先级的异常在执行。\n对于可靠系统而言，可以使用SVC异常实现资源的特权访问，使系统更加安全。通过SVC系统调用编号能够实现参数传递，从而实现不同功能的系统服务。使用系统服务可以不需要知道具体服务函数的地址，这样能够隐藏更多的细节，降低软件间的耦合性。\n在ARM开发工具链下，有比较优雅的方式直接使用SVC异常，在GCC下需要配合汇编来使用。\n这里不讨论ARM处理器对于异常的处理机制，它在触发SVC指令后响应的异常行为与系统中其它异常是一致的。\nSVC异常处理  .syntax unified  .thumb  .global SVC_Handler  .global SVC_VIRTUAL_CALL_0  .global SVC_VIRTUAL_CALL_1  .global SVC_VIRTUAL_CALL_2  .global SVC_VIRTUAL_CALL_3  .type SVC_Handler, %function  .type SVC_VIRTUAL_CALL_0, %function  .type SVC_VIRTUAL_CALL_1, %function  .type SVC_VIRTUAL_CALL_2, %function  .type SVC_VIRTUAL_CALL_3, %functionSVC_Handler:  tst lr, #4  ite eq  mrseq r0, msp  mrsne r0, psp  push &#123;r6, r7, lr&#125;  mov r7, r0  ldr r0, [r7, #0]     //原始R0  ldr r1, [r7, #4]  ldr r2, [r7, #8]  ldr r3, [r7, #12]  ldr r6, [r7, #24]    //svc指令相关的pc地址  ldr r6, [r6, #-2]  and r6, #0xFF  ldr r12, =g_svc_vector  ldr r6, [r12, r6, lsl #2]  blx r6  str r0, [r7, #0]  pop &#123;r6, r7, pc&#125;Default_SVC_Handler:  bx lr  .align 2g_svc_vector:  .word SVC_HANDLER_0  .word SVC_HANDLER_1  .word SVC_HANDLER_2  .word SVC_HANDLER_3    .weak      SVC_HANDLER_0  .thumb_set SVC_HANDLER_0, Default_SVC_Handler  .weak      SVC_HANDLER_1  .thumb_set SVC_HANDLER_1, Default_SVC_Handler  .weak      SVC_HANDLER_2  .thumb_set SVC_HANDLER_2, Default_SVC_Handler  .weak      SVC_HANDLER_3  .thumb_set SVC_HANDLER_3, Default_SVC_HandlerSVC_VIRTUAL_CALL_0:    svc 0    bx lrSVC_VIRTUAL_CALL_1:    svc 1    bx lrSVC_VIRTUAL_CALL_2:    svc 2    bx lrSVC_VIRTUAL_CALL_3:    svc 3    bx lr\n\nSVC_Handler函数是异常处理函数，进入函数，判断LR寄存器来分析进入异常前的环境，获取到对应的sp地址。通过sp寄存器就能访问到栈空间，在栈中可以获取到r0-r3，这个就是执行svc时传进来的参数，通常这4个寄存器不会被修改，除非发生了更高优先级的异常。通过在栈中获取到执行svc的pc指针，得到svc指令的二进制码，低8位存储了指令附加的异常id，使用该id在内部通过查表的方式定位具体需要执行的函数入口，执行指定的函数后，我们将r0也就是返回值存储到栈空间中，这样返回到用户态后，用户就能获得执行目标函数后返回结果。\n为了方便定义用户系统调用函数，设计了这样的一个宏。\n#define SVC_CALL_DEF(id, func, ret_t, ...) \\extern ret_t SVC_VIRTUAL_CALL_##id(__VA_ARGS__); \\ret_t SVC_HANDLER_##id(__VA_ARGS__)\n其中id表示该函数绑定到svc的那一个系统调用上，func表示函数名称，ret_t和后面的参数分别表示函数的返回值和形参列表，如果无形参则填入void。通过 SVC_VIRTUAL_CALL_id()来执行系统调用。\n这是一个简单的例子：\nSVC_CALL_DEF(1, test_svc_add, int, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = SVC_VIRTUAL_CALL_1(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n\n进阶写法前面的定义方法和调用方法与传统的C语言函数定义和函数调用存在区别，所以在使用上存在不方便的地方，按照下面的写法更加合理，且函数调用与C语言是一致的，减低了代码移植上的一致性问题。\n#ifndef __SVC_HANDER_H#define __SVC_HANDER_H#if defined(__GNUC__)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__); \\    __asm__(        \\        &quot;.thumb\\n&quot;  \\        &quot;.global &quot; #name &quot;\\n&quot; \\        &quot;.type &quot; #name &quot;, %function\\n&quot; \\        #name &quot;:\\n&quot; \\        &quot;svc &quot; #id &quot;\\n&quot; \\        &quot;bx lr\\n&quot;); \\    ret_t SVC_HANDLER_##id(__VA_ARGS__)#elif defined(__CC_ARM)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t __svc(id) name(__VA_ARGS__)#else#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__)    // #warning &quot;not support SVC function!&quot;#endif#endif\n\n有了这个宏定义后，定义一个svc函数以及函数的调用写法将变为：\nDEF_SVC_FUNC(2, int, add_func, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = add_func(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n这样的写法能够兼容不同的编译器，且不用提前定义SVC_VIRTUAL_CALL_0函数。\n"},{"title":"PIO参考手册","url":"/2025/03/08/PIO%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/","content":"\n本文原始文档来自于RP2040官方文档，该译文内容源自互联网 https://github.com/charlee/rp2040-pio-zhcn本文的编写重新参考了最新的RP2350官方文档，更新并补充了许多新的内容，包括新版本PIO的特性和新加入的一些指令等。\n\nPIO概要RP2040有两个完全相同的PIO模块，RP2350有3个PIO模块。每个PIO块都独立连接到总线、GPIO和中断控制器。一个 PIO 块的结构图如下图所示。\n\n\n\n\n\n\n\n图38. PIO块结构图。RP2040有两个PIO块，每个块有四个状态机。四个状态机可以从一片共享指令内存中同时执行指令。FIFO数据队列负责在PIO和系统之间缓冲传输的数据。每个状态机可以通过GPIO映射逻辑监视并操作最多30个GPIO。\n\n\n可编程输入输出块（PIO）是一个非常灵活的硬件接口。它能支持许多IO标准，例如：\n\n8080 和 6800 并行总线\nI2C\n3针I2S\nSDIO\nSPI、DSPI、QSPI\nUART\nDPI 或 VGA（通过电阻式DAC）\n\nPIO的编程方式与处理器类似。每个PIO有四个状态机，每个状态机可以独立执行顺序代码，操作 GPIO 并传输数据。但不同于通用处理器，PIO 状态机是专门为输入输出设计的，因此具有确定性、精确的时间，并与固定功能的硬件紧密结合。\n每个状态机都拥有以下内容：\n\n两个 32 位移位寄存器 - 可以向任意方向位移任意比特\n两个 32 位可擦写寄存器（scratch registor）\n每个方向上（TX&#x2F;RX）都有 4x32 位总线 FIFO，可以重新配置为单向 8x32 FIFO\n支持小数的时钟分频器（16 位整数，8 位小数）\n灵活的 GPIO 映射\nDMA 接口，每个时钟周期最多可传输来自系统 DMA 的 1 个字\nIRQ 标志设置&#x2F;清除&#x2F;状态查询\n\n每个状态机及其相关的硬件所占用的芯片面积大约相当于标准的串行接口，如 SPI 或 I2C 控制器等。但是，PIO 状态机可以动态配置或重新配置，实现多种不同的接口。\n状态机能用软件的形式编程，相比于像 CPLD 那样采用完全可配置的逻辑芯片，PIO能在同样的成本和功耗下提供更多的硬件接口。它还带来了人们更为熟悉的编程模型，和更简单的工具流程，因此人们可以利用 PIO 的灵活性直接进行编程，而不需要使用 PIO 库中事先定义好的接口。\nPIO 不仅非常灵活，性能还非常高，这都要归功于每个状态机中的固定功能的硬件。在输出 DPI 时，PIO 能够在 48MHz 系统时钟的支持下，在活跃的扫描线期间提供 360Mb&#x2F;s 的吞吐量。在这个例子中，一个状态机负责处理帧和扫描线的时间，并生成像素时钟，另一个负责处理像素数据，并解包行程编码的扫描线。\n状态机的输入和输出可以映射到最多 32 个 GPIO 上（在 RP2040 中限制为 30 个 GPIO），所有状态机都能独立、同时访问任何 GPIO。例如，标准的 UART 代码允许 TX、RX、CTS 和 RTS 使用任意四个 GPIO，而 I2C 也允许将 SDA 和 SCL 映射到任意 GPIO 上。具体的自由度取决于 PIO 程序使用 PIO 针脚映射资源的方式，一个接口可以在一定数量的 GPIO 范围内自由移动。\n3.2. PIO程序四个状态机执行共享指令内存的程序。系统软件将内存加载至该区域，配置状态机和 IO 映射，然后将状态机设置为运行状态。PIO 程序可以来自多个地方：可以由用户直接汇编，可以来自 PIO 库，或者由用户的软件生成。\n之后，状态机就会自动运行，系统软件通过 DMA、中断和控制寄存器与之交互，就像操作 RP2040 上的其他外设一样。对于更复杂的接口，PIO 提供了一个短小灵活的指令集，可以让系统软件更深入地操作状态机的控制流。\n\n\n\n\n\n\n\n图39. 状态机概览。数据通过一对 FIFO 输入输出。状态机可以执行一段程序，让这些 FIFO、一系列内部寄存器和管脚之间传输数据。时钟分频器可以降低状态机的执行速度。\n\n\n3.2.1. PIO程序PIO 状态机执行短小的二进制程序。\nPIO 库提供了像 UART、SPI 或 I2C 等通用接口的程序，因此许多情况下不需要自己编写 PIO 程序。但是，直接对 PIO 编程可以带来更大的灵活性，支持许多连设计者都没有考虑供的接口。\nPIO 一共有九条指令：JMP、WAIT、IN、OUT、PUSH、PULL、MOV、IRQ 和 SET。关于每条指令的详细信息请参见3.4节。\n尽管 PIO 只有九条指令，手工编写二进制 PIO 程序也非常困难。PIO 汇编是用文本形式描述的 PIO 程序，每条命令对应于二进制程序中的一条指令。下面是一个 PIO 汇编程序的例子：\nPico 示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.pio 第7-12行 \n\n 7 .program squarewave 8     set pindirs, 1 ; Set pin to output 9 again:10     set pins, 1 [1] ; Drive pin high and then delay for one cycle11     set pins, 0 ; Drive pin low12     jmp again ; Set PC to label `again`\n\nSDK 自带了 PIO 汇编器，名为 pioasm。该程序接受一个 PIO 汇编程序的文本文件，其中可以包含多个程序，并输出汇编后的程序。这些汇编后的程序以 C 头文件的形式输出，头文件中包含了常量数组。更多信息请参考3.3节。\n3.2.2. 控制流在每个时钟周期，每个状态机获取、解码并执行一条指令。每个指令精确地占用一个时钟周期，除非它显式地暂停执行（如 WAIT 指令）。每条指令还可以带有最多 31 个周期的延时，推迟下一条指令的执行，用于编写精确时钟周期的程序。\n程序计数器 PC 指向当前周期正在执行的指令的内存地址。一般而言，PC 每个周期加一，到达指令内存边界时自动返回开头。跳转指令是一个例外，它显式提供了 PC 的下一个值。\n上一节的示例汇编程序（开头为 .program squarewave）演示了这两个概念。它在一个 GPIO 引脚上产生占空比为 50% 的方波，每个周期占用四个时钟周期。通过其他手段（如 side-set）可以将周期缩短至两个时钟周期。\n注意：Side-set 可以让状态机在执行一条指令时，顺便设置少量 GPIO 的状态。详细描述请参见3.5.1节。\n系统对指令内存拥有只写的权限，用于加载程序：\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.c 第34-38行\n\n34     // Load the assembled program directly into the PIO&#x27;s instruction memory.35     // Each PIO instance has a 32-slot instruction memory, which all 4 state36     // machines can see. The system has write-only access.37     for (int i = 0; i &lt; count_of(squarewave_program_instructions); ++i)38         pio-&gt;instr_mem[i] = squarewave_program_instructions[i];\n\n时钟分频器可以按照固定的比例降低状态机的执行速度，该比例用一个 16.8 的定点分数表示。在上述示例中，如果采用的时钟分割因子为 2.5，那么方波的周期就是 4 x 2.5 &#x3D; 10 个时钟周期。这在需要设置 UART 等串行接口的精确波特率时非常有用。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.c 第42-47行\n\n42     // Configure state machine 0 to run at sysclk/2.5. The state machines can43     // run as fast as one instruction per clock cycle, but we can scale their44     // speed down uniformly to meet some precise frequency target, e.g. for a45     // UART baud rate. This register has 16 integer divisor bits and 846     // fractional divisor bits.47     pio-&gt;sm[0].clkdiv = (uint32_t) (2.5f * (1 &lt;&lt; 16));\n\n上述代码片段所在的整个程序可以在 GPIO 0 （或任何管脚）上产生一个 12.5MHz 的方波。我们还可以使用 WAIT PIN 指令根据管脚状态等待一定时间，或使用 JMP PIN 指令根据管脚状态跳转，实现根据管脚状态改变控制流。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.c 第51-59行 \n\n51     // There are five pin mapping groups (out, in, set, side-set, jmp pin)52     // which are used by different instructions or in different circumstances.53     // Here we&#x27;re just using SET instructions. Configure state machine 0 SETs54     // to affect GPIO 0 only; then configure GPIO0 to be controlled by PIO0,55     // as opposed to e.g. the processors.56     pio-&gt;sm[0].pinctrl =57         (1 &lt;&lt; PIO_SM0_PINCTRL_SET_COUNT_LSB) |58         (0 &lt;&lt; PIO_SM0_PINCTRL_SET_BASE_LSB);59     gpio_set_function(0, GPIO_FUNC_PIO0);\n\n系统可以通过 CTRL 寄存器在任意时间启动或停止任意状态机。多个状态机可以同时启动，而 PIO 的确定性能保证它们之间的完美同步。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.c 第63-67行\n\n63     // Set the state machine running. The PIO CTRL register is global within a64     // PIO instance, so you can start/stop multiple state machines65     // simultaneously. We&#x27;re using the register&#x27;s hardware atomic set alias to66     // make one bit high without doing a read-modify-write on the register.67     hw_set_bits(&amp;pio-&gt;ctrl, 1 &lt;&lt; (PIO_CTRL_SM_ENABLE_LSB + 0));\n\n大多数指令都来自指令内存，但指令也可以来自其他地方，并且可以混合使用：\n\n写入特殊配置寄存器（SMx INSTR）的指令会立即执行，中断其他指令的执行。例如，写入 SMx INSTR 的一条 JMP 指令会让状态机立即从另一个位置开始执行。\n使用 MOV EXEC 指令，可以从寄存器执行指令。\n使用 OUT EXEC 指令，可以从输出移位寄存器中执行指令。\n\n后面几种方式非常灵活：指令可以嵌入到传递给 FIFO 的数据流中。I2C 的示例就在正常的数据中嵌入了 STOP 和 RESTART 等的条件。对于 MOV 和 OUT EXEC 来说，MOV &#x2F; OUT 本身需要一个时钟周期，然后再执行指定的指令。\n3.2.3. 寄存器每个状态机都拥有几个内部寄存器。这些寄存器用于保存输入或输出数据，以及循环变量等临时数据。\n3.2.3.1. 输出移位寄存器（OSR）\n\n\n\n\n\n\n图40. 输出移位寄存器（OSR）。数据每次可以并行输出 1 ~ 32 比特，未使用的数据由一个双方向移位器负责回收。当 OSR 寄存器为空时，它会从 TX FIFO 中加载数据。\n\n\n输出移位寄存器（OSR）负责存储在 TX FIFO 和管脚（或其他目的地，如可擦写寄存器）之间移位输出数据。\n\nPULL 指令：从 TX FIFO 中移除一个 32 位字并置于 OSR 中。\nOUT 指令将 OSR 中的数据移位至其他目的地，一次可移位 1 ~ 32 比特。\n当数据被移位出后，OSR 会填充为零。\n如果启用自动加载（autopull），那么在达到某个移位阈值时，状态机会在执行 OUT 指令时，自动从 FIFO 加载数据到 OSR。\n移位方向可以是左或右，由处理器通过配置寄存器进行设置。\n\n例如，以每两个时钟周期一个字节的速率，将数据通过 FIFO 传输到管脚：\n1 .program pull_example12 loop:3     out pins, 84 public entry_point:5     pull6     out pins, 8 [1]7     out pins, 8 [1]8     out pins, 89     jmp loop\n\n在绝大部分情况下，可以通过自动加载（autopull，参见3.5.4节）功能，当状态机试图在空的 OSR 上执行 OUT 指令时，由硬件自动填充 OSR。这样做有两个好处：\n\n节省一条从 FIFO 加载数据的指令\n实现更高的吞吐量，只要 FIFO 有数据，就能以每时钟周期最高 32 比特的数据输出\n\n配置好自动加载后，上述程序可以简化如下，其行为完全相同：\n1 .program pull_example22 3 loop:4     out pins, 85 public entry_point:6     jmp loop\n\n通过程序折返功能（program wrapping，参见3.5.2节）还可以进一步简化程序，实现每个系统时钟周期输出 1 字节。\n1 .program pull_example32 3 public entry_point:4 .wrap_target5     out pins, 8 [1]6 .wrap\n\n3.2.3.2. 输入移位寄存器（ISR）\n\n\n\n\n\n\n图41. 输入移位寄存器（ISR）。数据每次进入 1 ~ 32 比特，当前内容会左移或右移，以腾出空间。当寄存器满时，内容会被写入 RX FIFO。\n\n\n\nIN 指令每次将 1 ~ 32 比特的数据移位进寄存器。\nPUSH 指令将 ISR 的内容写入 RX FIFO。\n执行推出（push）时，ISR 的内容被清零。\n如果设置了自动推出（autopush），那么当达到某个移位阈值时，状态机会在执行 IN 指令时自动将 ISR 的内容推出。\n移位方向可以由处理器通过配置寄存器进行设置。\n\n3.2.3.3. 移位计数器状态机会记录总共有多少比特通过 OUT 指令移出了 OSR 寄存器，以及通过 IN 指令移入了 ISR。这个信息由一对硬件计数器负责跟踪，即输出移位计数器和输入移位计数器，每个计数器可以保存数字 0 到 32（包含 0 和 32）。在每次移位操作后，相应的计数器会增加移位数量，最多增加 32（等于移位寄存器的宽度）。可以对状态机进行配置，在某个计数器达到一定阈值后自动执行下列某个动作：\n\n当特定数量的比特被移出后，自动加载 OSR。参见3.5.4节\n当特定数量的比特被移入后，自动清空 ISR。参见3.5.4节\nPUSH 或 PULL 指令根据输入或输出移位计数器的条件自动执行\n\n在 PIO 复位时，或在 CTRL_SM_RESTART 时，输入一位计数器被清为 0（表示没有任何比特被移入），输出移位寄存器被初始化为 32（表示全空，没有任何等待移出的比特）。影响移位计数器的其他指令包括：\n\n成功的 PULL 会将输出移位计数器清为 0\n成功的 PUSH 会将输入移位计数器清为 0\nMOV OSR, ... （即任何写入 OSR 的 MOV 指令）会将输出移位计数器清为 0\nMOV ISR, ... （即任何写入 ISR 的 MOV 指令）会将输入移位计数器清为 0\nOUT ISR, count 将输入移位计数器设置为 count\n\n3.2.3.4. 可擦写寄存器每个状态机有两个 32 位内部可擦写计数器（scratch registor），名为 X 和 Y。\n它们可以用于：\n\nIN&#x2F;OUT&#x2F;SET&#x2F;MOV指令的源或目的地\n分支条件的源\n\n例如，假设我们要为比特 “1” 产生一个长脉冲，为比特 “0” 产生一个短脉冲：\n 1 .program ws2812_led 2  3 public entry_point: 4     pull 5     set x, 23       ; Loop over 24 bits 6 bitloop: 7     set pins, 1     ; Drive pin high 8     out y, 1 [5]    ; Shift 1 bit out, and write it to y 9     jmp !y skip     ; Skip the extra delay if the bit was 010     nop [5]11 skip:12     set pins, 0 [5]13     jmp x-- bitloop ; Jump if x nonzero, and decrement x14     jmp entry_point\n\n这里 X 是循环计数器，Y 是临时变量，根据来自 OSR 的一个比特进行分支。该程序可以用来驱动 WS2812 LED 接口，不过该程序还可以写得更紧凑（最少只需要三条指令）。\n通过 MOV 指令，可擦写寄存器可以用来保存或恢复移位寄存器，可以用于重复移出同样的序列等情况。\n注意：更紧凑的 WS2812 示例（共四条指令）参见3.6.2节。\n3.2.3.5. FIFO每个状态机都拥有一对 4 字深的 FIFO，一个用于将数据从系统传输到状态机（TX），另一个用于将数据从状态机传输至系统（RX）。TX FIFO 由总线管理者（如处理器或 DMA 控制器）负责写入，而 RX FIFO 由状态机写入。FIFO 解耦合了 PIO 状态机和系统总线之间的时序，让状态机在没有处理器介入的情况下工作更长时间。\nFIFO 还会生成数据请求信号（DREQ），系统的 DMA 控制器可以借助此信号，根据 RX FIFO 中的数据情况，或 TX FIFO 中的空闲空间情况，采取适当的读写节奏。因此，处理器可以设置更长的事务，比如允许在没有处理器介入的情况下传输几 K 字节的数据。\n通常，一个状态机只需要单方向传递数据。此时，SHIFTCTRL_FJOIN 选项可以将两个 FIFO合并成一个 8 字深的单向 FIFO。这个特性可以用于高带宽的接口，如 DPI。\n3.2.4. 等待状态状态机可能由于多种原因暂停执行：\n\nWAIT 指令的条件未满足\n阻塞的 PULL 指令遇到 TX FIFO 为空的情况，或阻塞的 PUSH 指令遇到 RX FIFO 为满的情况\nIRQ WAIT 指令设置了 IRQ 标志，等待其清空\nOUT 指令遇到启用了自动加载，OSR 达到移位阈值，且 TX FIFO 为空的情况\nIN 指令遇到启用了自动推出，ISR 达到以为预制，且 RX FIFO 为满的情况\n\n此时，程序计数器不会增加，状态机会在下一个周期继续执行当前指令。如果指令带有一定数量的延时，那么在暂停执行状态解除之前，延时不会被执行。\n注意：Side-set（参见3.5.1节）不受暂停执行的影响，永远发生在所属指令的第一个时钟周期。\n3.2.5. 管脚映射PIO 可以控制最多 32 个 GPIO 的输出电平和方向，以及观察它们的输入电平。在每个系统时钟周期，每个状态机可以进行零个、一个或两个以下操作：\n\n通过一条 OUT 或 SET 指令改变某些 GPIO 的电平或方向，或通过一条 IN 指令读取某些 GPIO\n通过一个 side-set 操作改变某些 GPIO 的电平或方向\n\n每个操作都可以指定连续的一段 GPIO 管脚，管脚数量和起始管脚由每个状态机的 PINCTRL 寄存器控制。共可以设定四个范围，分别用于 OUT、SET、IN 和 side-set 操作。每个范围可以覆盖给定 PIO 块内的任意数量的 GPIO （在 RP2040 上为 30 个用户定义 GPIO），而且这些范围之间可以重叠。\n对于每次 GPIO 输出（电平和方向分别考虑），PIO 会考虑该时钟周期内发生的所有 8 个写入操作，并从编号最大的状态机开始应用写入操作。如果同一个状态机在同一个 GPIO 上同时执行 SET&#x2F;OUT 和 side-set 操作，则采用 side-set。如果没有任何状态机写入某个 GPIO 输出，则其值保持前一个周期的值不变。\n一般而言，每个状态机的输出被映射到不同的 GPIO 组上，从而实现某种并行接口。\n3.2.6 IRQ 标志IRQ 标志是可以由状态机或系统进行设置或清除的状态位。共有 8 个标志，全部对所有状态机可见，而且还可以通过 IRQ0_INTE 和 IRQ1_INTE 控制寄存器，将 IRQ 标志的低 4 比特遮盖成某个 PIO 的中断请求线，\nIRQ 标志的用途主要有两个：\n\n在状态机程序中，判断系统级别的中断，然后据此等待某个中断的应答\n同步两个状态机的执行\n\n状态机可以通过 IRQ 和 WAIT 指令来处理 IRQ 标志。\n3.2.7. 状态机之间的交互指令内存是一个 1-写 4-读的寄存器文件，所以四个状态机可以在同一个周期读取指令，而不需要相互等待。\n使用多个状态机有三种方式：\n\n将多个状态机指向同一个程序\n将多个状态机指向不同的程序\n用多个状态机运行同一个接口的不同部分，例如 UART 的 TX 端和 RX 端，或 DPI 显示的时钟&#x2F;水平同步和像素数据\n\n状态机之间无法进行数据通信，但可以通过 IRQ 标志互相同步。共有 8 个 IRQ 标志（低 4 比特可以遮盖，用于系统 IRQ），每个状态机可以通过 IRQ 指令设置或清除任意标志，也可以通过 WAIT IRQ 指令等待某个标志被设置或清除。这样可以实现状态机之间的时钟周期级别的同步。\n3.3. PIO 汇编器（pioasm）PIO 汇编器能够解析一段 PIO 源文件，并输出汇编后的代码，该代码可以包含到某个 RP2040 应用程序中，可以是使用 SDK 构建的 C 或 C++ 程序，也可以是 RP2040 MicroPython 上运行的 Python 程序。\n本节简要介绍 pioasm 中可以使用的标识符（directives）和指令（instructions）。有关怎样使用 pioasm、怎样将其集成到 SDK 构建系统中、怎样扩展其特性以及它能生成何种输出格式等的深入讨论，请参考 Raspberry Pi Pico C&#x2F;C++ SDK 一书。\n3.3.1. 标识符PIO 程序中的汇编语言可以使用以下标识符：\n.define ( PUBLIC ) &lt;symbol&gt; &lt;value&gt;\n定义一个名为 &lt;symbol&gt; 的整数符号，其值为 &lt;value&gt; （参见3.3.2节）。如果 .define 出现在输入文件中的第一个程序之前，那么定义就是全局的，对所有程序生效；否则，定义就是局部的，仅对其所在的程序生效。如果指定了 PUBLIC，那么符号将输出到汇编中，可以由用户代码使用。对于 SDK 而言，程序符号的定义形式为 #define &lt;program_name&gt;_&lt;symbol&gt; value，而全局符号的定义形式为#define &lt;symbol&gt; value。\n.program &lt;name&gt;\n开始一个名为 &lt;name&gt; 的新程序。注意名称会在代码中使用，所以应当由字母、数字或下划线组成，并且不以数字开始。程序直到出现下一个 .program 标识或源文件末尾时结束。PIO 指令只能在程序内使用。\n.clock_div &lt;divider&gt;\n如果存在该指令，则divider是程序的状态机时钟分频器。需要注意的是，分频值可以是浮点数，但目前无法使用算数表达式来定义。该指令影响程序的默认状态机配置，此指令仅在第一条程序指令之前有效。\n.pio_version &lt;version&gt;\n如果存在该指令，则要求硬件的PIO版本至少需要达到指定的值。rp2040的PIO版本为0，RP2350的PIO版本为1。\n.fifo &lt;fifo_config&gt;\n如果存在该指令，则它用来指定程序的FIFO配置。支持以下FIFO配置：\n\ntxrx: TX和RX的FIFO各自分配4字，这也是默认配置\ntx: TX FIFO独占8字\nrx: RX FIFO独占8字\ntxput: 4字FIFO用于TX，4字FIFO用于 mov rxfifo[index], isr (该配置不支持PIO version 0)\ntxget: 4字FIFO用于RX，4字FIFO用于 mov osr, rxfifo[index] (该配置不支持PIO version 0)\nputget: 4字FIFO用于 mov rxfifo[index], isr  4字FIFO用于 mov osr, rxfifo[index] (该配置不支持PIO version 0)\n\n.in &lt;count&gt; (left|right) (auto) (&lt;threshold&gt;)\n如果存在该指令，count 指示要使用的bit数，left和right指示ISR寄存器位移的方向，auto指示使能自动push，如果存在threshold，则其指示执行自动push的阈值。该指令影响程序的默认状态机配置，此指令仅在第一条程序指令之前有效。(对于PIO version 0来说，count固定为32)\n.out &lt;count&gt; (left|right) (auto) (&lt;threshold&gt;)\n如果存在该指令，count 指示要使用的bit数，left和right指示OSR寄存器位移的方向，auto指示使能自动pull，如果存在threshold，则其指示执行自动pull的阈值。该指令影响程序的默认状态机配置，此指令仅在第一条程序指令之前有效。(对于PIO version 0来说，count固定为32)\n.mov_status rxfifo &lt; &lt;n&gt;.mov_status txfifo &lt; &lt;n&gt;.mov_status irq &lt;(next|prev)&gt; set &lt;n&gt;\n该指令用于配置指令 mov x, status 的源。可从三种情况之中选择一种进行配置，包括根据RXFIFO数量低于n、TXFIFO数量低于n、irq的第n个标志被设置(或下一个更高编号或上一个更低编号的PIO)。irq选项不支持PIO version 0。\n.origin &lt;offset&gt;\n可选的标识，指示 PIO 指令内存的偏移量，程序必须加载到此偏移量处。绝大多数情况下，该标识用于指定程序必须加载到偏移量 0，这样这些程序才能使用基于数据的 JMP 指令，并且只用几个比特来存储跳转的（绝对）地址。在程序外部，该标识无效。\n.side_set &lt;count&gt; (opt) (pindirs)\n如果出现该标识，则 &lt;count&gt; 指示使用的 side-set 比特数。还可以通过 opt 以指定 side &lt;value&gt; 对于指令是可选的（注意这样做会使 side-set 在原本需要占用的 &lt;count&gt; 个比特之外，再额外占用一个比特。这些被占用的比特均来自指令的延时比特）。最后，pindirs 可以用来指示 side-set 值应当应用于 PINDIR，而不是 PIN 上。该标识只能出现在程序的第一条指令之前。\n.wrap_target\n该标识置于某条指令之前，用于指示在程序折返时应当从哪一条指令继续执行。该标识只能在程序内部使用，且每个程序只能使用一次。如果不指定，折返目的地为程序的开头。\n.wrap\n该标识置于某条指令之后，指示在正常的控制流中（即 jmp 条件为假，或没有 jmp 的情况）执行完该指令后，程序应当折返（至 .warp_target 标识的指令）。该标识只能在程序内部使用，且每个程序只能使用一次。如果不指定，则折返点为程序的最后一条指令之后。\n.lang_opt &lt;lang&gt; &lt;name&gt; &lt;option&gt;\n为程序指定与特定语言生成器有关的选项（参见SDK文档中的”Language generators”一节）。该标识只能在程序内使用。\n.word &lt;value&gt;\n将一个 16 位值作为一条指令存储在程序中。该标识只能在程序内部使用。\n3.3.2. 值下述值类型可以用于定义整数，或分支目的地。\n\n\n\n格式\n说明\n\n\n\ninteger\n一个整数值，如 3 或 -7\n\n\nhex\n一个十六进制值，如 0xf\n\n\nbinary\n一个二进制值，如 0b1001\n\n\nsymbol\n由 .define 定义的一个值（参见3.3.1节）\n\n\n&lt;label&gt;\n程序中的标签所对应的指令偏移量。通常在 JMP 指令中使用（参见3.4.2节\n\n\n( &lt;expression&gt; )\n一个可求值的表达式；参见3.3.3节。注意括号是必须的。\n\n\n3.3.3. 表达式表达式可以与 pioasm 值一同使用。\n\n\n\n格式\n说明\n\n\n\n&lt;expression&gt; + &lt;expression&gt;\n两个表达式的和\n\n\n&lt;expression&gt; - &lt;expression&gt;\n两个表达式的差\n\n\n&lt;expression&gt; * &lt;expression&gt;\n两个表达式的积\n\n\n&lt;expression&gt; / &lt;expression&gt;\n两个表达式的整数除法商\n\n\n- &lt;expression&gt;\n表达式的负值\n\n\n:: &lt;expression&gt;\n表达式的按位取反\n\n\n&lt;value&gt;\n任意的值（参见3.3.2节\n\n\n3.3.4. 注释行注释以 // 或 ; 开头。\nC 语言风格的注释放在 /* 和 */ 之间。\n3.3.5. 标签标签的形式如下：\n&lt;symbol&gt;:\n或\nPUBLIC &lt;symbol&gt;:\n标签必须从行首开始。\n提示：标签实际上只是自动的 .define，其值设置为当前程序指令的偏移量。PUBLIC 的标签可以通过与 PUBLIC 的 .define 同样的方式从用户代码访问。\n3.3.6. 指令所有的 pioasm 指令都遵循以下格式：\n&lt;instruction&gt; (side &lt;side_set_value&gt;) ([&lt;delay_value])\n其中：\n&lt;instruction&gt; 是下一节介绍的汇编指令。（参见3.4节）\n&lt;side_set_valie&gt; 是一个值（参见3.3.2节），在指令开始时，该值将应用到 side_set 管脚。注意 side &lt;side_set_value&gt; 中的 side-set 值的规则依赖于该程序的 .side_set 指示（参见3.3.1节）。\n如果没有指定 .side_set，则 side &lt;side_set_value&gt; 就是无效的。如果指定了可选数量的 side-set 管脚，则允许使用 side &lt;side_set_value&gt;。如果指定了必须数量的 side-set 管脚，则 side &lt;side_set_value&gt; 是必须的。\n&lt;side_set_value&gt; 的值必须匹配 .side_set 标识中指定的 side-set 的比特数。\n&lt;delay_value&gt; 指定在指令执行完成后需要延时的时钟周期数。delay_value 是一个值（参见3.3.2节），通常在 0 ~ 31 之间（包含 0 和 31，是一个 5 比特的值），但是如果通过 .side_set 指示（参见3.3.1节）启用了 side-set，那么可用的比特数就会减少。如果不指定 &lt;delay_value&gt;，则指令没有延时。\n注意 pioasm 指令名称、关键字和标识不区分大小写。遵循 SDK 的风格，下面的“汇编语法”一节统一使用小写。\n注意 某些汇编语法中会出现都好，但逗号完全是可选的。例如 out pins, 3 可以写成 out pins 3，jmp x-- label 可以写成 jmp x--, label。“汇编语法”一节使用前一种格式。\n3.3.7 伪指令目前，pioasm 提供一条伪指令（pseudoinstruction），以方便编程：\nnop：汇编成 mov y, y。表示“无操作”。没有任何副作用，用于 side-set 操作，或额外的延时。\n3.4. 指令集3.4.1. 概要PIO 指令为 16 位，编码方式如下：\n\n所有 PIO 指令的执行时间都是一个时钟周期。\n5 比特的 Delay/side-set 字段的含义依赖于状态机的 SIDESET_COUNT 配置：\n\n最多 5 个 LSB 比特（5 减 SIDESET_COUNT）为当前指令和下一条指令之间插入的空闲周期数。\n最多 5 个 MSB 比特（由 SIDESET_COUNT 设置）为 side-set（参见3.5.1节），可以在该指令执行的同时，将某些 GPIO 管脚设置为某个常量。\n\n3.4.2. JMP3.4.2.1. 编码\n3.4.2.2. 操作如果 Condition 为真，则将程序计数器设置为 Address，否则无操作。\nJMP 上的延时周期不论 Condition 是否为真都会生效。延时在 Condition 被求值、程序计数器被更新后进行。\n\nCondition：\n000：（无条件）：永远跳转\n001：!X：当寄存器 X 为零时\n010：X--：当 X 非零时。判断后进行减一\n011：!Y：当寄存器 Y 为零时\n100：Y--：当 Y 非零时。判断后进行减一\n101：X!=Y：当 X 不等于 Y 时\n110：PIN：根据输入管脚跳转\n111：!OSRE：当输出移位寄存器非空时\n\n\nAddress：要跳转到的指令地址。在指令编码中，该值为 PIO 指令内存中的绝对地址。\n\nJMP PIN 会根据 EXECCTRL_JMP_PIN 选择的 GPIO 管脚进行跳转。EXECCTRL_JMP_PIN 是一个可配置选项，它从状态机可以使用的最多 32 个 GPIO 输入管脚中选择其中之一，供 JMP 使用。不依赖于状态机的其他输入映射。如果该 GPIO 为高电平，则跳转。\n!OSRE 将自上一次 PULL 以来移出的比特数，与移位计数阈值进行比较。移位计数阈值由 SHIFTCTRL_PULL_THRESH 配置。自动加载（autopull，参见3.5.4节）也通过该配置项配置。\nJMP X-- 和 JMP Y-- 总是会将寄存器 X 或 Y 减一。减一操作与可擦写寄存器的当前值无关。跳转条件是寄存器的初始值，即减一操作发生之前的值。如果寄存器最初为非零值，则发生跳转。\n3.4.2.3. 汇编语法jmp (&lt;cond&gt;) &lt;target&gt;\n其中：\n&lt;cond&gt; 是上节列出的可选的条件（例如，!x 表示可擦写寄存器 X 为零）。如果未指定条件，则总是跳转。\n&lt;target&gt; 是一个程序标签或值（参见3.3.2节），表示程序内部的指令偏移量（第一条指令的偏移量为 0）。注意，由于 PIO JMP 指令使用 PIO 指令内存之内的绝对地址，JMP 需要在运行时根据程序的加载偏移量进行调整。这一步在加载程序时由 SDK 负责，但在编码 JMP 指令供 OUT EXEC 使用时需要留意这一点。\n3.4.3. WAIT3.4.3.1. 编码\n3.4.3.2. 操作等待，直到条件满足。\n与所有等待指令一样（参见3.2.4节），延时周期在指令完成之后发生。也就是说，如果指定了延时周期，那么延时要直到等待条件满足之后才会开始。\n\nPolarity\n1：等待 1。\n0：等待 0。\n\n\nSource：指定要等待什么。可能的值有：\n00:GPIO：等待由 Index 选择的系统 GPIO 输入。该项为绝对 GPIO 索引，不受状态机的输入 IO 映射影响。\n01：PIN：由 Index 指定的输入管脚。首先会应用当前状态机的输入 IO 映射，然后利用 Index 选择要等待哪个输入比特。换句话说，选择的管脚就是 PINCTRL_IN_BASE 加上 Index，再对 32 取余。\n10：IRQ：等待由 Index 选择的 PIO IRQ 标志。\n11：JMPPIN：等待由PINCTRL_JMP_PIN配置的GPIO，可以设置一个0-3的偏移。加上偏移后不得超过32。(该模式不支持PIO version 0)\n\n\nIndex：要检查哪个管脚或比特。\n\nWAIT x IRQ 的行为与其他 WAIT 源略有不同：\n\n如果 Polarity 为 1，则在等待条件满足后，当前状态机会清除选择的 IRQ 标志。\n标志位索引的解码方式与 IRQ 的索引字段相同，从两个MSB进行解码：\n00: 最低三位用于要等待的当前PIO的IRQ标志编号。\n01(PREV): 最低三位指示的IRQ编号为上一个PIO的IRQ标志。\n10(REL):  最低三位的值加上状态机的编号再模4作为IRQ的编号进行等待。例如状态机2的最低3位的值为1，则将等待IRQ3。状态机3的最低三位为3，则将等待IRQ2。这样，允许同一个程序的不同状态机就可以相互同步。\n11(NEXT): 最低三位指示的IRQ编号为上一个PIO的IRQ标志。如果 MSB 被设置，则将状态机的 ID（0..3）加到 IRQ 索引上，加法采用两个 LSB 的模 4 加法。例如，状态机 2、标志值为 ‘0x11’，则等待标志 3，而标志值 ‘0x13’ 将等待标志 1。这样，运行同一个程序的多个状态机就可以互相同步。\n\n\n\n注意 WAIT 1 IRQ x 不应当使用供中断控制器使用的 IRQ 标志，以避免与系统中断处理函数的竞合冲突。\n3.4.3.3. 汇编语法wait &lt;polarity&gt; gpio &lt;gpio_num&gt;\nwait &lt;polarity&gt; pin &lt;pin_num&gt;\nwait &lt;polarity&gt; irq &lt;irq_num&gt; (rel, next, prev)\nwait &lt;polarity&gt; jmppin (+ &lt;pin_offset&gt;)\n其中：\n&lt;polarity&gt; 是一个值（参见3.3.2节），指定极性（0 或 1）\n&lt;pin_num&gt; 是一个值（参见3.3.2节），指定输入管脚的编号（在状态机输入管教映射中的编号）\n&lt;gpio_num&gt; 是一个值（参见3.3.2节），指定实际的 GPIO 管脚编号\n&lt;irq_num&gt; (rel) 是一个值（参见3.3.2节），指定要等待的 IRQ 编号（0 ~ 7）。如果设置了 rel，则实际的 IRQ 编号的计算方式为，将 IRQ 编号的最低两个比特（irq_num10）替换成和的最低两个比特（irq_num10 + sm_num10），其中 sm_num10 为状态机编号\n&lt;pin_offset&gt; 是一个值，用来添加到JMP_PIN上来获得实际需要等待的引脚编号\n3.4.4. IN3.4.4.1. 编码\n3.4.4.2. 操作从 Source 移位 Bit count 个比特到输入移位寄存器（ISR）中。移位方向由各个状态机的 SHIFTCTRL_IN_SHIFTDIR 决定。此外，增加输入移位计数器 Bit count，最大到 32。\n\nSource：\n000：PINS\n001：X（可擦写寄存器 X）\n010：Y（可擦写寄存器 Y）\n011：NULL（全零）\n100：保留\n101：保留\n110：ISR\n111：OSR\n\n\nBit count：要将多少比特移位到 ISR。值为 1 ~ 32 比特，32 编码为 00000。\n\n如果启用了自动推出（autopush），那么当达到推出阈值（SHIFTCTRL_PUSH_THRES）时，IN 还会将 ISR 的内容推出到 RX FIFO。不论自动推出是否发生，IN 的执行时间都是一个时钟周期。当自动推出发生，但 RX FIFO 满时，状态机会进入等待状态。自动推出会清空 ISR 的内容为全零，并且会清除输入移位计数器。参见3.5.4节。\nIN 永远使用源数据的最低 Bit count 个比特。例如，如果 PINCTRL_IN_BASE 设置为 5，那么指令 IN 3, PINS 会读取管脚 5、6 和 7，并将这些值移入 ISR。首先，ISR 会左移或右移，为新的输入数据腾出空间，然后将输入数据复制到腾出的空间中。输入数据的比特顺序与移位方向无关。\n使用 NULL 可以移位 ISR 的内容。例如，UART 会首先接受 LSB，因此必须右移。在执行 8 次 IN PINS, 1 指令后，输入的串行数据占据了 ISR 的 31..24 比特。此时，IN NULL, 24 指令将会移入 24 个零比特，将输入数据移到 ISR 的 7..0 比特。另一种方式是让处理器或 DMA 从 FIFO 地址 +3 的位置读取一个字节，这样可以读取 FIFO 内容的 31..24 比特。\n3.4.4.3. 汇编语法in &lt;source&gt;, &lt;bit_count&gt;\n其中：\n&lt;source&gt; 是上述源之一。\n&lt;bit_count&gt; 是一个值（参见3.3.2节，指定了要移位的比特数（有效值为 1 ~ 32）。\n3.4.5. OUT3.4.5.1. 编码\n3.4.5.2. 操作将 Bit count 个比特移出输入移位寄存器（OSR），并写入 Destination。此外，还会增加输出移位计数器 Bit count，直到最大值 32。\n\nDestination：\n000：PINS\n001：X（可擦写寄存器 X）\n010：Y（可擦写寄存器 Y）\n011：NULL（全零）\n100：PINDIRS\n101：PC\n110：ISR（同时设置 ISR 移位计数器为 Bit count）\n111：EXEC（将 OSR 的移位数据作为指令执行）\n\n\nBit count：要从 OSR 移出多少比特。值为 1..32 比特，32 编码为 00000。\n\n将一个 32 位值写入 Destination：低 Bit count 个比特来自 OSR，其余为零。如果 SHIFTCTRL_OUT_SHIFTDIR 为右，则该值为 OSR 的最低 Bit count 比特，否则为最高 Bit count 比特。\nPINS 和 PINDIRS 使用 OUT 的管脚映射，参见3.5.6节。\n如果启用自动加载（autopull），那么如果达到了加载阈值 SHIFTCTRL_PULL_THRESH，则自动从 TX FIFO 填充 OSR。同时输出移位计数器清零。在这种情况下，如果 TX FIFO 为空，则 OUT 会进入等待状态，但执行时间仍然为一个时钟周期。详情参考3.5.4节。\n有了 OUT EXEC，指令就可以放在 FIFO 数据流中。OUT 本身的执行需要一个时钟周期，然后下一个周期执行来自 OSR 的指令。该机制能执行的指令类型没有限制。最初的 OUT 指令的延时周期将被忽略，但之后执行的指令可以正常插入延时周期。\nOUT PC 相当于无条件跳转到 OSR 移出的值对应的地址。\n3.4.5.3. 汇编语法out &lt;destination&gt;, &lt;bit_count&gt;\n其中：\n&lt;destination&gt; 是上述目的地之一。\n&lt;bit_count&gt; 是一个值（参见3.3.2节，指定要移位的比特数（有效值为 1 ~ 32）。\n3.4.6. PUSH3.4.6.1. 编码\n3.4.6.2. 操作将 ISR 的内容作为一个 32 位字推出到 RX FIFO。同时将 ISR 清除为全零。\n\nIfFull：如果设置为 1，那么在输入移位计数器未达到阈值（SHIFTCTRL_PUSH_THRESH，与自动推出用的是同一个选项；参见3.5.4节），则什么都不做。\nBlock：如果设置为 1，那么在 RX FIFO 为满时，暂停执行。\n\nPUSH IFFULL 也能像自动推出（autopush）那样让程序更紧凑。如果启用了自动推出，会导致 IN 在不恰当的时候陷入等待状态，比如状态机需要在此时判断某种外部控制信号，那么 PUSH IFFULL 就能派上用场了。\nPIO 汇编器会默认设置 Block 位。如果 Block 位没有设置，则 PUSH 不会在 RX FIFO 满的情况下进入等待，而是会继续立即执行下一条指令。此时，FIFO 的状态和内容不变。ISR 仍被清空为全零，同时设置 FDEBUG_RXSTALL 标志（与 RX FIFO 满时进行阻塞 PUSH 或自动推出相同），表示数据已经丢失。\n3.4.6.3. 汇编语法push (iffull)\npush (iffull) block\npush (iffull) nonblock\n其中：\niffull 相当于上述 IfFull == 1。也就是说，不指定的情况下，默认值为 IfFull == 0\nblock 相当于上述 Block == 1。如果不指定 block 或 noblock，则此值为默认值\nnoblock 相当于上述 Block == 0。\n3.4.7. PULL3.4.7.1. 编码\n3.4.7.2. 操作从 TX FIFO 加载一个 32 位字到 OSR 中。\n\nIfEmpty：如果为 1，那么在输出移位计数器达到阈值（SHIFTCTRL_PULL_THRESH，与自动加载用的是同一个选项；参见3.5.4节），则什么都不做。\nBlock：如果设置为 1，那么在 TX FIFO 为空时，暂停执行。如果为 0，那么从空的 FIFO 中加载，将会把可擦写寄存器 X 的内容复制到 OSR。\n\n一些外设（UART、SPI等）应当在无数据时等待，有数据时进行加载；而另一些（I2S）则应当继续执行，而且最好是继续输出占位数据，或重复数据。这个行为可以通过 Block 参数实现。\n在空的 FIFO 上执行不阻塞的 PULL 相当于执行 MOV OSR, X。程序可以事先在寄存器 X 中加载适当的默认值，或在每次 PULL NOBLOCK 之后执行一次 MOV X, OSR，从而重复上一个有效的 FIFO 字，直到新的数据出现。\n如果在启用自动加载时，当 TX FIFO 为空时的 OUT 会导致程序在不恰当的地方等待，就能用 PULL IFEMPTY 解决问题。IfEmpty 可以像自动加载一样简化一些程序，例如可以去掉外层循环计数器，但是它能够控制暂停的发生位置。\n注意 当启用自动加载时，在 OSR 满的情况下任何 PULL 指令都是误操作，所以 PULL 指令可以作为一种屏障。OUT NULL, 32 可以显式地抛弃 OSR 的内容。更多细节参见3.5.4.2节。\n3.4.7.3. 汇编语法pull (ifempty)\npull (ifempty) block\npull (ifempty) noblock\n其中：\nifempty 相当于上述 IfEmpty == 1，即如果没有指定，则默认值为 IfEmpty == 0\nblock 相当于上述 Block == 1。如果不指定 block 或 noblock，则此值为默认值\nnoblock 相当于上述 Block == 0。\n3.4.8. MOV3.4.8.1. 编码\n3.4.8.2. 操作从 Source 复制数据到 Destination。\n\nDestination：\n000：PINS（使用与 OUT 相同的管脚映射）\n001：X（可擦写寄存器 X）\n010：Y（可擦写寄存器 Y）\n011：PINDIRS（使用与 OUT 相同的管脚映射）\n100：EXEC（将数据作为指令执行）\n101：PC\n110：ISR（该操作会重置输入移位计数器为零，意为空）\n111：OSR（该操作会重置输出移位寄存器为零，意为满）\n\n\nOperation：\n00：无\n01：求反（按位求补）\n10：反转比特顺序\n11：保留\n\n\nSource：\n000：PINS（使用与 IN 相同的管脚映射）\n001：X\n010：Y\n011：NULL\n100：保留\n101：STATUS\n110：ISR\n111：OSR\n\n\n\nMOV PC 会导致无条件跳转。MOV EXEC 的效果和 OUT EXEC（参见3.4.5节）相同，可以将寄存器的内容作为指令执行。MOV 指令自身需要一个时钟周期，Source 中的指令在下一个周期执行。MOV EXEC 上的延时周期会被忽略，但被执行的指令可以带有延时周期。\n源 STATUS 的值为全 1 或全 0，取决于某些状态机的状态，如 FIFO 满&#x2F;空等。可以通过 EXECCTRL_STATUS_SEL 配置。\nMOV 可以通过有限的几种方式操作传输的数据，由 Operation 参数指定。求反操作会将 Destination 中的每个比特设置为 Source 中对应比特的 NOT，也就是说，1 变成 0，0 变成 1。至于反转比特顺序，如果将比特编号为 0 ~ 31 的话，该操作可以将 Destination 中的每个比特 n 设置为 Source 中的比特 31 - n。\nMOV dst, PINS 使用IN引脚映射读取引脚的值，掩码为 SHIFTCTRL_IN_COUNT，读取到的最低位来自于 PINCTRL_IN_BASE，其余的依次高位就是对应更高位的pin，最高到达31。结果中超过 SHIFTCTRL_IN_COUNT 的位被设置为0。\nMOV PINDIRS, src 不支持PIO version 0。\n3.4.8.3. 汇编语法mov &lt;destination&gt;, (op) &lt;source&gt;\n其中：\n&lt;destination&gt; 是上述目的地之一。\n&lt;op&gt; 如果存在的话，为下列值之一：\n\n! 或 ~ 表示 NOT （注意：永远是按位求 NOT）\n:: 表示反转比特顺序\n\n&lt;source&gt; 是上述源之一。\n3.4.9. IRQ3.4.9.1. 编码\n3.4.9.2. 操作设置或清除由 Index 参数指定的 IRQ 标志。\n\nClear：如果为 1，则清除 Index 指定的标志，否则设置标志。如果指定了 Clear，则忽略 Wait 比特。\nWait：等待指定标志再次变成低，即，等待某个系统中断处理函数响应该标志。\nIndex：最低三个bit指定来IRQ的索引，值为0 ～ 7。\nIndex Mode：Index的高2为编号偏移模式，有4种情况：\n00: 默认值，最低三位的索引用于当前PIO的IRQ标志。\n01(PREV): 索引值用于前一个PIO的对应IRQ标志。\n10(REL): 最低三位值加上状态机编号再模4的值用于当前PIO的IRQ标志。\n11(NEXT): 索引值用于下一个PIO的对应IRQ标志。\n\n\n\nIRQ 标志 4 ~ 7 只能被状态机使用，而 IRQ 标志 0 ~ 3 可以作为系统级别的中断，在 PIO 的两个外部中断请求线之一上使用，具体采用哪个外部中断请求线，由 IRQ0_INTE 和 IRQ1_INTE 配置。\nNEXT&#x2F;PREV模式可以再不同PIO之间进行同步，如果这些待同步的PIO状态机设置了时钟分频，则其分频配置必须相同，并且需要通过写入CTRL.NEXTPREV_CLKDIV_RESTART及相关的NEXT_PIO_MASK&#x2F;PREV_PIO_MASK位来同步时钟。需要注意的是，跨PIO同步在非安全代码中具有不同可访问性的PIO之间将被阻断。（NEXT&#x2F;PREEV模式不适用PIO version 0）\n模 4 加法可以实现 IRQ 和 WAIT 指令的“相对寻址”，用于运行同一个程序的不同状态机之间的同步。\n如果设置了 Wait，则 Delay 周期会等到等待期间结束后再开始。\n3.4.9.3. 汇编语法irq &lt;irq_num&gt; (prev, rel, next)\nirq set &lt;irq_num&gt; (prev, rel, next)\nirq nowait &lt;irq_num&gt; (prev, rel, next)\nirq wait &lt;irq_num&gt; (prev, rel, next)\nirq clear &lt;irq_num&gt; (prev, rel, next)\n其中：\n&lt;irq_num&gt; (rel) 是一个值（参见3.3.2节），指定要等待的 IRQ 编号（0 ~ 7）。如果存在 rel，则实际的 IRQ 编号的计算方式为，将 IRQ 编号（irq_num10）的最低两比特替换为（&lt;irq_num10 + sm_num10）的最低两比特，其中 sm_num10 为状态机编号\nirq 表示设置 IRQ，无需等待\nirq set 也表示设置 IRQ，无需等待\nirq nowait 还是表示设置 IRQ，无需等待\nirq wait 表示设置 IRQ，然后等待 IRQ 被清除后再继续\nirq clear 表示清除 IRQ\n3.4.10. SET3.4.10.1. 编码\n3.4.10.2. 操作将一个数 Data 写入到 Destination。\n\nDestination：\n000：PINS\n001：X（可擦写寄存器 X）5 个 LSB 比特写入 Data，其他比特清为 0。\n010：Y（可擦写寄存器 Y）5 个 LSB 比特写入 Data，其他比特清为 0。\n011：保留\n100：PINDIRS\n101：保留\n110：保留\n111：保留\n\n\nData: 设置到管脚或寄存器的 5 比特的立即数。\n\n该指令用于设置控制信号，如时钟或芯片选择，或初始化循环计数器。由于 Data 只有 5 比特，因此可擦写寄存器可以 SET 的值为 0 ~ 31，最大可循环 32 次。\nSET 和 OUT 的管脚映射是独立配置的。它们可以映射到不同的位置，例如，一个管脚作为时钟信号使用，另一个作为数据使用。它们的管脚范围也可以重叠：UART 传输程序可以使用 SET 来设置开始和终止比特，用 OUT 指令向同一个管脚上移出 FIFO 数据。SET指令最多可以控制5个管脚的输出和方向。\n3.4.10.3. 汇编格式set &lt;destination&gt;, &lt;value&gt;\n其中：\n&lt;destination&gt; 为上述目的地之一。\n&lt;value&gt; 是要设置的值（参见3.3.2节），有效值为 0 ~ 31。\n3.4.11. MOV(to RX)3.4.11.1. 编码未添加。\n3.4.11.2. 操作将ISR寄存器按照选定的位置写入RXFIFO。状态机可以按照任意顺序写入RXFIFO，由Y寄存器或立即数进行索引。前提是需要对SHIFTCTRL_FJOIN_RX_PUT字段进行配置，否则该操作未定义。\n注意，RXFIFO存储寄存器只有一个读端口和写端口，任何时候每个端口的访问都值分配给其中一个（系统或状态机）。\n3.4.11.3. 汇编格式mov rxfifo[y], isrmov rxfifo[&lt;index&gt;], isr\n其中：\ny 表示RXFIFO由y寄存器来索引&lt;index&gt; 使用一个立即数对RXFIFO进行索引，有效值是0～3。\n3.4.12. MOV(from RX)3.4.12.1. 编码未添加。\n3.4.12.2. 操作将所选的RXFIFO条目保存到OSR寄存器。PIO可以按照任意顺序读取RXFIFO，由Y寄存器或立即数进行索引。前提是需要对SHIFTCTRL_FJOIN_RX_GET字段进行配置，否则该操作未定义。\n3.4.12.3. 汇编格式mov osr, rxfifo[y]\nmov osr, rxfifo[&lt;index&gt;]\n其中：\ny 表示RXFIFO由y寄存器来索引&lt;index&gt; 使用一个立即数对RXFIFO进行索引，有效值是0～3。\n3.5. 功能详解3.5.1. Side-setSide-set 特性可以让状态机在执行主指令的同时，改变最多 5 个管脚的电平或方向。\n需要使用 side-set 的例子之一就是高速 SPI 接口，其数据比特从 OSR 推出到 GPIO，而时钟信号转换（从 1 到 0， 或从 0 到 1）必须与此同时发生。\n此时，一个带有 side-set 的 OUT 就能同时完成两项任务。\n这样可以保证接口的时序更精确，减小整体的程序大小（因为不需要独立的 SET 指令设置时钟管脚），而且提高了 SPI 能支持的最大频率。\nSide-set 还可以让 GPIO 映射更灵活，因为它的映射独立于 SET 的映射。示例 I2C 代码在禁止时钟拉伸（clock streching）的情况下，可以将 SDA 和 SCL 映射到任意管脚上。\n正常情况下，SCL 反转用于同步数据传输，而 SDA 包含移出的数据比特。但是，一些特定的 I2C 序列，如 Start 和 Stop 线条件，需要在 SDA 和 SCL 上产生特定的脉冲。I2C 通过如下映射来实现这一点：\n\nSide-set → SCL\nOUT → SDA\nSET → SDA\n\n这样，状态机就可以在 SDA 上提供两种情况的数据，在 SCL 上提供时钟，或者同时在 SDA 和 SCL 上提供固定的转换，同时依然允许 SDA 和 SCL 被映射到任意两个 GPIO 上。\nSide-set 数据编码到每条指令的 Delay/side-set 字段。任何指令都可以与 side-set 组合，包括 OUT PINS、SET PINS 等写入管脚的指令。\nSide-set 的管脚映射独立于 OUT 和 SET 的映射，但它们可以重叠。如果 side-set 和 OUT 或 SET 同时写入同一个管脚，则采用 side-set 的数据。\n注意 如果指令进入等待状态，side-set 依然会立即生效。\n1 .program spi_tx_fast2 .side_set 13 4 loop:5     out pins, 1   side 06     jmp loop      side 1\n\nspi_tx_fast 示例展示了 side-set 的两个优势：数据和时钟可以更精确地对齐，并且程序整体上可以更快，本例中每两个系统时钟周期就能输出一比特。程序也可以更小。\n使用 side-set 时需要配置四个选项：\n\nDelay/side-set 字段用于 side-set 而不是延时的 MSB 比特数。通过 PINCTRL_SIDESET_COUNT 设置。如果设置为 5，则无法使用延时周期。如果设置为 0，则无法使用 side-set。\n是否使用最高比特作为有效位。Side-set 只有在设置了有效位的指令上生效。如果不使用有效位，则当 SIDESET_COUNT 不为零时，该状态机上的所有指令都会执行 side-set。该选项由 EXECCTRL_SIDE_EN 设置。\n映射到 side-set 最低比特的 GPIO 编号。由 PINCTRL_SIDESET_BASE 设置。\nside-set 写入到 GPIO 电平还是 GPIO 方向。由 EXECCTRL_SIDE_PINDIR 设置。\n\n上述示例中，我们只设置了一个 side-set 比特，每条指令都执行 side-set，因此不需要有效位。SIDESET_COUNT 为 1，SIDE_EN 为假。SIDE_PINDIR 为假，因为我们要驱动时钟信号的高低电平，而不是高低阻抗。SIDESET_BASE 为时钟信号对应的 GPIO 管脚编号。\n3.5.2. 程序折返PIO 程序通常有一个“外层循环”：在 FIFO 和外部之间传输数据时，它们需要反复执行同样的步骤。最小的示例就是前面的方波示例：\nPico 示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave.pio 第7-12行\n\n 7 .program squarewave 8     set pindirs, 1 ; Set pin to output 9 again:10     set pins, 1 [1] ; Drive pin high and then delay for one cycle11     set pins, 0 ; Drive pin low12     jmp again ; Set PC to label `again`\n\n程序的主题部分设置管脚为高，然后设置为低，从而产生方波的一个周期。然后整个程序进行循环，以产生周期性的输出。跳转指令本身需要一个周期，每个 set 指令也需要一个周期，所以为了保证高低部分的长度相同，set pins, 1 指令增加了一个周期的延时，使状态机在执行 set pins, 0 指令之前等待一个周期。每次循环总共需要 4 个周期。这里有两个问题：\n\nJMP 占用了本可用于其他程序的指令内存\n执行 JMP 所需的额外周期导致最大输出速度降低了一半\n\n由于程序计数器（PC）超过 31 时会自动折返为 0，因此将整个指令内存填充为 set pins, 1 和 set pins, 0，就能解决第二个问题，但这样很浪费。状态机有一个硬件特性，通过配置 EXECCTRL 控制寄存器，就能解决大部分情况下的问题。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave_wrap.pio 第11-19行\n\n11 .program squarewave_wrap12 ; Like squarewave, but use the state machine&#x27;s .wrap hardware instead of an13 ; explicit jmp. This is a free (0-cycle) unconditional jump.14 15     set pindirs, 1    ; Set pin to output16 .wrap_target17     set pins, 1 [1]   ; Drive pin high and then delay for one cycle18     set pins, 0 [1]   ; Drive pin low and then delay for one cycle19 .wrap\n\n在执行完程序内存中的一条指令后，状态机会使用以下逻辑更新 PC：\n\n如果当前指令为 JMP，且 Condition 为真，则设置 PC 为 Target\n否则，如果 PC 等于 EXECCTRL_WRAP_TOP，则设置 PC 为 EXECCTRL_WRAP_BOTTOM\n否则，PC 加一，但如果当前值为 31，则设置为 0。\n\npioasm 中的 .wrap_target 和 .wrap 汇编标识实际上是标签。它们会导出常量，以写入到 WRAP_BOTTOM 和 WRAP_TOP中。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/generated/squarewave_wrap.pio.h 第1-37行\n\n// -------------------------------------------------- //// This file is autogenerated by pioasm; do not edit! //// -------------------------------------------------- //#pragma once#if !PICO_NO_HARDWARE#include &quot;hardware/pio.h&quot;#endif// --------------- //// squarewave_wrap //// --------------- //#define squarewave_wrap_wrap_target 1#define squarewave_wrap_wrap 2static const uint16_t squarewave_wrap_program_instructions[] = &#123;    0xe081, //  0: set    pindirs, 1                             //     .wrap_target    0xe101, //  1: set    pins, 1                [1]     0xe100, //  2: set    pins, 0                [1]             //     .wrap&#125;;#if !PICO_NO_HARDWAREstatic const struct pio_program squarewave_wrap_program = &#123;    .instructions = squarewave_wrap_program_instructions,    .length = 3,    .origin = -1,&#125;;static inline pio_sm_config squarewave_wrap_program_get_default_config(uint offset) &#123;    pio_sm_config c = pio_get_default_sm_config();    sm_config_set_wrap(&amp;c, offset + squarewave_wrap_wrap_target, offset + squarewave_wrap_wrap);    return c;&#125;#endif\n\n这是 PIO 汇编器 pioasm 产生的原始输出，它创建了一个默认的 pio_sm_config 对象，其中包含了程序代码中的 WRAP 寄存器值。也可以直接初始化控制寄存器字段。\n注意 WRAP_BOTTOM 和 WRAP_TOP 是 PIO 指令内存中的绝对地址。如果程序加载到某个偏移量，那么必须相应地调整折返地址。\nsquarewave_wrap 示例中插入了延时周期，所以它的行为与原版 squarewave 程序完全相同。但由于使用了程序折返，我们现在可以去掉延时，这样输出的速度就是以前的两倍，同时还能维持高电平和低电平的时间相等。\nPico示例：https://github.com/raspberrypi/pico-examples/tree/master/pio/squarewave/squarewave_fast.pio 第12-18行\n\n12 .program squarewave_fast13 ; Like squarewave_wrap, but remove the delay cycles so we can run twice as fast.14     set pindirs, 1    ; Set pin to output15 .wrap_target16     set pins, 1       ; Drive pin high17     set pins, 0       ; Drive pin low18 .wrap\n\n3.5.3. FIFO 合并默认情况下，每个状态机拥有两个 4 字长的 FIFO：一个用于将数据从系统传送到状态机（TX），一个用于反方向（RX）。但是，很多程序并不需要系统和状态机之间的双向数据传输，而更长的 FIFO 却很有用，特别是在 DPI 这种高带宽的接口中。在这些情况下，可以通过 SHIFTCTRL_FJOIN 选项将两个 4 字长的 FIFO 合并为一个 8 字长的 FIFO。\n\n\n\n\n\n\n\n图42. 可合并的双 FIFO。每个 FIFO 为 4 字长，包括 4 个数据寄存器、一个 1：4 解码器和一个 4:1 多路复用器。多路复用可以在 TX 和 RX 通道之间进行写数据和读数据操作，这样所有 8 个字都可以从两个端口进行访问。\n\n\n另一个用例是 UART。由于 UART 的 TX&#x2F;CTS 和 RX&#x2F;RTS 部分是异步的，因此它们是在两个独立的状态机上实现的。而让每个状态机的一半 FIFO 资源空闲，是一种浪费。由于我们可以将两个 FIFO 合并成一个 TX FIFO 供 TX&#x2F;CTS 状态机使用，或者合并成一个 RX FIFO 供 RX&#x2F;RTS 状态机使用，这样就能利用全部资源。而拥有 8 字深 FIFO 的 UART 能够处理的中断数量是 4 字深 FIFO 的 UART 的两倍。\n增加 FIFO 的深度（从 4 增加到 8）后，同一个状态机中的另一个 FIFO 的大小就变为零。例如，如果将 FIFO 合并供 TX 使用，那么就无法使用 RX FIFO，任何 PUSH 指令都会陷入等待状态。在 FSTAT 寄存器中，RX FIFO 同时表现为 RXFULL 和 RXEMPTY 状态。而合并到 RX 的情况正相反：TX FIFO 不可用，该状态机的 FSTAT 中 TXFULL 和 TXEMPTY 比特均为设置状态。\n只要 DMA 没有因为其他竞合状态而变慢，那么 8 字 FIFO 足够通过 RP2040 的 DMA 实现每个周期 1 字的速率。\n注意 改变 FJOIN 会抛弃当前状态机的 FIFO 中的一切数据。如果数据不能恢复，那么必须事先清空 FIFO 队列。\n3.5.4. 自动推出和自动加载随着 OUT 指令的执行，数据移出，OSR 会逐渐清空。OSR 为空后必须加载数据，比如通过 PULL 指令从 TX FIFO 传输一个字的数据到 OSR。类似地，ISR 为满后也必须清空。一种方法是，在移位一定数量的数据之后，通过循环执行一次 PULL：\n 1 .program manual_pull 2 .side_set 1 opt 3  4 .wrap_target 5     set x, 2                     ; X = bit count - 2 6     pull            side 1 [1]   ; Stall here if no TX data 7 bitloop: 8     out pins, 1     side 0 [1]   ; Shift out data bit and toggle clock low 9     jmp x-- bitloop side 1 [1]   ; Loop runs 3 times10     out pins, 1     side 0       ; Shift out last bit before reloading X11 .wrap\n\n该程序按照每 4 个时钟周期 1 比特的速率，从每个 FIFO 字中移出 4 比特，同时输出时钟信号。当 TX FIFO 为空时，程序在时钟高电平处暂停（注意在指令暂停的周期上 side-set 依然会生效）。图43演示了状态机执行该程序的过程。\n\n\n\n\n\n\n\n图43. manual_pull 程序的执行过程。X 是循环计数器。每次循环会移出一比特数据，然后将时钟拉低，再拉高。每条指令都有一个周期的延时，因此整个循环需占用四个时钟周期。在第三次循环后，移出第四比特，然后状态机立即返回程序开头，重置循环计数器，并加载新的数据，同时维持每比特 4 个时钟周期的节奏。\n\n\n该程序有一些限制：\n\n它占用了 5 个指令槽，但只有 2 个是有用的（out pins, 1 set 0 和 ... set 1），用于输出串行数据和时钟信号。\n它的吞吐量的上限为系统时钟频率除以 4，因为它需要额外的周期来加载新数据并重新设置循环计数器。\n\n这是非常常见的一种 PIO 程序，所以没个状态机都有一些额外的硬件来处理这种情况。状态机会跟踪从 OSR OUT 出的比特数，以及 IN 进 ISR 的比特数，在这些计数器达到某个可配置的阈值后，执行特定的动作。\n\n在执行 OUT 指令时，如果达到或超过加载的阈值，且 TX FIFO 中有数据的话，状态机就会同时将 TX FIFO 中的数据加载到 OSR 中。\n在执行 IN 指令时，如果达到或超过推出的阈值，且 RX FIFO 中有数据的话，状态机可以直接将移位结果写入 RX FIFO 中，并清除 ISR。\n\n利用自动加载（autopull）功能，manual_pull 示例可以重写如下：\n1 .program autopull2 .side_set 13 4 .wrap_target5     out pins, 1    side 0      [1]6     nop            side 1      [1]7 .wrap\n\n这个程序比原版本更短、更简单，而且如果去掉延时的话，运行速度是原版本的两倍，因为通过硬件加载 OSR 是“免费”的。注意程序并不知道下一次加载之前需要移位多少比特；硬件会在达到配置好的阈值（SHIFTCTRL_PULL_THRESH）后自动加载，所以示例程序也可以从每个 FIFO 字中移出 16 比特或 32 比特。\n最后，注意上述程序与原本并非完全相同，因为它会在时钟信号低时暂停，而不是高的时候。我们可以通过 PULL IFEMPTY 指令改变暂停位置，该指令使用与自动加载（autopull）同样的可配置阈值：\n1 .program somewhat_manual_pull2 .side_set 13 4 .wrap_target5     out pins, 1    side 0      [1]6     pull ifempty   side 1      [1]7 .wrap\n\n下面是完整的示例（PIO 程序，以及一个用于加载它并运行的 C 程序），演示了如何在同一个状态机上同时启用自动加载（autopull）和自动推出（autopush）。状态机 0 的功能是将数据从 TX FIFO 传输至 RX FIFO，吞吐量为每两个时钟周期一个字。该程序还演示了当 OSR 和 TX FIFO 均为空时，状态机会在执行 OUT 时进入暂停状态。\n1 .program auto_push_pull2 3 .wrap_target4     out x, 325     in x, 326 .wrap\n#include &quot;tb.h&quot; // TODO this is built against existing sw tree, so that we get printf etc#include &quot;platform.h&quot;#include &quot;pio_regs.h&quot;#include &quot;system.h&quot;#include &quot;hardware.h&quot;#include &quot;auto_push_pull.pio.h&quot;int main()&#123;    tb_init();    // Load program and configure state machine 0 for autopush/pull with    // threshold of 32, and wrapping on program boundary. A threshold of 32 is    // encoded by a register value of 00000.    for (int i = 0; i &lt; count_of(auto_push_pull_program); ++i)        mm_pio-&gt;instr_mem[i] = auto_push_pull_program[i];    mm_pio-&gt;sm[0].shiftctrl =            (1u &lt;&lt; PIO_SM0_SHIFTCTRL_AUTOPUSH_LSB) |            (1u &lt;&lt; PIO_SM0_SHIFTCTRL_AUTOPULL_LSB) |            (0u &lt;&lt; PIO_SM0_SHIFTCTRL_PUSH_THRESH_LSB) |            (0u &lt;&lt; PIO_SM0_SHIFTCTRL_PULL_THRESH_LSB);    mm_pio-&gt;sm[0].execctrl =            (auto_push_pull_wrap_target &lt;&lt; PIO_SM0_EXECCTRL_WRAP_BOTTOM_LSB) |            (auto_push_pull_wrap &lt;&lt; PIO_SM0_EXECCTRL_WRAP_TOP_LSB);    // Start state machine 0    hw_set_bits(&amp;mm_pio-&gt;ctrl, 1u &lt;&lt; (PIO_CTRL_SM_ENABLE_LSB + 0));    // Push data into TX FIFO, and pop from RX FIFO    for (int i = 0; i &lt; 5; ++i)        mm_pio-&gt;txf[0] = i;    for (int i = 0; i &lt; 5; ++i)        printf(&quot;%d\\n&quot;, mm_pio-&gt;rxf[0]);    return 0;&#125;\n\n图44展示了状态机执行该程序的过程。初始时，OSR 为空，所以状态机会在第一条 OUT 指令处等待。当 TX FIFO 中有数据时，状态机会将数据传输到 OSR 中。在下一个周期，OUT 可以利用 OSR 中的数据执行（本例中将数据传输到可擦写寄存器 X 中），同时状态机会使用 FIFO 中的新数据填充 OSR。由于每一条 IN 指令都会立即填充 ISR，因此 ISR 一直为空，IN 就会直接把数据从 X 传输到 RX FIFO。\n\n\n\n\n\n\n\n图44. auto_push_pull 程序的执行过程。状态机会在 OUT 上暂停，直到数据从 TX FIFO 进入 OSR。然后，每次执行 OUT 操作，由于其比特数为 32，因此 OSR 都会同时自动加载，而 IN 的数据会越过 ISR，直接进入 RX FIFO。当 FIFO 空且 OSR 也为空时状态机会暂停。\n\n\n为了在正确的时间触发自动推出或自动加载，状态机会使用一对 6 比特计数器跟踪 ISR 和 OSR 的总移位数。\n\n复位后，或在 CTRL_SM_RESTART 时，ISR 移位计数器设置为 0 （尚未移入任何数据），OSR 移位计数器设置为 32 （没有任何待移出数据）\nOUT 指令会给 OSR 移位计数器增加 Bit count\nIN 指令会给 ISR 移位计数器增加 Bit count\nPULL 指令或自动加载会将 OSR 计数器清为 0\nPUSH 指令或自动推出会将 ISR 计数器清为 0\nMOV OSR, x 或 MOV ISR, x 会将 OSR 或 ISR 移位计数器清为 0\nOUT ISR, n 指令会将 ISR 移位计数器设置为 n\n\n在执行任何 OUT 或 IN 指令时，状态机都会将移位计数器与 SHIFTCTRL_PULL_THRESH 和 SHIFTCTRL_PUSH_THRESH 比较，来决定是否要采取动作。自动加载和自动推出分别由 SHIFTCTRL_AUTOPULL 和 SHIFTCTRL_AUTOPUSH 字段启用。\n3.5.4.1. 自动推出详解下面是启用了自动推出（autopush）的 IN 指令的伪代码：\nisr = shift_in(isr, input())isr count = saturate(isr count + in count)if rx count &gt;= threshold:    if rx fifo is full:        stall    else:        push(isr)        isr = 0        isr count = 0\n\n注意硬件平台执行上述步骤只需要一个机器时钟周期（除非出现暂停）。\n阈值的范围为 1 ~ 32。\n3.5.4.2. 自动加载详解在非 OUT 周期，硬件执行以下伪代码：\nif MOV or PULL:    osr count = 0if osr count &gt;= threshold:    if tx fifo not empty:        osr = pull()        osr count = 0\n\n因此，自动加载可以在两个 OUT 之间的任何点发生，取决于数据何时到达 FIFO。\n在 OUT 周期，步骤略有不同：\nif osr count &gt;= threshold:    if tx fifo not empty:        osr = pull()        osr count = 0    stallelse:    output(osr)    osr = shift(osr, out count)    osr count = saturate(osr count + out count)    if osr count &gt;= threshold:        if tx fifo not empty:            osr = pull()            osr count = 0\n\n硬件能够在移出全部数据的同时填充 OSR，因为这两个操作可以并行执行。但是，硬件无法在同一个周期执行填充 OSR 并 ‘OUT’ 同一份数据，因为这样做会造成很长的逻辑链。\n可以认为，对于程序而言，填充操作是异步的，但 ‘OUT’ 就像一个数据屏障，状态机永远不能 OUT 尚未写入 FIFO 的数据。\n注意，在自动加载启用时，从 OSR ‘MOV’ 的操作是未定义的；根据与系统 DMA 的竞合状态，你可能会读到尚未移出的残留数据，或读到 FIFO 的新数据。与此类似，’MOV’ 到 OSR 的操作可能会覆盖刚刚自动加载进来的数据。但是，’MOV’ 进 OSR 的数据永远不会被覆盖，因为 ‘MOV’ 会更新移位计数器。\n如果你确实需要读取 OSR 的内容，应当显式地执行某种 ‘PULL’。上面描述的不确定性是由硬件自动进行加载的代价。启用自动加载会改变 ‘PULL’ 的行为：如果 OSR 为满，则 PULL 为误操作。这样做是为了避免与系统 DMA 之间的竞合冲突。它就像一个屏障：或者自动加载已经开始执行，此时 ‘PULL’ 操作无效；或者程序会在 ‘PULL’ 指令处等待，直到 FIFO 有数据。\n‘PUSH’ 不存在相似的行为，因为自动推出没有这种不确定性。\n3.5.5. 时钟分频器PIO 依靠系统时钟运行，但对于绝大多数接口来说，系统时钟太快了，而可插入的 Delay 周期数是有限的。像 UART 等设备需要精确地控制并改变信号的速率，最好是运行同一个程序的多个状态机也能够独立地改变速率。因此，每个状态机都有一个独立的时钟分频器。\n时钟分频器不会降低系统时钟速率，而是定义了多少个系统时钟周期等于执行 PIO 程序的“一个周期”。它会产生一个时钟允许信号，该信号能够在每个系统时钟周期暂停或恢复执行。时钟分频器会以一定的间隔产生允许脉冲，从而状态机能够以某个固定的、比系统时钟慢很多的速率运行。\n时钟分频器可以简化状态机与系统之间的接口，降低延迟，而且占用的芯片面积很小。在时钟允许信号为低电平时，状态机完全处于空闲状态，不过系统仍然可以访问状态机的 FIFO 并改变其配置。\n时钟分频器支持 16 比特整数、8 比特分数，小数分频器采用一阶积分-微分（first-order delta-sigma）。时钟分割比例可以在 1 ~ 65536 之间以 1&#x2F;256 的增量改变。\n如果时钟分割比例设置为 1，则状态机在每个时钟周期都会执行，即全速执行：\n\n\n\n\n\n\n\n图45. 时钟分割比例为 1 时的状态机执行情况。通过 CTRL 寄存器允许状态机之后，每个时钟周期其时钟允许信号都为高。\n\n\n通常，整数分割比例会让状态机以每 n 个时钟周期等于 1 个执行周期的速率执行，因此有效时钟速率为 fsys &#x2F; n。\n\n\n\n\n\n\n\n图46. 整数时钟分割比例产生一个周期性的时钟允许信号。时钟分频器会不断地从 n 开始递减，在到达 1 时产生一个允许脉冲。\n\n\n分数分割比例会维持稳定的 n + f &#x2F; 256 的分割速率，其中 n 和 f 是该状态机的 CLKDIV 寄存器的整数和分数部分。它会有选择地在 n 个周期到 n+1 个周期之间延长某个分割期间。\n\n\n\n\n\n\n\n图47. 分数时钟分割比例，平均分割比例为 2.5。时钟分频器会在每个分割周期上改变分数部分的值，当到达 1 时，则给整数部分加 1，以延长下一个分割周期。\n\n\n对于较小的 n，分数分割比例导致的抖动可能是无法接受的。但是，当分割比例很大时，抖动几乎可以忽略不计。\n注意 对于高速异步串口来说，最好使用偶数分割比例，或 1M 波特的整数倍，而不要使用传统的 300 的倍数，以避免不必要的抖动。\n3.5.6. GPIO 映射在内部，PIO 有一个 32 位寄存器，表示它能驱动的每个 GPIO 管脚的输出电平，以及另一个寄存器表示每个输出允许的情况（高低阻抗）。在每个系统时钟周期，每个状态机都可以写入这些寄存器中的部分或全部 GPIO。\n\n\n\n\n\n\n\n图48. 状态机有两个独立的输出通道，一个由 OUT&#x2F;SET 共享，另一个由 side-set 使用（可在任何时刻发生）。三个独立的映射（每个映射包括第一个 GPIO 管脚号和 GPIO 个数）控制 OUT、SET 和 side-set 被定向到哪个 GPIO。输入数据会根据哪个 GPIO 被映射到 IN 数据的 LSB 进行旋转。\n\n\n输出电平和输出允许寄存器的写数据和写掩码来自以下来源：\n\n一条 OUT 指令，最多能写 32 比特。根据指令的 Destination 字段，该指令可以应用于管脚或管脚方向。OUT 数据的最低位映射到 PINCTRL_OUT_BASE，向后依次映射 PINCTRL_OUT_COUNT 个比特，在到达 GPIO31 后折返。\n一条 SET 指令，最多能写 5 比特。根据指令的 Destination 字段，该指令可以应用于管脚或管教方向。SET 数据的最低位映射到 PINCTRL_SET_BASE，向后依次映射 PINCTRL_SET_COUNT 个比特，在到达 GPIO31 后折返。\n一个 side-set 操作，最多能写 5 比特。根据 EXECCTRL_SIDE_PINDIR 寄存器字段的值，该操作可以应用于管脚或管教方向。side-set 数据的最低位映射到 PINCTRL_SIDESET_BASE，向后依次映射 PINCTRL_SIDESET_COUNT 个比特，在到达 GPIO31 后折返。\n\n每个 OUT&#x2F;SET&#x2F;side-set 操作都会写连续的管脚区间，但每个区间都在 32 比特的 GPIO 空间内有独立的大小和位置。对于大多数应用来说，这已经足够灵活了。例如，如果一个状态机在一组管脚上实现了像 SPI 等接口，那么另一个状态机可以运行同一个程序，映射到另一组管脚上，提供第二个 SPI 接口。\n在任意时钟周期，状态机可以执行一次 OUT 或 SET，并且可以同时执行一次 side-set。管脚映射逻辑会生成一个 32 比特的写掩码，并根据情趣内容和管脚映射配置，将输出电平和输出允许寄存器写入数据总线。\n如果同一个状态机在同一个时钟周期内的 side-set 操作与 OUT&#x2F;SET 操作重叠，那么在重叠的区域中 side-set 优先。\n3.5.6.1. 输出优先级\n\n\n\n\n\n\n图49. 每个状态机对于每个 GPIO 通过写掩码选择优先级。每个 GPIO 会考虑来自四个状态机的写入电平和方向，然后应用编号最大的状态机的值。\n\n\n每个状态机在每个周期会通过其管脚映射硬件执行一次 OUT&#x2F;SET 和 side-set。这样，每个状态机都会为 GPIO 输出电平和输出允许寄存器生成 32 比特的写数据和写掩码。\n对于每个 GPIO，PIO 会考虑来自所有四个状态机的写操作，然后应用编号最大的状态机的写操作。这一步骤是针对输出电平和输出值分别进行的，所以可能出现在同一个周期内一个状态机同时改变了同一个管脚的电平和方向（例如通过同时发出的 SET 和 side-set），或一个状态机改变了 GPIO 方向，另一个状态机改变了同一个 GPIO 的电平。如果没有状态机写入 GPIO 的电平或方向，则值保持不变。\n3.5.6.2. 输入映射IN 指令收到的数据的方式是，LSB 映射到 PINCTRL_IN_BASE 设置的 GPIO，后续的更高位来自后续更高编号的 GPIO，到达 31 时折返。\n换句话说，IN 总线是 GPIO 输入值根据 PINCTRL_IN_BASE 的右旋结果。如果不够 32 个 GPIO，则 PIO 输入会在相应位置上填充 0， 以补齐 32 比特。\n像 WAIT GPIO 等指令会使用绝对 GPIO 编号，而不是 IN 数据总线中的索引。此时不会进行右旋。\n3.5.6.3. 输入同步器为了保证 PIO 的稳定性，每个 GPIO 输入都有两个标准 2-fliplop 同步器。这会导致输入采样延迟两个周期，但好处是，状态机可以在任何时刻执行 IN PINS，而且只会看到干净的高低电平，而不会看到可能会影响状态机电路的中间值。对于 UART RX 等异步接口来说这一点非常重要。\n有时某些 GPIO 可能需要跳过同步器。这样可以减少延迟，但用户必须自行保证状态机不会在错误的时刻进行采样。通常，只有 SPI 等同步接口才能做到这一点。设置 INPUT_SYNC_BYPASS 中的相应比特即可跳过同步器。\n警告 对不稳定的输入进行采样会导致不可预测的状态机行为，应当避免这种情况。\n3.5.7. 强制指令和被 EXEC 的指令除了指令内存外，状态机还可以从其他三个来源执行指令：\n\nMOV EXEC 可以从 Source 指定的某个寄存器执行指令\nOUT EXEC 可以执行 OSR 移出的数据\n从 SMx_INSTR 控制寄存器执行指令，系统可以将指令直接写入该寄存器，以立即执行\n\n 1 .program exec_example 2  3 hang: 4     jmp hang 5 execute: 6     out exec, 32 7     jmp execute 8  9 .program instructions_to_push10 11     out x, 3212     in x, 3213     push\n\n#include &quot;tb.h&quot; // TODO this is built against existing sw tree, so that we get printf etc#include &quot;platform.h&quot;#include &quot;pio_regs.h&quot;#include &quot;system.h&quot;#include &quot;hardware.h&quot;#include &quot;exec_example.pio.h&quot;int main()&#123;    tb_init();    for (int i = 0; i &lt; count_of(exec_example_program); ++i)        mm_pio-&gt;instr_mem[i] = exec_example_program[i];    // Enable autopull, threshold of 32    mm_pio-&gt;sm[0].shiftctrl = (1u &lt;&lt; PIO_SM0_SHIFTCTRL_AUTOPULL_LSB);    // Start state machine 0 -- will sit in &quot;hang&quot; loop    hw_set_bits(&amp;mm_pio-&gt;ctrl, 1u &lt;&lt; (PIO_CTRL_SM_ENABLE_LSB + 0));    // Force a jump to program location 1    mm_pio-&gt;sm[0].instr = 0x0000 | 0x1; // jmp execute    // Feed a mixture of instructions and data into FIFO    mm_pio-&gt;txf[0] = instructions_to_push_program[0]; // out x, 32    mm_pio-&gt;txf[0] = 12345678;                        // data to be OUTed    mm_pio-&gt;txf[0] = instructions_to_push_program[1]; // in x, 32    mm_pio-&gt;txf[0] = instructions_to_push_program[2]; // push    // The program pushed into TX FIFO will return some data in RX FIFO    while (mm_pio-&gt;fstat &amp; (1u &lt;&lt; PIO_FSTAT_RXEMPTY_LSB))        ;    printf(&quot;%d\\n&quot;, mm_pio-&gt;rxf[0]);    return 0;&#125;\n\n这里我们向状态机中加载了一个示例程序，它做了两件事：\n\n进入无限循环\n进入一个循环，该循环反复地从 TX FIFO 加载 32 比特数据，然后将低 16 比特作为指令执行\n\nC 程序将状态机设置为运行状态，然后进入 hang 循环。在状态机执行时，C 程序强制执行一条 jmp 指令，使状态机跳出循环。\n当一条指令写入 INSTR 寄存器后，状态机会立即解码并执行该指令，而不会执行从 PIO 指令内存读取到的指令。程序计数器不会增加，因此在下一个周期（假设 INSTR 寄存器强制执行的指令没有导致等待状态）状态机会从原来的位置继续执行当前程序，除非写入的指令修改了 PC。\n写入 INSTR 寄存器的指令中的延时周期会被忽略，并立即执行，不管状态机的时钟分频器如何设置。这个接口用于执行初始化或改变流程控制，所以指令会尽快执行，而不管状态机如何配置。\n写入 INSTR 的指令可以进入等待状态，此时状态机会锁住该指令，直到其完成。出现这种情况时，会设置 EXECCTRL_EXEC_STALLED 标志。重启状态机或向 INSTR 写入 NOP 可以清除该标志。\n上述示例状态机程序的第二阶段使用了 OUT EXEC 指令。OUT 本身需要一个执行周期，OUT 执行的指令在下一个执行周期进行。注意被执行的指令之一也是 OUT——状态机每个周期只能执行一条 OUT 指令。\nOUT EXEC 会将 OUT 移出的数据写入内部的指令锁存器。下一个周期中，状态机知道它不应该执行指令内存，而是执行该锁存器的内容，而且知道此时不应当增加 PC。\n该程序在运行时会输出 “12345678”。\n注意 如果写入 INSTR 的指令造成等待状态，该指令会被写入到与 OUT EXEC 和 MOV EXEC 所用的同一个锁存器，并覆盖其中保存的指令。因此，如果使用了 EXEC 指令，那么写入 INSTR 的指令不能造成等待。\n"},{"title":"SWD采样时序","url":"/2025/03/08/SWD%E9%87%87%E6%A0%B7%E6%97%B6%E5%BA%8F/","content":"最近在工作中遇到一个技术问题，在翻看ARM的一份技术手册《Arm Debug Interface Architecture Specification》，看到SWD章节时，我突然有个疑惑，SWD的DIO信号到达是在CLK的上升沿采样还是下降沿采样？\n我反复阅读了文档，似乎并没有明确的描述。只有一张描述时序的图：\n很有意思，根据这个图来看，应该是Host在上升沿输出信号，Host在下降沿读取信号。\n为了确保理解有遗漏的地方，我把文档放到了豆包AI中去分析，让它看看这个时序是怎么样的。豆包AI帮我解读了文档中SWD相关的部分：\n该文档围绕Arm Debug Interface v5展开，其中SWD协议是重要内容，涵盖协议概述、操作、接口等方面。它是一种同步串行接口协议，具有多版本、支持多种操作等特点，在调试中起着关键作用。\n\n协议概述\n基本操作：采用单双向数据连接和独立时钟同步传输数据 ，一次操作包含数据包请求、确认响应和数据传输（按需）三个阶段。传输完成后，主机需进行特定操作以确保数据能顺利通过SW - DP。\n协议版本：v1是点对点架构，存在物理连接复杂等缺点；v2是多-drop架构，支持多设备连接，向后兼容，支持设备断电，但与v1在启动状态和休眠状态上存在兼容性问题。\n其他特性：包括线路反转（防止信号冲突，时长由DLCR.TURNROUND控制 ）、空闲周期（主机完成事务后需插入空闲周期或开始新事务 ）、位顺序（数据传输LSB先）、奇偶校验（对数据包请求和数据传输阶段进行偶校验）以及多-drop限制（设备需唯一ID，存在配置和自动检测限制 ）。\n\n\n协议操作\n各种响应情况：成功写操作（OK响应）包括8位写数据包请求、3位OK确认响应和33位WDATA数据传输阶段；成功读操作类似，只是数据传输方向相反。WAIT响应表示SW - DP无法立即处理请求，FAULT响应表示有错误发生，协议错误响应针对多种错误情况。\n特殊情况处理：SW - DP可实现写缓冲，能接受写操作，但存在相关限制。此外，还介绍了目标和主机的响应总结，以及SWD协议操作中的各种状态变化和数据传输规则。\n\n\n接口相关\n接口概述：使用单双向数据引脚SWDIO和时钟引脚SWCLK，支持主机和目标驱动信号，时钟可异步，空闲时可停止。目标需100KΩ上拉电阻确保线路状态已知。\n连接与复位：调试器需进行线路复位序列以确保连接正常，复位后特定操作可使接口退出复位状态。SWD协议版本2有特定的目标选择协议，涉及写TARGETSEL寄存器和读DPIDR寄存器等操作 。\n\n\n\n豆包AI都已经看到了位顺序是LSB这些细节了，但是它任然没有找到找到SWD的DIO信号到达是在CLK的上升沿采样还是下降沿采样。\n所以我又进一步明确问题：SWD协议是上升沿采样还是下降沿采样？AI这次还联网查询了一下：\nSWD协议中，数据在SWDIO上传输时，目标设备在SWCLK的上升沿进行采样。这一采样方式在文档及相关资料中均有明确阐述，是SWD协议数据传输机制的重要组成部分。 \n\n数据采样沿的明确规定：在文档中虽未直接提及SWD协议是上升沿采样还是下降沿采样，但参考其他权威资料，如CSDN博客文章《SWD(一) 杂谈》明确指出从相关章节可以看到是上升沿采样。并且在“SWD协议操作”部分描述数据传输过程时，虽未强调采样沿，但从信号传输的逻辑和常见的SWD协议实现来看，上升沿采样符合其数据传输的时序要求。\n与协议其他部分的关联性：SWD协议的数据包请求、确认响应和数据传输阶段的操作，都依赖于准确的采样时刻来保证数据的正确传输。上升沿采样确保了在时钟信号的特定时刻，目标设备能稳定地获取总线上的数据，与协议中对数据传输的奇偶校验、数据包格式等规定相互配合，共同保障数据传输的准确性和稳定性。\n\n所以AI也认为文档中没有明确说明。\n获取我们需要第三方的代码来佐证一下：https://github.com/blackmagic-debug/blackmagic/blob/main/src/platforms/common/swdptap.c根据这段代码中的注释以及函数实现来看，主机端在时钟下降沿输出数据，在时钟上升沿采集数据。\n在看看Raspberry Pi的代码：https://github.com/raspberrypi/debugprobe/blob/master/src/probe.pio这段代码中的注释和实现同样表明了主机端在时钟下降沿输出数据，在时钟上升沿采集数据。\n还有CMSIS-DAP的源码中SW_DP.c文件的实现来看，主机端在时钟下降沿输出数据，在时钟上升沿采集数据。\n所以问题是ARM的文档中配图是不是存在错误?还是说它就是一个示意图，没有明确说明。\n将问题交给DeepSeek分析一下，我的问题是：ARM芯片的SWD调试协议中DIO在CLK上升沿还是下降沿采样？它思考了43秒，给出了标题：ARM SWD调试协议DIO采样沿分析\nDeepSeek的回答简直无可挑剔！\n目前的AI工具都太强大了，可以帮助分析很多问题。但是目前AI的代码能力仍然有限，只能用于输出几百行规模的代码，不能用于分析复杂的需求。或许不久后就有能够生成几千行甚至上万行代码的能力，那时候才是解放生产力的时代。\n"},{"title":"TLSF与FreeRTOS-heap4对比","url":"/2024/05/21/TLSF%E4%B8%8EFreeRTOS-heap4%E5%AF%B9%E6%AF%94/","content":"TLSF内存分配器的一些测试和比较FreeRTOS太出名了，就不介绍了。TLSF是一个实时动态内存分配器，可用于嵌入式系统。具有高效的内存使用效率和可预测的响应时间，它具体的工作原理可以参考作者主页上的一些文档。\n我运行了一些简单的测试来比较二者的一些差异：\n\n\n\n\nTLSF\nheap4\n\n\n\n8000次内存分配耗时\n33ms\n13ms\n\n\n3000次碎片化分配耗时\n12ms\n106ms\n\n\n单个内存额外开销\n8字节\n8字节\n\n\n内存固定开销\n3224字节\n16字节\n\n\n内存碎片合并\n支持\n支持\n\n\n线程安全\n支持\n支持\n\n\n多块内存管理\n支持\n不支持\n\n\nrealloc接口\n支持\n不支持\n\n\n对齐分配\n不支持\n不支持\n\n\n堆内存溢出检测\n不支持\n不支持\n\n\ndouble free检测\n不支持\n不支持\n\n\n开源协议\nLGPL\nMIT\n\n\n注：性能数据仅仅反映在我的测试平台和测试用例上的结果\n简单总结：\n\n相比于heap4，tlsf可管理多块内存，支持realloc接口，功能上更完善。但是其内存固定开销较大，可能不适合管理较小的内存。在分配速度上，在分配连续内存时，heap4的分配速度优于TLSF。但是在遇到较多内存碎片后，tlsf的优势就比较明显了，其可预测的分配时间更适合高实时性的场景。\n\nheap4采用空闲链表管理空闲内存，当内存碎片较多后，内存分配性能将急剧下降。tlsf采用bitmap和空闲链表两级管理的方式，可实现O(1)的分配时间复杂度。\n\nheap4通过portBYTE_ALIGNMENT设置全局字节对齐方式。tlsf通过BLOCK_ALIGN设置全局字节对齐方式。均不支持分配时指定对齐方式。\n\nmalloc(0)的行为差异。tlfs会按照一个最小快进行分配(8字节)。heap4返回空指针并在内部触发内存申请失败的hook。\n\n二者都具备一些辅助内存调试的接口。作为经过多个版本迭代的发行版软件，它们都具有较高的可靠性。选择TLSF还是heap4，主要看你的需求。它们都具备良好的性能，并且都支持多线程。\n\n\n我看到另外一个分支版本tlsf，它支持对齐分配、更低的单块内存开销(4字节)，但是它没有实现线程安全的机制。\n内存分配器通常最为系统基础组件存在，因此选择一个好的内存分配器，可以带来更好的系统稳定性。我在之前总结了关于内存分配器对堆内存故障的一些内容，我就不单独发表了，一并贴在后面。\n堆内存使用中常见的4种问题\n1.内存泄漏 (memory leak)内存使用的基本流程是申请-&gt;使用-&gt;释放。如果内存不释放就会导致对该段内存的管理失去了控制，如果频繁发生这种问题，就会导致可用内存越来越小。通常来说在程序正常运行过程出现严重的内存泄漏时，通过观察可用内存的变化量可以判定是否出现了内存泄漏问题。如何进一步定位这个内存泄漏点呢？这个可以通过内存申请释放日志分析，如果内存泄漏频率较高能够非常容易就定位到问题所在。对于大块内存的泄漏一般也比较容易发现。如果出现较小内存的泄漏且频率不高的话需要长时间的测试才能发现问题。\n\n2.重复释放(double free)内存重复释放比较好理解，就是内存经历了申请-&gt;释放-&gt;再释放的过程。显然第二次释放这段内存会出现无法预料到的情况。该问题导致的具体现象也不确定。通常只能通过经验分析是否发生了该问题，出现该问题可能导致两个以上的线程出现异常行为。虽然不容易确认是否发生了double free，但是如果确认发生了double free，通常能够通过内存的申请释放日志找到问题点。但是如果某些情况可能会使问题变得比较棘手，即线程A申请内存指针p1，随机释放p1指针，线程B申请到同样的内存指针p1，线程A再次释放指针p1，即线程A释放了两次内存。如果使用log分析，能够看到这个地址的申请和释放都是成对的，很难定位问题点。对于前面这种情况，显然线程B会使用到一块不安全的内存，进一步导致UAF等问题。当出现这样的问题，设计一种malloc\\free成对机制就能较快的定位问题，常见的作法是添加动态标记，这样其它线程就不能释放一个不属于它的指针了。\nstatic inline uint32_t malloc_flag_generate(void)&#123;    static uint16_t id = 0;    return (id++ &lt;&lt; 16) | (rand() &amp; 0xffff);&#125;void *malloc_f(size_t size, uint32_t *flag)&#123;    if(!flag) return NULL;    uint32_t *ptr = malloc(size + sizeof(uint32_t));    *ptr = *flag = malloc_flag_generate();    return ptr++;&#125;void free_f(void *ptr, uint32_t *flag)&#123;    uint32_t *_ptr = ptr;    _ptr--;    assert(*flag == *_ptr);    free(_ptr);&#125;\n\n3.内存越界(memory overflow)内存越界不同于前面两种内存释放操作不合理导致的问题，它主要是由于内存申请的长度小于实际想要使用的长度，或者是实际使用的内存长度超过了分配的内存长度。内存越界可能导致篡改其它应用数据。但在某些内存管理器下可能出现破坏堆内存链表的情况，进一步导致的问题就是使得分配器分配出异常的内存空间地址。对于第二种问题情况，具体出现的问题现象也不确定，只能通过经验判断。检查内存溢出是内存分配器的一个基础安全能力，业内通用的做法是在内存区域的边界添加redzone，在释放内存时检查redzone进行分析，判断是否发生溢出。如何构造redzone也是一个复杂的问题，包括redzone填充的数据以及数据长度，随机的redzone内容和长度是一种安全的算法，但在具体的实施上通常比较麻烦，且在面对精心构造的shellcode时也会出现绕过的情况，应对该问题时一些内存调试手段有助于分析该问题，例如内存断点、陷阱等。\n\n4.内存非法访问(UAF)指针p指向一段合法申请的内存空间，当释放p指向的内存空间后，p指针未置NULL，所以理论上来说通过p指针任然能够访问该段内存下的数据。显然后续通过p指针访问数据都属于非法的访问。该问题配合堆内存管理器的一些特性能够导致系统出现严重的安全性问题。该问题通常不易发现，它如果没有造成明显的问题，很难定位问题点。内存分配器加入一些检测机制能够规避某些场景下的use after free问题，释放内存时，对内存中填充关键字。在分配内存时再检测关键字有没有被污染，以此来判断UAF问题。但是这种检测机制作用有限，它不能检测到上面场景下发生的问题。\n\n\n"},{"title":"nRF52x运行蓝牙协议栈+FreeRTOS的原理","url":"/2022/05/30/nRF52x%E8%BF%90%E8%A1%8C%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88+FreeRTOS%E7%9A%84%E5%8E%9F%E7%90%86/","content":"\n之前有个研发的产品为了满足蓝牙连接的需求，选择了nRF52840这个芯片，它的蓝牙协议栈是一种类似使用动态库的方式进行调用，官方仅仅给出了协议栈的二进制包(SoftDevice)，并给出了动态调用的方法，其调用的关键就是使用ARM单片机的SVC调用，这是一种比较好的设计，我们开发软件能够非常简单的调用协议栈的程序来实现蓝牙通信相关的功能。后来产品的使用需求发生的变化，蓝牙功能已经不需要的，而是需要更加复杂的通信功能。为了保持业务功能代码的一致性，所以并没有替换芯片，但是由于通信功能更加复杂后，迫不得已需要RTOS的支援。后续就是移植FreeRTOS等一系列操作。因为该单片机是CM4内核，所以这些操作都很简单。\n\nSVC调用冲突的疑惑今天在看这两套基于nRF单片机的设计方案时，我对其中的有个细节产生了疑惑。了解FreeRTOS的开发者应该比较清楚，像CM4内核的单片机启动FreeRTOS的第一个任务时，依赖SVC调用从裸机运行切换为RTOS线程运行。而蓝牙协议栈也使用了SVC调用，那是不是意味着该单片机的蓝牙功能不能和FreeRTOS兼容，结果是否定的。因为从官方的例程中可以看到蓝牙+FreeRTOS的例程(examples\\ble_peripheral\\ble_app_hrs_freertos)。我决定弄清楚Nordic的蓝牙协议栈+FreeRTOS是如何兼容的。\n我起初认为FreeRTOS的port实现中对初始任务调用有区别一般单片机的特殊处理，但是仔细看它的port文件后又发现并没有什么特别的。\n// external\\freertos\\portable\\ARM\\nrf52\\port.c__asm void vPortSVCHandler( void )&#123;    PRESERVE8    /* Get the location of the current TCB. */    ldr r3, =pxCurrentTCB    ldr r1, [r3]    ldr r0, [r1]    /* Pop the core registers. */    ldmia r0!, &#123;r4-r11, r14&#125;    msr psp, r0    isb    mov r0, #0    msr basepri, r0    bx r14&#125;__asm void vPortStartFirstTask( void )&#123;    PRESERVE8    EXTERN __Vectors    /* Use the NVIC offset register to locate the stack. */    ldr r0, =__Vectors    ldr r0, [r0]    /* Set the msp back to the start of the stack. */    msr msp, r0    /* Globally enable interrupts. */    cpsie i    cpsie f    dsb    isb#ifdef SOFTDEVICE_PRESENT    /* Block kernel interrupts only (PendSV) before calling SVC */    mov r0, #(configKERNEL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))    msr basepri, r0#endif    /* Call SVC to start the first task. */    svc 0    ALIGN&#125;\n\n而在FreeRTOSConfig.h文件中也将该函数映射到了中断向量表中\n// examples\\ble_peripheral\\ble_app_hrs_freertos\\config\\FreeRTOSConfig.h/* Definitions that map the FreeRTOS port interrupt handlers to their CMSISstandard names - or at least those used in the unmodified vector table. */#define vPortSVCHandler                                       SVC_Handler#define xPortPendSVHandler                                    PendSV_Handler\n\n到这里我转头分析nRF的SDK代码，例如sd_ble_enable()函数就是一个SVC调用在ble.h文件中使用一个SVCALL宏定义扩展为SVC调用代码，到这里我怀疑SVCALL针对有无RTOS有两种不同的设计，后来发现是多虑了。\n检查中断向量表实在不行上代码吧，在调试环境中看看，我运行了一个仅仅包含蓝牙协议栈的程序，运行起来后发现SCB-&gt;VTOR&#x3D;0\n很奇怪~\n蓝牙协议栈在ROM中的地址范围为0-0x27000，我们编写的APP地址范围为0x27000-END。因为单片机从地址0处开始运行，肯定是运行蓝牙协议栈，在协议栈内跳转到APP中，按照一般BOOT+APP的设计思想，BOOT跳转是应把中断向量表寄存器改为APP的中断向量表。这里为什么还是BOOT的中断向量表呢？难道是Bug。看来需要看看协议栈固件中发生了什么。\n其实到这里我就大概猜到这里面的门道了，我准备逆向分析蓝牙协议栈的二进制包，看看是否符合我的预期。我认为整个系统任然依赖Boot(蓝牙协议栈程序，我把它当作boot的角色)的向量表，而在Boot的中断处理函数中通过适当的判断决定执行Boot中断处理逻辑还是跳转引导到APP中的中断处理函数中来。\n分析SoftDevice固件官方提供的boot为一个HEX文件，我先转为bin文件，方便查看二进制数据，从前面的调试结果能够看到中断向量表在起始位置，那么很容易就找到SVC的入口地址了，在0x2c偏移处得到0x00000AA5，忽略最低bit1，转到0x00000AA4，开始分析SVC的函数处理流程，这里不讨论如何逆向固件，直接看结果，我把其中最关键的部分截取了出来。\n这里分析的固件从nRF5_SDK_17.0.2_d674dde中获得。不同版本的SoftDevice可以在汇编数据上有差别，大体流程应该是一致的。\n0x00000AA4 F01E0F04  TST           lr,#0x04       ;; 解析SVCid的经典代码，很多地方都看过0x00000AA8 BF0C      ITE           EQ0x00000AAA F3EF8108  MRS           r1,MSP0x00000AAE F3EF8109  MRS           r1,PSP0x00000AB2 6988      LDR           r0,[r1,#0x18]  ;; 得到执行SVC指令后的PC指针值. why offset = 0x18, see ARM manual0x00000AB4 3802      SUBS          r0,r0,#0x02    ;; 向后回退一个指令的长度，即2字节，就是SVC指令的位置0x00000AB6 7800      LDRB          r0,[r0,#0x00]  ;; 按字节取值，从低位得到SVC的id，id是作为低位包含在二进制编码中的0x00000AB8 2818      CMP           r0,#0x180x00000ABA D103      BNE           0x00000AC4   ;; SVC的ID不等于0x18跳转到0x00000AC4，这就是我们需要流程，FreeRTOS的SVCid为00x00000ABC E000      B             0x00000AC0   ;; SVC的ID等于0x18跳转到0x00000AC40x00000ABE 0000      MOVS          r0,r00x00000AC0 4A07      LDR           r2,[pc,#28]  ; @0x00000AE00x00000AC2 4710      BX            r20x00000AC4 4A07      LDR           r2,[pc,#28]  ; @0x00000AE40x00000AC6 6812      LDR           r2,[r2,#0x00] ;; 检测内存发现@0x20000000的值为0x10000x00000AC8 322C      ADDS          r2,r2,#0x2C   ;; 0x2C? 像是SVC的偏移，推测在RAM的0x1000处有一个新的中断向量表0x00000ACA 6812      LDR           r2,[r2,#0x00] ;; r2=0x0002606D0x00000ACC 4710      BX            r20x00000ACE 0000      MOVS          r0,r00x00000AE0: 00000377 .word 0x000003770x00000AE4: 20000000 .word 0x200000000x0002606C 2004      MOVS          r0,#0x04     ;; 这是另一个SVC处理函数0x0002606E 4671      MOV           r1,lr0x00026070 4208      TST           r0,r1        ;; 这是编译器生成的还是手工编写的汇编，太冗余了...0x00026072 D002      BEQ           0x0002607A0x00026074 F3EF8109  MRS           r1,PSP0x00026078 E001      B             0x0002607E0x0002607A F3EF8108  MRS           r1,MSP0x0002607E 6988      LDR           r0,[r1,#0x18]0x00026080 3802      SUBS          r0,r0,#0x020x00026082 7800      LDRB          r0,[r0,#0x00] ;; 到这里，函数重新解析了一遍SVC的ID0x00026084 2810      CMP           r0,#0x100x00026086 DB13      BLT           0x000260B0    ;; 如果ID小于0x10则跳转到 0x000260B00x00026088 2820      CMP           r0,#0x200x0002608A DB0F      BLT           0x000260AC    ;; 如果ID小于0x20则跳转到 0x000260AC0x0002608C 282C      CMP           r0,#0x2C0x0002608E DB0B      BLT           0x000260A8    ;; 如果ID小于0x2c则跳转到 0x000260A80x00026090 4A0A      LDR           r2,[pc,#40]  ; @0x000260BC0x00026092 6812      LDR           r2,[r2,#0x00]0x00026094 4B0A      LDR           r3,[pc,#40]  ; @0x000260C00x00026096 429A      CMP           r2,r30x00026098 D103      BNE           0x000260A20x0002609A 2860      CMP           r0,#0x600x0002609C DB04      BLT           0x000260A80x0002609E 4A09      LDR           r2,[pc,#36]  ; @0x000260C40x000260A0 4710      BX            r20x000260A2 2002      MOVS          r0,#0x020x000260A4 6008      STR           r0,[r1,#0x00]0x000260A6 4770      BX            lr0x000260A8 4A07      LDR           r2,[pc,#28]  ; @0x000260C80x000260AA 4710      BX            r20x000260AC 4A07      LDR           r2,[pc,#28]  ; @0x000260CC0x000260AE 4710      BX            r20x000260B0 4A07      LDR           r2,[pc,#28]  ; @0x000260D00x000260B2 6812      LDR           r2,[r2,#0x00]  ;; 在0x20000004处的值为0x27000,它是app的起始位置0x000260B4 322C      ADDS          r2,r2,#0x2C    ;; 计算出app中SVC的地址0x000260B6 6812      LDR           r2,[r2,#0x00]0x000260B8 4710      BX            r2             ;; 跳转到app中的SVC执行0x000260BC: 2000005C .word 0x2000005C0x000260C0: CAFEBABE .word 0xCAFEBABE0x000260C4: 0000139B .word 0x0000139B0x000260C8: 00024485 .word 0x000244850x000260CC: 00024E9F .word 0x00024E9F0x000260D0: 20000004 .word 0x20000004\n\n分析执行过程猜测在0x20000000和0x20000004处存放了两个中断向量表的起始地址，一个是内存中的向量表，位于0x1000；另一个就是APP的中断向量表，位于0x27000。\n结论非常明显了，当SVC的id小于0x10时就会跳转到我们编写的APP固件中的SVC处理函数中，这样就实现了FreeRTOS的port所依赖的功能。而id大于等于0x10时就执行协议栈内部的工作流程，实现了蓝牙协议栈+FreeRTOS功能的兼容。\n从这个汇编代码的执行路径来看，从触发BOOT中的SVC到跳转到APP中的SVC处理函数，全程都没有使用栈操作的指令，没有涉及pop、push、bl、bxl等。这样在APP的中断函数中就能直接返回到线程环境代码，这样的设计对APP的中断处理函数来说也更加封闭。\n官方的文档中也说明了0-0xf的id调用分配到了Application，其它的id分配为协议栈。\n类似的像PendSV_Handler中断处理函数，在协议栈内部触发后，经过5条指令就能够跳转到APP内部，还算是比较简洁的，应该不会对FreeRTOS的调度性能产生很大的影响。\n官方的SDK中id是从0x60开始使用的，而协议栈中对小于0x20、0x2c等区间的id有特殊处理，为什么需要这样处理呢？以后再看吧。\n不懂固件中为什么需要两次解析SVC的id，关键是是第二次解析时很不简洁，还多了3条指令，看起来好别扭-_-!\n"},{"title":"一个困扰我很久的问题","url":"/2023/08/30/%E4%B8%80%E4%B8%AA%E5%9B%B0%E6%89%B0%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84%E9%97%AE%E9%A2%98/","content":"大约在一年半前，我写了一篇文章介绍如何统计FreeRTOS系统中任务的实时CPU占用率的方法，其中最关键的是使用DWT计数器。我一直认为这个计数器在任意条件下都是能够正确运行的，直到我把它运用到Cortex-M7内核中。\n正常情况下Cortex-M7内核的DWT计数器能够正常工作，只是需要操作一个访问锁寄存器LAR，但是我发现各个单片机对这个锁的实现并不是一致的，某些单片机不解锁仍然能够使用DWT功能，ARM的技术手册中也没有详细描述这寄存器。LAR锁不是今天讨论的主要内容，略过。我这里主要想说说单片机睡眠模式下遇到的DWT计数异常的问题。\n当我使用FreeRTOS的低功耗模式时就发现了DWT异常的现象，当单片机进入休眠状态后，DWT的计数器并没有继续运行，这个现象我只在STM32H750这个单片机上碰到，由于我手上没有其它的CM7的单片机，所以我无法确认这个问题是不是这个单片机特有的。当出现这个问题后我就在CM4的单片机上尝试复现，但是在CM4的单片机中任务统计功能和低功耗都能很好的运行。\n我在网上检索了很多的资料，都没有相关的描述，这让我非常怀疑是软件某个地方配置不当导致的，但是我却并没有发现可疑的地方。\n当启用FreeRTOS的低功耗模式后，在tickless处理流程中，我确认DWT的CYCCNT寄存器没有继续计数，所以启用低功耗模式后，统计任务的CPU占用时间就不可靠了。\n由于能够确认在tickless中CYCCNT的计数存在缺失，所以通过FreeRTOS的HOOK能够进行一定程度的补偿来确保任务CPU统计功能大致正常工作，但是这总是存在误差的，因为依靠traceINCREASE_TICK_COUNT()纠正的时间精度不够准确。\n如果能确认这个问题是硬件导致的，我就放心了，因为我常常时不时的就在尝试完美解决这个问题，这个问题困扰我很久了。\n"},{"title":"一个整数无法正常溢出导致的bug","url":"/2025/01/15/%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E7%9A%84bug/","content":"lvg是一款非常流行的图形库，最近在使用它的过程中发现一个有意思的问题，这里做简单记录。话说事情是这样的，我为按钮设计了一个动画，大概是按钮一直沿y轴周期性的往复移动。\nlv_anim_t by;lv_anim_init(&amp;by);lv_anim_set_exec_cb(&amp;by, (lv_anim_exec_xcb_t) lv_obj_set_y);lv_anim_set_var(&amp;by, btn);lv_anim_set_time(&amp;by, 1797);lv_anim_set_values(&amp;by, 2, 106);lv_anim_set_playback_time(&amp;by, 1797);lv_anim_set_repeat_count(&amp;by, LV_ANIM_REPEAT_INFINITE);lv_anim_start(&amp;by);\n\n代码非常简单，就是为btn绑定一个无限重复次数的动画。代码刚开始可以好好运行，但是动画执行了几分钟后这个按钮的动画突然暂停了。按钮保持在了一个固定的位置，我不明白发生了什么。我可以确认系统内各个任务都在正常的执行，图形页面上的一些效果都在正常显示，就只有这个按钮的动画仿佛被删除了一样。\n系统重启了几次，这个bug视乎可以一直复现，我决定连着调试器看看，到底发生了什么，我在关键的一些的地方设置了断点，等待故障发生。奇怪的是故障发生后没有命中任何断点，我立即暂停了程序运行，我决定进入到动画处理的定时器回调函数中看看，相关的动画句柄数据到达是什么样的。\n在anim_timer()函数内设置一个断点，成功命中，说明动画处理相关的定时器没有被删除，但是动画执行的回调却不执行。检查lv_anim_t结构体内的数据，发现a-&gt;act_time为一个很大的负数值，这就看起来很离谱，这意味着距离下一次动画被激活还有很长的时间要等待，动画效果因此被暂停。为什么act_time是负数了。\nuint32_t elaps = lv_tick_elaps(a-&gt;last_timer_run);a-&gt;act_time += elaps;\n\n在我将能够排除的地方都排除后，我将问题点定位到了上面这里。elaps的计数值肯定是一个正数，但如果elaps非常大的话可能导致后面的累加计算溢出导致计算出的值为负数。\nlv_tick_elaps()的作用是计算当前时刻距离last_timer_run时刻的时间差，它的实现如下：\nuint32_t lv_tick_elaps(uint32_t prev_tick)&#123;    uint32_t act_time = lv_tick_get();    /*If there is no overflow in sys_time simple subtract*/    if(act_time &gt;= prev_tick) &#123;        prev_tick = act_time - prev_tick;    &#125;    else &#123;        prev_tick = UINT32_MAX - prev_tick + 1;        prev_tick += act_time;    &#125;    return prev_tick;&#125;\n\n看到这里，我突然明白了问题点，lv_tick_elaps函数内做了整数溢出处理，但是它默认从lv_tick_get()返回的时间计数周期为UINT32_MAX。如果时间周期不是UINT32_MAX，这就导致溢出计算错误。\n再看看lv_tick_get()函数的实现，它最终会调用由void lv_tick_set_cb(lv_tick_get_cb_t cb)设置的回调函数，我这里是：\nstatic uint32_t get_gui_tick(void)&#123;    return xTaskGetTickCount() * 1000u / configTICK_RATE_HZ;&#125;// lv_tick_set_cb(get_gui_tick);\n\n我这里的configTICK_RATE_HZ&#x3D;20000，这就导致get_gui_tick函数返回的周期比UINT32_MAX小了20倍。所以导致程序运行时act_time计算错误。\nlvgl似乎没有对用户导入的时间查询回调函数做一定的规范，导致了该问题的发生。\n修改FreeRTOS内核配置，将configTICK_RATE_HZ设置为1000，这样可以解决问题吗？哈哈，如果这样想你很快就会调入另外一个陷阱。\nxTaskGetTickCount() * 1000u / configTICK_RATE_HZ\n\n先乘法再除法会导致xTaskGetTickCount()时间的周期缩小1000倍，所以不要忽视这些细节。\n我这里为了不修改FreeRTOS内核配置，所以我决定使用一个硬件定时器来彻底解决该问题，确保导入到图形库内的时间查询函数返回值的周期为UINT32_MAX。\n这是第一次遇到由于整数溢出边界不严谨导致的故障。如果你有类似的困扰可以将configTICK_RATE_HZ设置为1000并调用lv_tick_set_cb(xTaskGetTickCount)来解决该问题。\n"},{"title":"一个简单但强大的协程库-PtPlus","url":"/2024/08/20/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%86%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%BA%93-PtPlus/","content":"去年我基于Protothreads协程库实现了一些有意思的扩展功能以方便使用该协程库。相关的两篇文章可以翻看去年的博客。\n\n更优雅的使用Protothreads协程框架\nPT协程的一个小扩展\n\n最近我继续完善了相关的功能，并增加了一些新的功能。实现了低功耗支持、可超时的信号量等。\n将所有相关代码进行整理后我为其命名为PtPlus。现已经发布在GitHub上，欢迎大家使用。\n它使用标准C语言编写，几乎可以运行在所有的嵌入式平台上。\n相关的用法以及示例可以参考PtPlus。\n这里仅展示一段代码来展示该协程库的使用。\n#include &lt;stdio.h&gt;#include &quot;pt_plus.h&quot;#ifdef _WIN32#include &lt;windows.h&gt;#define sleep(ms) Sleep(ms)#endifstruct pt_sem sem;PT_THREAD(test_task_A(struct pt *pt))&#123;    PT_BEGIN(pt);    static int i;    for(i = 0; i &lt; 10; i++)&#123;        PT_TASK_DELAY(pt, 1000);        printf(&quot;send semaphore - %d\\r\\n&quot;, clock_time());        PT_SEM_SIGNAL(pt, &amp;sem);    &#125;    PT_END(pt);&#125;PT_THREAD(test_task_B(struct pt *pt))&#123;    PT_BEGIN(pt);    static int err_cnt = 0;    while(1)&#123;        int ret;        PT_SEM_WAIT_TIMEOUT(pt, &amp;sem, 2000, &amp;ret);        if(ret == 0)&#123;            printf(&quot;Obtained semaphore! - %d\\r\\n&quot;, clock_time());        &#125;else&#123;            printf(&quot;Obtain semaphore timeout - %d\\r\\n&quot;, clock_time());            err_cnt++;            if(err_cnt &gt;= 3)&#123;                PT_EXIT(pt);            &#125;        &#125;    &#125;    PT_END(pt);&#125;int main(void)&#123;    PT_SEM_INIT(&amp;sem, 0);    PT_TASK_RUN(test_task_A);    PT_TASK_RUN(test_task_B);    while(PT_TASK_NUMS() &gt; 0)&#123;        PT_TASK_SCHEDULE();        clock_time_t idle_time = PT_TASK_IDLE_TIME();        if(idle_time &gt; 0)&#123;            // Calling system delay functions            sleep(idle_time);        &#125;    &#125;    return 0;&#125;\n\n在main函数中创建了两个任务后开始进行调度。任务A每间隔1秒发出一个信号量，任务B每隔2秒等待信号量，如果等待超时则打印错误信息。任务B连续3次超时后，任务B将退出。当所有的协程任务都结束后，程序结束。\n"},{"title":"体验国产RISC-V单片机","url":"/2024/05/18/%E4%BD%93%E9%AA%8C%E5%9B%BD%E4%BA%A7RISC-V%E5%8D%95%E7%89%87%E6%9C%BA/","content":"\nRISC-V单片机并不是很新鲜的东西，但因为其市场占有率相比于ARM内核的芯片较小，所以此类芯片并不流行。在此之前，我并没有接触过RISC-V的芯片，趁着春节假期，购得一块国产单片机CH32V307，本着学习的态度，看看该芯片相比于ARM内核有何优缺点。\n\n芯片上手RISC-V芯片的指令集、指令架构同ARM芯片有着非常大的差异，不过前期还不需要接触到这个层面，从最基本的helloworld程序开始可以最快上手这个芯片，芯片厂家提供了HAL层的代码和集成开发环境，还提供了大量的example可供参考，所有让这个芯片运行起来是很容易的。\n这个芯片让人最感兴趣的有三个方面，RISC-V内核、内建10MPHY的以太网控制器、内建480MPHY的高速USB控制器。尤其是后两点，几乎所有的STM32的芯片都不支持，这对构建网络相关、USB相关的应用非常有利。\nRISC-V内核针对RISC-V内核的探索，主要是移植FreeRTOS操作系统为主。FreeRTOS官方提供了RISC-V的port层适配，其基于mtimer实现，但是该芯片的内部实现上有些差异(RISC-V生态不统一)，其砍掉了mtimer，增加了一个类似ARM单片机的systick，所以芯片厂家自己实现了一个port适配层。\n参考该适配层代码完成了操作系统的移植。在移植过程中主要遇到了以下问题：\n\n需要在链接脚本中分配独立的操作系统栈该栈仅用于线程切换的中断使用，FreeRTOS官方的port层方案中没有这方面内容。RISC-V芯片没有独立的中断栈空间，所以芯片厂商为RTOS上下文切换中断特别实现了中断栈切换机制，相对应的栈空间需要提前在链接脚本中分配。这是与ARM单片机区别较大的地方，ARM单片机可自定义线程栈和中断栈，并由芯片自动完成切换。这里需要注意链接脚本的写法，操作系统的栈空间和系统开始运行的栈空间其实可以为同一个地址空间，因为操作系统开始运行后，最开始的主栈空间将不再使用。所以这两部分空间是一致的。在xPortStartFirstTask实现中，将链接脚本分配的空间地址减小了512字节，这主要是避免和主栈空间发送冲突，但实际上这里应该是不需要的。将中断栈地址将写入到mscratch寄存器中，这是一个临时存储数据的寄存器，这里将专用于保存栈地址，通过寄存器交换指令实现sp寄存器和mscratch的交换，达到栈空间的切换目的，这样用户空间和内核调度中断的栈将相互独立。\n .stack ORIGIN(RAM) + LENGTH(RAM) - __stack_size :&#123;    PROVIDE( _heap_end = . );        . = ALIGN(4);    PROVIDE(_susrstack = . );    . = . + __stack_size;    PROVIDE( _eusrstack = .);    __freertos_irq_stack_top = .;&#125; &gt;RAM \n\n芯片运行模式该芯片具有两种运行模式，用户模式和机器模式，原则上来说芯片上电启动后芯片运行在机器模式，但是厂家提供的启动代码将芯片调整到了用户模式，在裸机开发时这可能更有利于系统安全。但是在RTOS系统中，系统为了访问CSR寄存器实现对处理器的控制，系统必须允许在特权级。所以这里需要调整启动汇编代码，根据芯片相关手册，调整mstatus寄存器使得芯片始终运行在机器模式。这部分内容与ARM单片机也有像类似的地方。ARM单片机也分为特权模式和非特权模式，目前市面上大部分操作系统都运行在特权级，包括用户级的线程。仅少部分操作系统对用户线程实现了权限管理。\n\nCall API from ISR为了系统的安全性和健壮性，FreeRTOS要求在中断中使用FromISR结尾的系统API。但是芯片官方的port实现中缺少相关的检测支持，这使得软件开发过程中可能出现一些潜在的风险无法暴露。主要是在vPortEnterCritical()接口的实现中，当第一次进入临界区，需要检测是否在中断中，因为该API仅能够在非中断上下文使用，中断上下文有其它的实现接口。芯片官方和FreeRTOS默认的port层代码如下：\n void vPortEnterCritical( void )&#123;    portDISABLE_INTERRUPTS();    uxCriticalNesting++;&#125;\n 可见缺少相关故障断言支持，这里可调整为：\n void vPortEnterCritical( void )&#123;    portDISABLE_INTERRUPTS();    uxCriticalNesting++;    if( uxCriticalNesting == 1 )    &#123;        configASSERT( ( (PFIC-&gt;GISR) &amp; 0x1ff ) == 0 );    &#125;&#125;\n 通过GISR寄存器实现中断上下文的识别和检测。\n\n低功耗模式无论是FreeRTOS官方代码还是芯片产家的port层代码中都缺少低功耗支持相关的内容，所以这部分需要自己实现，因为芯片是支持低功耗模式的。主要是需要充分理解systick运行机制以及芯片的低功耗进入及唤醒机制并配合操作系统完成低功耗运算的实现。使用WFI指令可以让处理器进入低功耗模式，当发生中断时可自动唤醒芯片，但是在FreeRTOS系统中配合systick实现的低功耗接口vPortSuppressTicksAndSleep，在WFI指令前需要关闭中断，所以导致系统无法正常唤醒。这里需要特殊处理一下，通过SCTLR寄存器将WFI指令切换为event模式，即通过事件唤醒系统。再将SEVONPEND标志置位，这样即使关闭全局中断，当系统的任意中断发生时仍然能够立即唤醒芯片。在具体实现vPortSuppressTicksAndSleep上，需要注意systick的计数方向，FreeRTOS已经将其改为向上计数，所以这里同一般STM32单片机的计数方向是相反的。先根据系统需要休眠的时间估算systick的计数值，重设systick的CMP寄存器，通过WFI让芯片休眠，芯片唤醒后检查是systick唤醒还是其它中断唤醒，如果是其它中断唤醒则需要根据systick的计数值计算刚刚休眠的时长。将systick的CMP恢复到休眠前的状态，通知RTOS内核刚刚休眠的时长，这样即完成了低功耗port的实现，在具体的实现上还需要注意systick在不同时间段的累计补偿和停机补偿。使用低功耗模式会不可避免的使得RTOS时间同实际时间发生一定的偏移，但这个偏移在长时间的累计才会比较明显，一般影响不大。但是如果将RTOS的内核时间作为日历时间使用则会导致一定的误差，这是开启低功耗模式时需要注意的问题。在我的开发板上测试，在运行相同软件应用的情况下，未开启低功耗模式运行时的电源为5V&#x2F;29mA，开启低功耗模式后的电源为5V&#x2F;19mA，考虑到开发板上存在一些固定功率开销，低功耗模式带来的优势还是非常明显的。注：开启低功耗模式运行后，网卡驱动的发送部分硬件DMA存在一定的异常问题还未解决。\n\n\n太网控制器芯片内建10M的PHY，这意味这该芯片不需要单独的网卡芯片即能够实现网络通信，使用单片芯片方案即能够完成联网应用开发。芯片厂家提供了一个网络协议栈WCHNET，该协议栈能够满足基本的网络应用开发需求，但是面对复杂应用，使用LwIP协议栈可能更加合适。\nLwIP依赖前面的操作系统，此外协议栈没有其它的移植要求。为了让协议栈正常运行起来，最关键的是实现网卡驱动。这里参考官方示例基本能够完成驱动开发，官方虽然没有针对LwIP进行适配，但是驱动层的MAC帧都是通用的，所以驱动的移植难度也不大。以太网HAL层的代码结构同STM32单片机类似，用法上没有陌生感。\n驱动移植完成后进行了简单的网络测试，使用iperf工具测试，收发带宽可达9.3M，基本上达到10M接口的传输速度上限。\nUSB控制器芯片官方提供了较丰富的测试代码，有HS、FS端口相关的代码，还有主机、从机的示例。应用类别也有CDC、网络等。运行了官方示例代码，可以确认USBHS能够很好的工作，但是在移植Tinyusb是遇到了一些问题。\nTinyUSB是第三方USB协议栈，其支持CH32V307芯片，该协议栈能够非常方便的进行USB设备描述符的编写，这是我常用的一个USB协议栈库。该协议栈也对CH32V307的HS端口进行了适配，但是在实际运行过程中出现了一些问题。在关闭协议栈调试日志的情况下，内部会出现断言错误，打开日志后，该故障消失。输出日志会影响代码的运行速度，这应该就其内部的差异。导致该问题的原因没有进一步研究，应该是驱动层或协议层代码存在一些竟态问题。所以针对该芯片USB方面的内容就没有进行更加深入的测试。检查TinyUSB官方的issus列表，可以确认针对CH32V307的适配还存在一些问题，待修复后再测试该芯片的USB性能。\n故障诊断该芯片提供了一个独立的故障中断，类似于ARM单片机的HardFault，但是该故障中断囊括了芯片运行的大部分故障，包括指令异常、内存寻址错误、内存非对齐等。特别注意RISC-V单片机不支持非对齐内存访问，在编写C代码时需要注意规避这方面的问题。\n当发生故障时，可以通过CSR寄存器列表中的mcause寄存器确定发生故障的原因。更进一步的，通过mepc寄存器还能够提供发生故障时的PC指针。这对于故障的诊断十分有利。\n中断控制器这是芯片相关的内容，并不是RISC-V通用的中断控制器。芯片可支持8级中断优先级、4组优先级分组。该芯片的特色是支持硬件压栈，即硬件上有独立的内存空间用于中断发生时通过硬件自动保持caller saved寄存器，这意味其相比于一般的单片机中断，它的响应过程可以减少许多额外的指令开销。硬件压栈最高支持3级嵌套，可以满足中断高实时性的要求。\n此外，芯片还支持4路免表中断，即不通过中断向量表，将中断函数入口地址直接绑定到指定的中断上，这将进一步提高中断的响应速度。\n需要注意的是，区别于ARM单片机中断有独立的栈，该芯片发生中断时并不会自动切换栈空间，这意味着中断栈空间将是线程栈空间的延续。在调试网卡中断时我没有意识到这一点，导致中断发生时将IDLE线程的栈空间溢出。如果不能手动将栈切换到独立空间，那么需要控制中断函数的栈空间消耗。\n其它内容芯片官方开发的HAL库在代码风格上接近STM32早期的标准库，甚至部分API名称都一致，这也是方便入手该芯片的优势。\n在以上开发测试过程中编译器一直使用-Os优化，代码运行过程中没有出现由于编译优化导致的问题。\n芯片的最高主频为144MHz，代码模板采用默认的96MHz。96MHz主频下，基于FreeRTOS系统运行Coremark基准测试，跑分可达250分(满频率运行应当为370分)，性能同ARM的CM4内核水平相当。\n2K performance run parameters for coremark.CoreMark Size    : 666Total ticks      : 15839Total time (secs): 15.839000Iterations/Sec   : 252.541196Iterations       : 4000Compiler version : GCC8.2.0Compiler flags   : -OfastMemory location  : FreeRTOS-heap4seedcrc          : 0xe9f5[0]crclist       : 0xe714[0]crcmatrix     : 0x1fd7[0]crcstate      : 0x8e3a[0]crcfinal      : 0x65c5Correct operation validated. See README.md for run and reporting rules.CoreMark 1.0 : 252.541196 / GCC8.2.0 -Ofast / FreeRTOS-heap4\n\n此外还测试了SPI、TIM等外设，性能尚可。该芯片还具有DVP、FSMC等外设，可进一步拓展该芯片的用途。\n总的来说，第一次使用RISC-V芯片，该芯片给我留下了较好的影响。我认为该国产芯片的功能已经达到了目前主流单片机的行列，但其流行程度、相关的开发生态环境、社区活跃度都还需要进一步发展。将其应用到项目开发过程中需要考虑面临故障时缺少经验的问题，国产单片机的发展任重而道远。\n"},{"title":"一个极简的DAPLink","url":"/2024/06/20/%E4%B8%80%E4%B8%AA%E6%9E%81%E7%AE%80%E7%9A%84DAPLink/","content":"平时我的主要兴趣方向都是嵌入式软件开发方面的内容，但偶尔也做一些硬件相关的内容。我的硬件设计水平一般，仅仅是能够用嘉立创的EDA软件设计一些简单的PCB，焊接能力更是拿不出手😅。\n之前我偶然间看到一个别人设计的DAPLink，使用51单片机完成的。让我感兴趣的是，如果更换同类型的更小封装芯片，或许可以设计出一个非常小的DAPLink，所以就有了我的一个设计。\n我使用CH552E单片机加一个LDO以及其它几个电阻电容就完成了它的主要电路。一个极简的DAPLink，具有一个SWD接口和一个UART接口，只有大约USBtype-C母座的大小。如果你喜欢，它甚至可以作为你的板载调试器。\n\n我已经让它工作了很长一段时间，看起来非常好用。在某个量产项目中，我把它当作固件批量下载工具，目前还没有遇到明显的问题。\n最后，它的原理图、PCB、源代码、编译好的固件在这里：原理图PCB：立创开源-DAPLink固件、源码：https://github.com/DazzlingOkami/CH552-DAPLink\n"},{"title":"从单片机到FPGA：我的RISC-V软核开发实践","url":"/2025/05/16/%E4%BB%8E%E5%8D%95%E7%89%87%E6%9C%BA%E5%88%B0FPGA%EF%BC%9A%E6%88%91%E7%9A%84RISC-V%E8%BD%AF%E6%A0%B8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/","content":"从单片机到 FPGA：我的 RISC-V 软核开发实践一、单片机数据处理瓶颈引发的技术思考在近期的项目开发中，我遭遇了一个棘手的技术挑战：需要在单片机端直接处理 2.6Msps 的数据量，而 500MHz 主频限制下，每个数据的处理时间仅有不到 200 个时钟周期。传统方案中，double 类型的高精度运算严重消耗计算资源，数据总线带宽压力巨大。经过反复优化，最终通过将数据类型替换为 long 型，并借助汇编实现部分并行处理，才勉强满足实时性要求。\n这次经历让我深刻意识到：单片机在面对大规模数据并行运算时存在天然局限。其冯・诺依曼架构下的顺序执行模式，难以高效处理高密度计算任务。而 FPGA 凭借硬件并行处理的特性，显然更适合这类场景。于是，我决定通过一个实战项目开启 FPGA 的学习之旅，目标是构建 STM32 与 FPGA 协同工作的异构计算系统。\n二、项目架构设计：构建异构计算系统（一）核心功能定义项目的核心目标是在 FPGA 内运行 RISC-V 软核，由 STM32 通过 FMC 总线完成程序加载与运行控制，并实现两者的数据交互。这一架构借鉴了工业控制中 “ARM+FPGA” 的经典组合模式：STM32 负责上层逻辑控制，FPGA 承担底层并行计算，通过内存映射的 FMC 总线实现高效通讯。\n（二）关键技术选型RISC-V 软核：选择 PicoRV32 作为核心，因其轻量级设计和开源生态，便于快速集成。\n硬件平台：\nFPGA 选用安路科技 EF2L45LG144B 开发板，其内置的 256KB 双端口 ERAM 成为关键：一个端口连接 RISC-V 核（32 位数据宽度），另一个端口通过 FMC 接口与 STM32（16 位数据宽度）通信，数据位宽转换通过地址低位自动选择高低字节实现。\n自主设计 STM32 扩展板，通过FPGA开发板预留接口与 STM32 实现硬件级联，构建完整的双核心系统。\n三、Verilog 设计实践：从模块集成到时序优化（一）顶层架构设计`timescale  1 ps / 1 psmodule top(    input clk_ref,    input i_rst,    inout [15:0] fmc_data,    input fmc_wrn,    input fmc_rdn,    input fmc_csn,    input fmc_nadv);    wire clk;    wire rstn;    sys_clk u_sys_clk(        .clk_ref(clk_ref),        .i_rst(i_rst),        .clk(clk),        .rstn(rstn)    );    wire [15:0] mem_addr;    wire [15:0] mem_wdata;    wire [15:0] mem_rdata;    wire mem_wen;    wire mem_do;    fmc_bus u_fmc_bus (        .sys_clk(clk),        .sys_rst_n(rstn),        .db(fmc_data),        .wrn(fmc_wrn),        .rdn(fmc_rdn),        .csn(fmc_csn),        .nadv(fmc_nadv),        .ram_addr(mem_addr),        .ram_wdata(mem_wdata),        .ram_rdata(mem_rdata),        .ram_wen(mem_wen),        .ram_do(mem_do)    );    wire sram_valid;    assign sram_valid = (mem_addr &lt; 16&#x27;h8000);    wire [15:0] sram_rdata;    picorv32_ctrl u_picorv32_ctrl(        .clk(clk),        .rstn(rstn),        .ram_addr(mem_addr),        .ram_wdata(mem_wdata),        .ram_wen(mem_wen),        .ram_rdata(sram_rdata),        .ram_do(mem_do &amp; sram_valid)    );    assign mem_rdata =     sram_valid ? sram_rdata :                        16&#x27;h0000;endmodule\n\n顶层模块采用分层设计：\n时钟子系统：通过 FPGA 内置 PLL 生成 100MHz 稳定时钟，满足 RISC-V 核与 FMC 总线的时序要求。\n总线接口层：FMC 模块实现异步总线协议转换，将 STM32 的 16 位 FMC 信号映射为 16 位内存接口，地址空间划分为前 64KB（RISC-V 程序区）和扩展区（预留未来功能）。\n核心控制层：PicoRV32_CTRL 模块负责软核与内存的交互，通过双端口 RAM 实现 STM32（端口 B）与 RISC-V（端口 A）的并行访问。\n（二）RV32核心控制module picorv32_ctrl(    input clk,    input rstn,    input [15:0] ram_addr,    input [15:0] ram_wdata,    input ram_wen,    output [15:0] ram_rdata,    input ram_do);    wire trap;    wire mem_valid;    wire mem_instr;    reg mem_ready;    wire [31:0]    mem_rdata;    wire [31:0] mem_addr;    wire [31:0] mem_wdata;    wire [3:0] mem_wstrb;    wire mem_la_read;    wire mem_la_write;    wire [31:0] mem_la_addr;    wire [31:0] mem_la_wdata;    wire [3:0] mem_la_wstrb;    reg rv32_rstn;    reg rv32_state;    reg [15:0] rv32_ctrl_out;    always@(posedge clk) begin        if(~rstn) begin            rv32_rstn &lt;= 1&#x27;b0;        end        else begin            rv32_rstn &lt;= rv32_state;        end    end    always@(posedge clk) begin         if(~rstn) begin            rv32_state &lt;= 1&#x27;b0;        end else if(ram_do) begin            case(ram_addr)                16&#x27;h4001: begin                    if(ram_wen)                        rv32_state = ram_wdata[0];                    else                        rv32_ctrl_out &lt;= &#123;15&#x27;b0, rv32_state&#125;;                end                default: begin                    rv32_ctrl_out &lt;= 16&#x27;h0000;                end            endcase        end    end    picorv32 #(.COMPRESSED_ISA(1))    picorv32_core (        .clk         (clk         ),        .resetn      (rv32_rstn   ),        .trap        (trap        ),        .mem_valid   (mem_valid   ),        .mem_instr   (mem_instr   ),        .mem_ready   (mem_ready   ),        .mem_addr    (mem_addr    ),        .mem_wdata   (mem_wdata   ),        .mem_wstrb   (mem_wstrb   ),        .mem_rdata   (mem_rdata   ),        .mem_la_read (mem_la_read ),        .mem_la_write(mem_la_write),        .mem_la_addr (mem_la_addr ),        .mem_la_wdata(mem_la_wdata),        .mem_la_wstrb(mem_la_wstrb)    );    wire [31:0] ram_32_rdata;    wire [31:0] ram_32_wdata;    wire [3:0] ram_byte_en;    assign ram_byte_en = ram_addr[0] == 1&#x27;b0 ? 4&#x27;b0011 : 4&#x27;b1100;    assign ram_32_wdata = &#123;ram_wdata, ram_wdata&#125;;    assign ram_rdata = (ram_addr[0] == 1&#x27;b0 &amp;&amp; ram_addr[15:14] == 0) ? ram_32_rdata[15:0] :                       (ram_addr[0] == 1&#x27;b1 &amp;&amp; ram_addr[15:14] == 0) ? ram_32_rdata[31:16] :                       rv32_ctrl_out;    EF2_BRAM256 u_EF2_BRAM256(        .doa(ram_32_rdata),        .dia(ram_32_wdata),        .cea(ram_do &amp; ram_addr[15:14] == 0),        .clka(clk),        .wea(ram_wen),        .rsta(~rstn),        .addra(ram_addr[13:1]),        .weabyte(ram_byte_en),        .dob(mem_rdata),        .dib(mem_la_wdata),        .ceb(1&#x27;b1),        .clkb(clk),        .web(mem_la_write),        .rstb(~rstn),        .addrb(mem_la_addr[14:2]),        .webbyte(mem_la_wstrb)    );    always @(posedge clk) begin        if (~rstn) begin            mem_ready &lt;= 1&#x27;b0;        end else begin            mem_ready &lt;= 1&#x27;b1;        end    endendmodule\n\n模块内例化了两个模块，分别是rv32内核模块和BRAM模块。picorv32模块通过一个简单的内存预取接口将其连接到32k字节的内存块。picorv32_ctrl提供的整个地址空间，前面32kb直连BRAM内存块，后面32kb连接内部实现的寄存器，目前寄存器只有一个，用于控制rv32内核的复位状态来控制内核的运行。\nBRAM的内存宽度是32bit，前面FMC的内存宽度是16bit，所有这里做了一个巧妙的处理，通过地址低位来选择输入输出数据的高位还是低位。\npicorv32默认没有开启指令压缩和乘法扩展，这里通过COMPRESSED_ISA手动打开指令压缩。为了节省一点LUT资源就不开乘法扩展了。在通过riscv-gcc编译程序时的架构选型应为-march&#x3D;rv32ic。\n（三）FMC异步接口这个接口代码应该是不复杂的，但我发现我写的代码看着很别扭，代码质量不高，所以就不展示了。😂😂😂\n四、软件生态构建：从编译链到控制程序（一）RISC-V 测试程序开发采用 MounRiver Studio 开发工具中集成的 RISC-V 工具链，编写包含解密功能的测试程序：\n启动汇编（start.S）：初始化栈指针到 1KB 地址处，建立程序运行的基本环境：\n.section .init.global mainlui sp, %hi(0x00001000)       // 加载栈基址高12位addi sp, sp, %lo(0x00001000)  // 生成完整32位地址jal ra, main                  // 调用C主函数ebreak                        // 程序结束\n\nC 语言逻辑：实现 ROT13 解密算法，将混淆字符串转换为可读信息：\nvolatile char *pmem = (void*)0x1000;     // 定义输出缓冲区void putc(char c)&#123;    *pmem++ = c;&#125;void puts(const char *s)&#123;    volatile int j;    while (*s)    &#123;        putc(*s++);    &#125;&#125;void *memcpy(void *dest, const void *src, int n)&#123;\twhile (n) \t&#123;\t\tn--;\t\t((char*)dest)[n] = ((char*)src)[n];\t&#125;\treturn dest;&#125;void main()&#123;    // 待解密的字符串    char message[] = &quot;$Uryyb+Jbeyq!+Vs+lbh+pna+ernq+guvf+zrffntr+gura$gur+CvpbEI32+PCH&quot;            &quot;+frrzf+gb+or+jbexvat+whfg+svar.$$++++++++++++++++GRFG+CNFFRQ!$$&quot;;    // ROT13解密逻辑    for (int i = 0; message[i]; i++)        switch (message[i])        &#123;        case &#x27;a&#x27; ... &#x27;m&#x27;:        case &#x27;A&#x27; ... &#x27;M&#x27;:            message[i] += 13;            break;        case &#x27;n&#x27; ... &#x27;z&#x27;:        case &#x27;N&#x27; ... &#x27;Z&#x27;:            message[i] -= 13;            break;        case &#x27;$&#x27;:            message[i] = &#x27;\\n&#x27;;            break;        case &#x27;+&#x27;:            message[i] = &#x27; &#x27;;            break;        &#125;    // 输出解密后的数据    puts(message);    while(1);&#125;\n\n内存链接脚本（firmware.lds）：定义 32KB 统一编址空间，整合代码与数据：\nMEMORY &#123;    mem : ORIGIN = 0x00000000, LENGTH = 0x8000&#125;SECTIONS &#123;    .memory : &#123;        . = 0x000000;        start*(.text);        *(.init);        *(.text);        *(*);        end = .;        . = ALIGN(4);    &#125; &gt; mem&#125;\n\n（二）STM32 控制程序实现通过 FMC 总线实现固件加载与状态控制：\n#include &lt;stdio.h&gt;#include &quot;incfile.h&quot;INCFILE(fw, &quot;main.bin&quot;);    // 嵌入二进制固件int main(void)&#123;  /* MCU Configuration--------------------------------------------------------*/  MPU_Region_InitTypeDef MPU_InitStruct = &#123;0&#125;;  /* Disables the MPU */  HAL_MPU_Disable();  /* Configure the MPU attributes for the FMC */  MPU_InitStruct.Enable           = MPU_REGION_ENABLE;  MPU_InitStruct.Number           = MPU_REGION_NUMBER0;  MPU_InitStruct.BaseAddress      = 0x60000000;  MPU_InitStruct.Size             = MPU_REGION_SIZE_256MB;  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;  MPU_InitStruct.IsBufferable     = MPU_ACCESS_NOT_BUFFERABLE;  MPU_InitStruct.IsCacheable      = MPU_ACCESS_NOT_CACHEABLE;  MPU_InitStruct.IsShareable      = MPU_ACCESS_NOT_SHAREABLE;  MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_DISABLE;  MPU_InitStruct.TypeExtField     = MPU_TEX_LEVEL0;  MPU_InitStruct.SubRegionDisable = 0x00;  HAL_MPU_ConfigRegion(&amp;MPU_InitStruct);  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */  HAL_Init();  /* Configure the system clock */  SystemClock_Config();  /* Initialize all configured peripherals */  MX_GPIO_Init();  MX_FMC_Init();        // 初始化FMC总线  MX_USART1_UART_Init();// 初始化输出串口#define SRAM_ADDR (0x60000000)  HAL_Delay(1000);      // 等待FPGA程序上电复位完成  uint16_t *addr = (void*)SRAM_ADDR;  // 测试FMC内存读写  for(int i = 0; i &lt; 1024; i++)&#123;      addr[i] = i;  &#125;  for(int i = 0; i &lt; 1024; i++)&#123;      if(addr[i] != i)&#123;          printf(&quot;sram error %d %d\\r\\n&quot;, i, addr[i]);          break;      &#125;  &#125;  printf(&quot;sram check complate\\r\\n&quot;);  // 加载固件到FPGA  const uint16_t *fw = FILEPTR(fw);  int fw_size = FILESIZE(fw);  for(int i = 0; i &lt; fw_size/2+1; i++)&#123;      addr[i] = fw[i];  &#125;  printf(&quot;firmware load complate\\r\\n&quot;);  // 控制RISC-V运行  uint16_t *run_enable = (uint16_t*)(0x60000000 + (0x4001 &lt;&lt; 1));  *run_enable = 1; // 写入1启动软核  HAL_Delay(1000);  *run_enable = 0; // 写入0暂停软核  // 读取并显示结果  const uint16_t *msg = (uint16_t*)(0x60000000 + (0x1000));  uint16_t buf[64];  for(int i = 0; i &lt; 64; i++)&#123;      buf[i] = msg[i];  &#125;  const char *msg_str = (void*)buf;  printf(&quot;\\r\\n%s\\r\\n&quot;, msg_str);  while (1)  &#123;      HAL_Delay(500);      printf(&quot;hello world\\r\\n&quot;);  &#125;&#125;\n\n程序通过内存映射方式将 FPGA 的 ERAM 视为 STM32 的外部 SRAM，直接通过指针操作实现数据交互。控制寄存器（0x4001）的单个 bit 即可启动 &#x2F; 停止 RISC-V 核，体现了内存映射接口的简洁性。\n五、调试过程与关键验证（一）时序约束要点时钟配置：对 PLL 生成的 100MHz 时钟进行时序约束，确保时钟抖动小于 500ps\n异步接口：在 FMC 模块中使用寄存器打拍处理异步信号，避免亚稳态问题\n（二）测试结果验证当 STM32 完成固件加载并启动 RISC-V 核后，串口终端显示：\nsram check complatefirmware load complateHello World! If you can read this message thenthe PicoRV32 CPU seems to be working just fine.                TEST PASSED!\n\n这表明：\n\nFMC 总线通讯正常，数据读写无误\nRISC-V 软核正确执行了 ROT13 解密算法\n双核心系统的协同控制机制有效\n\n（三）学习RISC-V汇编所有都正确执行后，再回过头看看RISC-V测试程序的反汇编代码，看看有没有因为编译优化而存在程序运行作弊的情况。\n00000000 &lt;init&gt;:   0:   00000137                lui     sp,0x0   4:   40010113                addi    sp,sp,1024 # 400 &lt;end+0x233&gt;   8:   0cc000ef                jal     ra,d4 &lt;main&gt;   c:   9002                    ebreak0000000e &lt;putc&gt;:   e:   15802783                lw      a5,344(zero) # 158 &lt;pmem&gt;  12:   00178693                addi    a3,a5,1  16:   14d02c23                sw      a3,344(zero) # 158 &lt;pmem&gt;  1a:   00a78023                sb      a0,0(a5)  1e:   8082                    ret...000000d4 &lt;main&gt;:  d4:   7175                    addi    sp,sp,-144  d6:   08000613                li      a2,128  da:   05400593                li      a1,84  de:   850a                    mv      a0,sp  e0:   c706                    sw      ra,140(sp)  e2:   3fa9                    jal     3c &lt;memcpy&gt;  e4:   870a                    mv      a4,sp  e6:   04d00593                li      a1,77...00000158 &lt;pmem&gt;: 158:   1000\n\n看看putc函数的行为，从0x158地址取出数保存到a5寄存器，a5寄存器加1后保存到a3寄存器，再将a3寄存器的值写回到0x158地址处。最后将a0寄存器的值写入a5地址下实现数据输出。这里可以看到0x158地址下的初值就是0x1000，也就是pmem变量的初值。功能同C语言描述的一致，同时也表明代码和数据为统一编址，没有区分RAM和ROM。如果要区分ROM和RAM，需要添加一些启动代码来处理data段数据的拷贝。\n前面RISC-V的C代码中有一个memcpy函数不知道你注意到没有，为什么需要这个函数呢？如果将这个函数删除掉，确实会导致无法编译通过。通过检查汇编才发现main函数确实会调用memcpy，根据汇编代码和map文件，main函数的逻辑是原静态字符串存储在rodata区，然后在栈上分配了一段内存来保存message数据，所以这里需要memcpy来处理一大段内存的拷贝。这也是同ARM汇编不一样的地方，学的新知识了😄\n（四）观察RISC-V的运行通过FPGA开发工具提供的芯片调试工具，可以去捕获观测FPGA运行过程中寄存器的值。通过观测reg_pc和mem_rdata，更加直观的看到RISC-V的运行过程和内存取值的过程。发现每个指令执行的周期为1~7个时钟周期不等。jal跳转指令执行最快，仅需1个时钟周期。内存读写指令(sw)、条件跳转(bnez)、加法(addi)指令等需要5个时钟周期。\n六、总结回顾开发过程，学会了Verilog模块化设计的基本方法，尤其是内存接口的应用。此外还增强了对RISC-V的了解，实现了从源码、工具链再到硬件执行的完整流程。\n回忆起我刚毕业参加工作，那时公司研发的项目基本上全采用ARM+FPGA的开发形式，ARM侧做纯粹的软件应用逻辑，FPGA控制底层的硬件。ARM和FPGA采用FMC接口进行通讯，通过内存映射的方式传输数据，这样ARM可以很方便的和FPGA进行通讯。当年由于能力有限，我并没有太深入的去了解这其中的通讯原理。主要是当时开发ARM的和开发FPGA的是两拨人，我主要负责ARM软件的开发，并没有机会接触到FPGA开发，后来觉得非常的遗憾。\n通过这个小项目的开发经历也算是弥补了当年未能深入参与开发的一些遗憾。期待将项目中得到的经验应用到实际工作中，进一步探索FPGA在嵌入式领域的应用。\n"},{"title":"加密算法库之mbedtls","url":"/2025/08/01/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%BA%93%E4%B9%8Bmbedtls/","content":"一直对各种加密算法库都非常感兴趣，之前用wolfssllib做过一些关于RSA的非对称加密的测试。最近又在做https相关的内容，由于wolfssllib的版权问题，不方便于商业开发使用，所以准备换到mbedtls进行https相关的开发。\nmbedtls的移植和使用都比较简单，唯一走的弯路就是在实现底层calloc函数时出了一点意外，最开始没注意到申请的内存需要清零，因为我用的是malloc来申请内存，内存默认没有清零，导致mbedtls在进行大数运算时经常卡死或者出错，这个问题折腾了好久。\n用mbedtls作为https的tls层，配置基本可以照搬官方的默认配置模板，然后做一些针对特定平台的适配，主要是内存、时间、随机数生成器这方面的适配。\n考虑到在单片机环境不方便更新CA证书，我选择不校验服务器证书。这或许会导致中间人攻击，但是在专用通讯网络中，我认为没有这方面的风险。\n关于https的细节不是我今天想说的，我今天想对比一下wolfssl和mbedtls的RSA算法差异。虽然目前主流的服务器的tls都基本上是椭圆曲线加密，但是RSA作为一种非常经典的非对称加密算法，仍然值得学习。\n这里先对比一下wolfssl和mbedtls的RSA算法在ARM单片机(STM32H7@480MHz)上执行的效果，以生成一个2048位的密钥对来进行测试。\n\n\n\nlib\nwolfssl\nmbedtls\nmbedtls(without MBEDTLS_HAVE_ASM)\n\n\n\n执行时间(秒)\n25.7\n2.17\n15.8\n\n\n堆内存使用(kb)\n17.2\n14.2\n14.2\n\n\n显然在单片机上mbedtls的性能要好得多，我认为其中最关键的应该是mbedtls针对特定处理器架构所做的优化，这些优化在大整数计算性能方面有非常大的提升。\n通过对运行时heap区的数据进行分析，wolfssl性能偏低的原因主要是在进行大整数计算时频繁的内存分配导致的。wolfssl在生成2048长度密钥时，内存分配次数达到了20万次以上，而mbedtls生成相同的密钥数据时内存分配只有几千次。\nwolfssl也不是完全没有优点，通过对编译后的二进制文件进行分析，mbedtls相关函数所使用的栈空间要更多一些，总调用栈深度达到了3kb字节，而wolfssl的栈调用深度在1kb以内。\n了解RSA算法的开发者应该都知道，RSA密钥生成中最关键的算法就是大质数生成算法，这应该是决定两者性能关键的算法。\n通过分析代码来看，两者的实现都基本上差不多。首先利用随机数生成器生成一个2047位的随机数，然后判断这个树是不是质数，如果不是质数则重新生成一个，直到生成了一个可以用的质数。\n根据素数定理来看，在这种长度级别的整数附近，素数的密度在千分之一左右。所以这是一个需要反复试错的算法，这是无法避免的。\n所以为了提升效率，素数的判定上就必须要尽可能的优化。mbedtls构造了1000以内的质因数用来快速验算待判定的树是否存在一些小的因数，然后再使用Miller-Rabin算法进行素性测试。wolfssl在操作上类似，不过它的素因数表要稍微大一些，最大的素数是1619。此外，在验算两个大质数的距离时，两个库也存在区别，mbedtls先生成两个大质数P和Q，再计算它们的距离，如果距离太近的化就重新生成P和Q。而wolfssl在校验第二个质数Q的素性前先进行了距离计算，这样效率应该快一些，且当距离不满足要求时只需要重新生成Q即可。看起来在这些细节方面wolfssl的策略要更好一些，不过它的代码看起来也要复杂许多。\n在移植这两个算法库之余，还学习椭圆曲线加密相关的内容。RSA密钥生成过程中由于需要不断试错来寻找大质数，所以在嵌入式系统中看起来它的性能就不是很稳定。而椭圆曲线加密在这方面就要好得多，椭圆曲线的密钥生成不依赖大质数生成，无论是计算量还是稳定性都要好得多。椭圆曲线依靠椭圆曲线上的离散对数问题的复杂性来保证安全，而RSA依靠大数分解难题来保证安全性，在安全性上面椭圆曲线也应该要更好。\n"},{"title":"内存陷阱，一种内存调试方法","url":"/2022/07/25/%E5%86%85%E5%AD%98%E9%99%B7%E9%98%B1%EF%BC%8C%E4%B8%80%E7%A7%8D%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/","content":"需求场景在一个多任务系统中，当一个全局可访问的数据出现了异常，如何排查问题呢？由于在多任务环境中，各个任务并行运行，一般的单步跟踪调试很难定位问题。逐个屏蔽代码又可能会导致问题无法复现。使用内存断点是比较好的方法，但是大多数集成开发环境对该功能的支持不完美，且使用场景有限。\n下面引入一个问题代码场景，分析该问题的排查方法。\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        delay(1000);    &#125;&#125;void isr_a(void)&#123;    *p = *p + 1;&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n\n在这段程序中任务A分配了一段内存空间，并打开了一个外部中断，任务A统计中断发生的次数，每秒输出一次数据并清零。如果此时存在一个任务B，由于其它故障导致变量被分配到了同一段内存上，显然任务A统计次数的变量就会出现数据异常的现象。\n由于地址0x2000会被正常的任务A和中断A访问，同时被异常的任务B访问。集成开发环境中的内存断点无法正常区分正常的访问和非法的访问，进而导致无法准确的跟踪到问题代码。\n适时启用内存断点如果能够在代码中实时的启用和关闭内存断点，看这个问题就能解决了。大致看起来是这样的：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        disable_mem_break(0x2000);        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        enable_mem_break(0x2000);        delay(1000);    &#125;&#125;void isr_a(void)&#123;    disable_mem_break(0x2000);    *p = *p + 1;    enable_mem_break(0x2000);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当正常访问数据时就先把内存断点关闭，当数据正常访问完成后再开，这样线程B非法访问数据时就会被内存断点捕获。这样在代码中适时添加、删除断点的行为是可行的。\n内存断点的原理ARM Cortex-M3以上的内核都具有CoreDebug和DWT内核外设模块，它们的一个功能就是实现内存断点机制，通过在DWT的监视表上记录需要监视的内存地址，监视的方式(读、写)等参数，当满足条件时就会触发DebugMon_Handler异常中断。这个过程显然是代码可控制的。\ntypedef struct&#123;  __IOM uint32_t CTRL;      __IOM uint32_t CYCCNT;    __IOM uint32_t CPICNT;    __IOM uint32_t EXCCNT;    __IOM uint32_t SLEEPCNT;  __IOM uint32_t LSUCNT;    __IOM uint32_t FOLDCNT;   __IM  uint32_t PCSR;      __IOM struct&#123;    uint32_t COMP;    uint32_t MASK;    uint32_t FUNCTION;    uint32_t RESERVED;  &#125; W[4];&#125; DWT_Type;\n不同的处理器内核所具有的内存断点数量是不一样的，一般CM3、CM4、CM7只有4个，更高级的内核数量会多一些。同时监视4个地址下的内存能够满足很多分析场景。打开内存监视功能需要写入COMP、MASK、FUNCTION三个寄存器，其中COMP寄存器写入待监视的地址，FUNCTION表示监视的方式(5:read 6:write 7:read&amp;write 0表示关闭监视)，MASK表示监视的数据位宽(0:8位 1:16位 2:32位)。\n此外，还需要打开DebugMon_Handler异常中断，需要向CoreDebug模块的DEMCR寄存器第16位和24位写入1，用来打开DebugMon异常。\n代码mem_trap.h\n#ifndef _CPU_MEM_TRAP_H#define _CPU_MEM_TRAP_Htypedef enum &#123;    MEM_TRAP_DISABLE = 0,    MEM_READ_ONLY  = 5,    MEM_WRITE_ONLY = 6,    MEM_READ_WRITE = 7&#125; mem_trap_mode_t;typedef enum &#123;    MEM_8BIT,    MEM_16BIT,    MEM_32BIT&#125; mem_width_t;void mem0_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem0_watchpoint_reset(void);void mem1_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem1_watchpoint_reset(void);void mem2_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem2_watchpoint_reset(void);void mem3_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem3_watchpoint_reset(void);void mem_watchpoint_allreset(void);#endif\n\nmem_trap.c\n#include &quot;mem_trap.h&quot;#include &lt;stdio.h&gt;#if defined(DWT) &amp;&amp; defined(CoreDebug)/* Symbol conflict */#ifdef COMP1#undef COMP1#endif#ifdef COMP2#undef COMP2#endif#define DEF_MEM_WATCHPOINT(i) \\void mem##i##_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width)&#123;\\    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk |\\                        CoreDebug_DEMCR_MON_EN_Msk;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\    DWT-&gt;COMP##i = (uint32_t)addr;\\    DWT-&gt;MASK##i = (uint32_t)width;\\    DWT-&gt;FUNCTION##i = (uint32_t)mode;\\&#125;\\void mem##i##_watchpoint_reset(void)&#123;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\&#125;void mem_watchpoint_allreset(void)&#123;    DWT-&gt;FUNCTION0 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION1 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION2 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION3 = MEM_TRAP_DISABLE;&#125;DEF_MEM_WATCHPOINT(0)DEF_MEM_WATCHPOINT(1)DEF_MEM_WATCHPOINT(2)DEF_MEM_WATCHPOINT(3)__WEAK void mem_trap_log(int idx, uint32_t pc, uint32_t addr, const char *event)&#123;    printf(&quot;[%d]Trigger memory trap near by %#08x, %s at %#08x\\r\\n&quot;, \\        idx, (unsigned int)pc, event, (unsigned int)addr);&#125;void watchpoint_event_handle(uint32_t *args)&#123;    #define EVENT_PC (args[6])    const char* mem_event[4] = &#123;&quot;READ&quot;, &quot;WRITE&quot;, &quot;READ_WRITE&quot;, &quot;ERROR&quot;&#125;;    if((DWT-&gt;FUNCTION0 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(0, EVENT_PC, DWT-&gt;COMP0, mem_event[(DWT-&gt;FUNCTION0 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION1 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(1, EVENT_PC, DWT-&gt;COMP1, mem_event[(DWT-&gt;FUNCTION1 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION2 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(2, EVENT_PC, DWT-&gt;COMP2, mem_event[(DWT-&gt;FUNCTION2 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION3 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(3, EVENT_PC, DWT-&gt;COMP3, mem_event[(DWT-&gt;FUNCTION3 - 5) &amp; 0x3]);    &#125;&#125;#if defined(__CC_ARM)__asm void DebugMon_Handler(void)&#123;    extern watchpoint_event_handle        /* *INDENT-OFF* */    PRESERVE8    tst lr, #4    ite eq    mrseq r0, msp    mrsne r0, psp    push &#123;lr&#125;    bl watchpoint_event_handle    pop &#123;pc&#125;&#125;#elif defined(__GNUC__)void DebugMon_Handler(void)&#123;    __asm volatile    (        &quot;tst lr, #4                     \\n&quot;        &quot;ite eq                         \\n&quot;        &quot;mrseq r0, msp                  \\n&quot;        &quot;mrsne r0, psp                  \\n&quot;        &quot;push &#123;lr&#125;                      \\n&quot;        &quot;bl watchpoint_event_handle     \\n&quot;        &quot;pop &#123;pc&#125;                       \\n&quot;    );&#125;#endif#endif\n注：这里引用了CMSIS的内容，可以需要inlcude相关的文件。\nDebugMon异常处理函数使用汇编实现的原因是为了在代码中自动定位到触发内存监视的PC指针位置，也就是代码位置。代码的用法也比较简单，当需要保护某块代码中的数据不被异常访问，我们就使用mem0_watchpoint_reset()和mem0_watchpoint()将代码包起来。\n以最开始的那段代码为例：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        mem0_watchpoint_reset();        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);  // 开启保护        delay(1000);    &#125;&#125;void isr_a(void)&#123;    mem0_watchpoint_reset();    *p = *p + 1;    mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当任务C运行时由于内存监视器的存在且打开了对适当内存的保护，访问0x2000地址时就会触发DebugMon异常，该异常函数能够自动分析出任务B中修改数据时的PC指针位置。\n总结在代码中使用这种内存跟踪机制在解决某些内存问题时是很有效的，它对正常的数据访问没有任何影响，但是在正常的数据访问之外，我们在那个数据点上挖了一个陷阱，任何尝试访问数据的代码都会掉入到这个陷阱中并被我们捕获，所有我把这种内存调试方法成为内存陷阱。\n这里对DWT的机制以及寄存器只是一个简单的描述，如果需要了解其中的细节请查阅《ARMv7-M Architecture Reference Manual》，里面有非常详细的描述。\n"},{"title":"单片机总线选择焦虑","url":"/2022/12/11/%E5%8D%95%E7%89%87%E6%9C%BA%E6%80%BB%E7%BA%BF%E9%80%89%E6%8B%A9%E7%84%A6%E8%99%91/","content":"\n当你有多个选择，但是每个选择都不完美时，就会出现选择焦虑！\n\n\n最近在优化单片机上USB协议栈内的代码，我发现了一个我之前没有被注意到的地方，那就是写入到USB端点上的数据是由DMA自动完成的，涉及到DMA的内存区域都需要特别对待，而我之前就是将它当作普通内存处理，也就是普通内存的缓存策略(庆幸运行了这么久居然没出错)。\n由于单片机内的内存分布比较复杂，所以我决定在解决这个问题时顺便优化一下内存布局。这是单片机的总线连接情况，看起来比较复杂。\n\n仔细看看总线的连接情况，发现一个很蠢的事情，目前USBHS1(可以理解为USB的专用DMA)操作的数据位于AXISRAM上，中间要经过一个D2-to-D1 AHB bus的通道，我认为这太不合理了，因为D2域也有三块内存，我决定将USB的缓存调整到D2的SRAM3上，毕竟AXISRAM内存与CPU的交互较多，这样USB的DMA传输数据就几乎能独享到SRAM3的内存总线带宽了，而不用占用D1域的总线矩阵。这样还有一个好处是使用MPU配置缓存策略也比较方便。\n\n不过我改完了之后就发现了新的问题。因为USB协议栈中实现了大容量存储设备实例，需要用到内存卡SDMMC1，这就出现一个新的问题。SD卡的数据操作也是专用的DMA，我使用的是SDMMC1，硬件已经决定了我无法调整到SDMMC2上。观察D1总线矩阵就能看到，SDMMC1无法访问到D2域上。\n\n要解决这个问题就只能让MDAM或者CPU帮忙，把数据从D2域拷贝到D1域的AXISRAM中，然后SDMMC的DMA就能操作数据了。\n为了优化数据总线上的负载反而带来了更多的数据总线操作，这就更蠢了。\n在这里纠结了好久，最后选择在AXISRAM末尾使用约8K字节的数据用来作为USB的缓存，并将它配置为非缓存的模式。\n还是感觉不爽😔，为什么D1域上的SDMMC1不能访问D2，是故意这样设计的吗？\n"},{"title":"在8pin的芯片上运行Linux","url":"/2025/09/18/%E5%9C%A88pin%E7%9A%84%E8%8A%AF%E7%89%87%E4%B8%8A%E8%BF%90%E8%A1%8CLinux/","content":"今年早些时候我在Dmitry Grinberg的blog上看到一个有趣的项目，他用3个8pin的芯片来运行Linux。这个项目让我进一步理解现代计算机的工作原理，所以我决定自己尝试实现这个项目。\n原项目通过引脚时序上的一些复用逻辑来让8pin的STM32G031得以同时驱动一片PSRAM和SD卡，但是这种用法看起来非常的麻烦，我想找一种更简单的方法来达到这个目的。\n后来我接触到RV32IMA项目，该模拟器方案视乎要比uMIPS要更简单，可以运行更简单的Linux固件，这样就可以不使用SD卡了，通过一片NorFlash来存放一个简单的Linux固件。\n现在我的想法就是通过4片8pin的芯片来运行Linux，分别是STM32G031J6M6，APS64064L，W25Q64JV，CH340N。这4个芯片的组合可以构建一个直接插在电脑USB接口上运行的8pin的Linux系统。\n让我们来思考一下如何连接4个芯片。这似乎是一个非常具有挑战性的问题。\n各个部件应该这样连接起来，STM32需要串口一对引脚，一对下载调试引脚，SPI的3个引脚，两个片选信号引脚，还有STM32供电的3个引脚。STM32需要分配11个引脚，这已经超出了STM32G031的8个引脚了。\n\n某些引脚或许可以分时复用来达到需求。首先，下载调试引脚只有在芯片启动时需要，芯片正常运行后就不需要了，所以可以复用为普通引脚。此外NorFlash芯片在上电后可以将数据拷贝到APS6404L芯片中，这样系统串口还未使用时就可以使用NorFlash芯片，这又能够节约一个片选信号线。这样减少了3个信号线正好满足8pin芯片的需求。\n哪些信号复用是一个需要好好考虑的问题。首先调试信号线固定为STM32芯片的7、8脚，且它能够与其它任何信号进行分时复用。如果SPI要使用硬件SPI的话，4、5、6引脚直接分配到SPI。剩余的2、3脚为电源引脚，最后还剩下1、7、8引脚，这三个引脚只有1脚能够作为硬件串口的RX引脚，剩下的7、8脚分配作为两个SPI芯片的片选信号线。此外8脚还需要承担串口TX的功能，所以8脚的片选必须连接到norFlash的片选。因为NorFlash可以和串口分时复用，当从Flash读取数据时，假定串口输出不可用，且从Flash读取数据只在开机读取一次，对串口的功能影响较小。\n最终设计的原理图如下：\n这里除了4个8pin的芯片外，还添加了一个3脚的LDO供电芯片。USB接口选择了印制板型的TYPE-C接口，可以直接插在USB TYPE-C公头上。\n最终的实现效果如下，一个非常小巧的结构。PCB板材厚度一定要是0.8mm，只有该厚度能够正好插入TYPE-C公头接口中。\n\n\n    \n        顶层\n        底层\n        实物\n    \n\n\n\n软件的移植参考了pico-rv32ima，我也将STM32的相关代码放在了Github上，8pin-linux。软件实现中除了RV32软核部分，最有学习价值都就是cache的实现，使用该cache方案在一定程度上弥补了外部串行PSRAM读写效率低的状况，解决了RV32软核运行速度与外部IO速度不匹配的问题，这种技术手段可以借鉴到其它项目中。\nSTM32的固件编译出来接近32kb，ram使用也接近8kb，基本耗尽STM32的存储资源。\nLinux固件文件为Image，在STM32的源码相关目录中存在。它需要提前写入到W25Q64芯片中，可用使用JLink等工具来完成。\nSTM32芯片可以飞线引出SWD引脚，在上电后5秒内连接调试器，连接调试器后需要使用STLink修改芯片的选项字节。将nRST引脚修改为普通GPIO使用，之后再下载STM32的程序。芯片运行5秒后相关的引脚会切换到其它功能，下载调试就不可用了。该SWD接口几乎不具备调试的能力，除非将相关复用功能临时关闭。\n该项目几乎没有额外的调试手段来观察RV32内核的运行情况，唯一的手段是使用示波器观察SPI的CS引脚，通过该引脚可以观察软核的内存IO情况，同时也能判断RV32内核死机问题。\n可以看看Linux启动日志，时间戳为终端自动添加的：\n[15:24:47.759] Start[15:24:47.769] ********************************************************************************************************************************************************************************************************************************************** // 重复输出，此时是STM32在将Linux固件从NorFlash中写入到APS64064L中。Image loaded sucessfuly![15:25:33.150] Linux version 6.1.14mini-rv32ima (user@buildvm) (riscv32-buildroot-linux-uclibc-gcc.br_real (Buildroot -g61a3fe7e) 12.2.0, GNU ld (GNU Binutils) 2.38) #3 Thu May  4 18:56:08 UTC 2023[15:25:33.315] Machine model: riscv-minimal-nommu,qemu[15:25:33.346] Zone ranges:[15:25:33.390]   Normal   [mem 0x0000000080000000-0x0000000080ffefff][15:25:33.425] Movable zone start for each node[15:25:33.459] Early memory node ranges[15:25:33.499]   node   0: [mem 0x0000000080000000-0x0000000080ffefff][15:25:33.540] Initmem setup node 0 [mem 0x0000000080000000-0x0000000080ffefff][15:25:33.679] riscv: base ISA extensions aim[15:25:33.719] riscv: ELF capabilities aim[15:25:33.780] Built 1 zonelists, mobility grouping off.  Total pages: 4063[15:25:33.829] Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0[15:25:33.880] Unknown kernel command line parameters &quot;earlycon=uart8250,mmio,0x10000000,1000000&quot;, will be passed to user space.[15:25:33.938] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes, linear)[15:25:34.080] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[15:25:34.130] mem auto-init: stack:off, heap alloc:off, heap free:off[15:25:34.169] Memory: 13340K/16380K available (1445K kernel code, 269K rwdata, 146K rodata, 874K init, 108K bss, 3040K reserved, 0K cma-reserved)[15:25:34.227] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[15:25:34.269] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0[15:25:34.309] riscv-intc: 32 local interrupts mapped[15:25:34.448] clint: clint@11000000: timer running at 1000000 Hz[15:25:34.500] clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df40, max_idle_ns: 3526361616960 ns[15:25:34.550] sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns[15:25:34.600] Console: colour dummy device 80x25[15:25:34.839] printk: console [hvc0] enabled[15:25:35.318] Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00 BogoMIPS (lpj=10000)[15:25:35.490] pid_max: default: 4096 minimum: 301[15:25:37.777] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[15:25:38.149] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[15:25:51.993] devtmpfs: initialized[15:26:06.741] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns[15:26:50.500] clocksource: Switched to clocksource clint_clocksource[15:29:15.250] workingset: timestamp_bits=30 max_order=12 bucket_order=0[15:38:46.700] Freeing unused kernel image (initmem) memory: 872K[15:38:46.818] This architecture does not have kernel memory protection.[15:38:47.094] Run /init as init process[15:49:25.583] Welcome to pico-rv32ima Linux[15:51:33.919] Jan  1 00:00:49 login[32]: root login on &#x27;console&#x27;[15:51:34.185] [15:52:19.570] ~ # [15:52:57.861] ~ # [15:52:59.748] ~ # uname -a[15:53:15.205] Linux pico 6.1.14mini-rv32ima #3 Thu May  4 18:56:08 UTC 2023 riscv32 GNU/Linux[15:53:16.133] ~ # [15:53:17.588] ~ # uname -a[15:53:23.321] Linux pico 6.1.14mini-rv32ima #3 Thu May  4 18:56:08 UTC 2023 riscv32 GNU/Linux[15:53:24.100] ~ # [15:53:25.459] ~ # free[15:53:36.194]               total        used        free      shared  buff/cache   available[15:53:36.287] Mem:          14212        1892       10984           0        1336       10376[15:53:41.886] ~ # [15:53:43.249] ~ # echo hello[15:54:10.550] hello[15:54:11.507] ~ # [15:54:12.871] ~ # pwd[15:54:29.969] /root[15:54:30.643] ~ # [15:54:32.110] ~ # ls\n\n第30秒成功加载固件。第46秒输出第一行Linux启动消息。第64秒初始化设备文件系统。第14分执行初始程序。第27分42秒启动终端，显示命令提示符。…\n启动花费了将近半小时是让我很意外的。执行pwd和uname -a命令都能正常响应。准备执行ls命令，等了很久都没有输出结果，我认为它应该是还在慢慢运行吧！也有可能是系统挂了！😅\n该软件方案在550MHz的STM32H7芯片上配合高速的SDRAM，可以非常流畅的运行Linux，终端交互都没有任何问题。除了STM32G031芯片的主频低外，外部的串行PSRAM带宽低也是导致Linux运行慢的主要原因。\n"},{"title":"在RTOS中如何优雅的处理Fault异常","url":"/2021/11/06/%E5%9C%A8RTOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86Fault%E5%BC%82%E5%B8%B8/","content":"ARM处理器下的Fault异常ARM处理器当发生异常事件后就会暂停当前程序的运行，处理器进入异常模式，响应一个来自处理器内核或者外设的中断请求。\n这里想要处理的Fault异常就是ARM处理器多个异常中的一类，以Cortex-M7内核的ARM处理器为例，主要的Fault异常有HardFault、BusFault、UsageFault、MemManage。当发生这些异常就表示程序出现了比较严重的错误，进而导致“死机”。\n嵌入式实时操作系统下发生Fault异常后会如何处理常见的各种嵌入式实时操作系统(FreeRTOS、UCOSII&#x2F;III等)都没有特别的对Fault进行处理，基本上都是按照默认处理方式来解决，也就是让处理器进入死循环。\nvoid xxxFault_Handler(void)&#123;    while (1);&#125;\n\n这种处理方式是无可厚非的，因为程序本身发生了致命的故障，暂停当前程序的运行或许能够避免程序发生更严重的错误。大多数单线程嵌入式软件(NoOS)都是这样处理的，一个地方的错误会导致整个系统崩溃。\n但是在多任务环境下，RTOS提供了多线程运行的机制，线程之间是相对独立的运行。基于此，在RTOS中采用这种暂停处理器的方式来处理异常就不是最佳的解决方案了。例如有两个线程在运行(线程A和线程B)，线程B在正常运行，线程A由于地址访问错误，导致触发HardFault异常，Fault异常会暂停整个处理器的运行，不但使发生错误的A线程停止了运行，线程B也被牵连导致运行停止。所以在RTOS中发生异常时想要将出现Fault异常而带来的损失降低到最小，也就是单独停止错误线程的运行而不结束整个系统的运行。\n发生Fault异常后如何暂停异常线程首先需要知道的是，异常并不总是由线程运行导致的，还有用户中断处理程序(IRQ)、RTOS内核调度等，在这些地方发生的异常目前看起来是比较难处理的，所以后面主要处理的就是在线程中发生的Fault异常。这里以FreeRTOS操作系统为例，对于其他的操作系统都能实现类似的解决方案，可以结合实际的处理器、操作系统平台进行修改移植，因为核心思想是一致的。当发生Fault后不能简单的while(1)处理了，更优雅且安全的的实现要完成两步动作：\n\n暂停错误线程的运行\n将CPU的执行权限切换到正常线程中\n\n清理异常线程这是在FreeRTOS下的一个实现：\n// fault_handle.c#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;#if (INCLUDE_xTaskGetIdleTaskHandle == 0)#warning &quot;Unable to switch to a valid task!&quot;#endifvoid* clean_fault_task(void)&#123;    extern void* pxCurrentTCB;    TaskHandle_t fault_task = pxCurrentTCB;    if(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)&#123;        /* RTOS not running. */        return NULL;    &#125;    /* Switch to Idle task and delete current fault task. */    // log_info(&quot;task(%s) fault.\\n&quot;, pcTaskGetName(task));    #if defined(INCLUDE_xTaskGetIdleTaskHandle) &amp;&amp; (INCLUDE_xTaskGetIdleTaskHandle == 1)    pxCurrentTCB = xTaskGetIdleTaskHandle();    #else    return NULL;    #endif    vTaskDelete(fault_task);    return pxCurrentTCB;&#125;\n简单解释一下这段代码的含义。首先需要判断操作系统的任务调度有没有运行，如果操作系统还没有启动，这就说明异常不是在线程中触发的，这就不在解决范围内。然后找到一个可以切入的线程，而且它是处于就绪态的任务，显然最好的选择就是Idle线程了。通过xTaskGetIdleTaskHandle()获取到Idle线程的句柄，赋值给pxCurrentTCB。最后调用vTaskDelete()删除当前错误的线程，并返回新的当前线程就好了。\n这里为什么需要先获取新的的线程再删除旧的错误线程呢？这就需要理解线程删除中发生了什么。\n// void vTaskDelete( TaskHandle_t xTaskToDelete )if( pxTCB == pxCurrentTCB )&#123;    /* A task is deleting itself.  This cannot complete within the    * task itself, as a context switch to another task is required.    * Place the task in the termination list.  The idle task will    * check the termination list and free up any memory allocated by    * the scheduler for the TCB and stack of the deleted task. */    vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );    /* Increment the ucTasksDeleted variable so the idle task knows    * there is a task that has been deleted and that it should therefore    * check the xTasksWaitingTermination list. */    ++uxDeletedTasksWaitingCleanUp;    /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as    * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */    traceTASK_DELETE( pxTCB );    /* The pre-delete hook is primarily for the Windows simulator,    * in which Windows specific clean up operations are performed,    * after which it is not possible to yield away from this task -    * hence xYieldPending is used to latch that a context switch is    * required. */    portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );&#125;// ...if( pxTCB == pxCurrentTCB )&#123;    configASSERT( uxSchedulerSuspended == 0 );    portYIELD_WITHIN_API();&#125;// ...\n这是FreeRTOS线程删除时是进行的一些操作，当判断为删除当前线程(pxCurrentTCB)是会进行的额外操作。FreeRTOS是不能直接删除线程自身的，它是将自己标记为预删除的状态，然后操作系统切换到Idle线程中时去清理这些需要被删除的线程，此外这里还会进行一次主动的线程调度，这是非常危险的，当线程出现错误后，如果继续进行常规调度流程，这可能会涉及到访问错误线程的栈空间，这是不可靠的(导致更严重的错误)。所以线程清理仅仅是让操作系统不再调度这个错误的线程，与原错误线程相关的操作降低到最少。\n进行一次特别的线程调度有何特别？这里的线程调度操作将没有切出线程，只有切入线程，因为本该切入的线程在刚刚前面那段代码中删除了。所以这里的线程调度就不能直接使用系统的API完成调度，这里需要自己实现一段线程调度的代码。这里以一段ARM汇编来实现这段调度程序。\nbic r3, lr, #7cmn r3, #8beq .endbl clean_fault_taskcmp r0, #0beq .endldr r0, [r0]ldmia r0!, &#123;r4-r11, r14&#125;tst r14, #0x10it eqvldmiaeq r0!, &#123;s16-s31&#125;msr psp, r0isbmov r0, #0msr basepri, r0bx r14.end: b .end\n这段汇编代码分为4个部分，第一段，这里是通过LR寄存器的值来判断触发异常是否是在普通的线程中，如果不是在线程中触发的异常将不能处理，直接跳转到最后的死循环中。第二段，调用前面实现的任务清理函数，清理掉错误线程并选择一个新的可运行线程(这里就是Idle线程)，函数返回后，判断r0，如果无法清理错误线程或者没有可用的线程，仍然跳转到最后的死循环中。第三段，r0就是前面函数返回时传递过来的新的线程句柄，它存储的第一个字段就是该线程的栈，栈里面存储的内容结构涉及到FreeRTOS线程调度相关的内容。这里就简单说一说FreeRTOS的任务调度时的栈内结构，栈里面存储的是r4-r11寄存器，这些寄存器是ARM异常处理无法自动保存的。此外还有保存r14(lr)寄存器，它是用来判断栈内是否存储了浮点寄存器的，LR寄存器的bit4指示了线程是否在使用浮点寄存器。由于s0-s15以及浮点状态寄存器FPSR是直接由ARM异常自动完成存取了，所以这里还需要根据线程是否使用了浮点寄存器来存储s16-s31寄存器。\n将待切入运行的线程相关的寄存器都恢复完毕后，就可以退出异常并转入到新的线程去执行了，也就是第四段代码的内容。\n封装异常处理将前面汇编代码进行封装，这样就能够处理多个Fault异常了。\n// fault_handle.h#ifndef _FAULT_HANDLE_H#define _FAULT_HANDLE_H#if defined(__CC_ARM)#define FAULT_HANDLER()#elif defined(__GNUC__)#define FAULT_HANDLER() \\    (&#123; \\    __asm volatile ( \\        &quot;   push &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot; \\        /* Exception not returned to Handle mode */ \\        &quot;   bic r3, lr, #7                  \\n&quot; \\        &quot;   cmn r3, #8                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;                                   \\n&quot; \\        /* Clean fault task and get the pxCurrentTCB address. */ \\        &quot;   bl clean_fault_task             \\n&quot; \\        &quot;   cmp r0, #0                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;   add sp, #24                     \\n&quot; \\        &quot;                                   \\n&quot; \\        /* The first item in pxCurrentTCB is the task top of stack. */ \\        &quot;   ldr r0, [r0]                    \\n&quot; \\        /* Pop the registers that are not automatically saved on \\           exception entry and the critical nesting count. */ \\        &quot;   ldmia r0!, &#123;r4-r11, r14&#125;        \\n&quot; \\        /* Is the task using the FPU context?  If so, pop the high vfp registers too. */ \\        &quot;   tst r14, #0x10                  \\n&quot; \\        &quot;   it eq                           \\n&quot; \\        &quot;   vldmiaeq r0!, &#123;s16-s31&#125;         \\n&quot; \\        /* Restore the task stack pointer. */   \\        &quot;   msr psp, r0                     \\n&quot; \\        &quot;   isb                             \\n&quot; \\        &quot;   mov r0, #0                      \\n&quot; \\        &quot;   msr basepri, r0                 \\n&quot; \\        &quot;   bx r14                          \\n&quot; \\        &quot;                                   \\n&quot; \\        &quot;.end&quot; END_LINE &quot;:                  \\n&quot; \\        &quot;   pop &#123;r0, r1, r2, r3, r12, lr&#125;   \\n&quot; \\        ); \\    &#125;)#define _STR2(x) #x#define _STR(x) _STR2(x)#define END_LINE _STR(__LINE__)#endif#endif\n这段代码实现比前面的汇编多了一些内容，主要是要考虑堆栈平衡以及异常线程清理失败后的恢复线程的问题。前面处理失败是进入一个死循环中，这里没有进入死循环。处理失败后所有的寄存器会恢复到处理前的状态，这样能够为其它错误分析类的程序提供帮助，比如我前面有篇文章讲解了如何进行栈回溯，那段程序就能够衔接在这段程序前面或者后面，帮助分析异常问题。\n这里需要特别提醒，栈平衡是非常重要的一点，尤其是使用汇编来操作栈空间时。要知道，bx lr后后面的代码是无法继续执行的，所以需要保证进入Fault时到执行bx lr时msp栈是平衡的。如果栈不平衡就会导致栈内存空间异常减小。这段宏定义是内联汇编，当它嵌入到C函数后，函数头是否还有栈操作我不确定。可能不同的编译器情况不一样，但我用GCC时没有发现问题。如果你想要把这段代码移植到你的系统中，最好仔细核对栈平衡相关的内容。\n相比于最开始的while(1)，新的异常处理程序可以写为：\nvoid xxxFault_Handler(void)&#123;    FAULT_HANDLER()；    while (1)    &#123;    &#125;&#125;\n这样当一个线程执行出现异常后能够自动停止并继续进行系统调度，保证了系统的持续运行。\n总结通过这种处理方式能够解决线程错误带来的死机问题，但是在实际的生产运行过程中，还需要其它辅助性质的程序来帮助程序更加稳固的运行，例如可以设计一个基于定时器的守护任务，当它监视到线程崩溃结束后自动重启它。这样才更加具有实际意义。\n这段程序任然有不完美的地方，比如它不能处理非线程Fault异常，还有线程清理时是暂停它还是删除它？删除线程后相关资源是否及时回收？这些问题都需要结合实际项目进一步完善。\n"},{"title":"初学射频信号","url":"/2023/05/07/%E5%88%9D%E5%AD%A6%E5%B0%84%E9%A2%91%E4%BF%A1%E5%8F%B7/","content":"\n从事嵌入式软件开发4年有余，我自认为还是有相当多的知识和技能存在欠缺，所以近年来一直保持良好的学习态度，持续充实自身的技能。从之前的文章内容能够看出，我主要围绕嵌入式软件开发的多个方面记录自己的学习心得。但实际上不仅限于此，在过去的一年中有很多机会接触到射频开发，所以学习到了很多有意思的新知识，这对我来说算是一件很有乐趣的事情。这种乐趣来自于对未知的探索，因为我并非专业的科班出身，所以在这之前对射频开发领域是完全一片空白的，因此刚开始对我来说这是一个很大的挑战，但是我逐渐将它变为一种乐趣。以下内容来自与一位初学者的日记。\n\n从射频信号开始什么是射频信号？通俗来说就是特定频率的电磁波信号，但是这个描述太笼统了，因为大多数电子产品都会发射一些干扰信号，这些我并不认为这是射频信号，我理解的射频信号是具有一定信号强度且能够远距离传输的电磁信号。\n射频信号的产生射频信号需要依靠射频电路和天线来产生。通过时钟源、PLL、放大器就能组成简单的射频电路，接触过单片机的开发者应该都听说过PLL这个词，通过它能够得到我们想要的频率的信号，例如单片机内部的主时钟信号、射频信号等。可能有些人对单片机上的晶振有误解，认为单片机的时钟是由晶振提供的，这是不正确的，如果单片机内部具有PLL，那么时钟信号由PLL提供，晶振仅仅是一个时钟参考的作用，用于校正PLL输出的时钟频率。\nPLL的工作原理PLL的全称是Phase-Locked Loop，即相位锁定环路，下图是某PLL信号内部的模块框图，这里只关心最关键的PLL部分。信号的来源是那个正弦符号的那个模块（VCO），它直接输出我们想要的频率，而它输出频率的准确性就是依靠PLL的负反馈机制完成的，输出的信号经过N分频后与参考信号进行比较，当频率和相位不一致时，会调节VCO的电压来调节VCO输出的频率，这个调节是快速且准确的。这个负反馈环就是相位锁定环路，PLL一般先锁定频率，保证频率没有误差，再锁定相位，保证相位一致。CPout和VTune通过一个外部电路连接，一个滤波电路，形成一个更加稳定的PLL环路，这个外部电路叫做环路滤波器。\n天线为什么能发射电磁波我认为这里采用了和变压器类似的原理，我们的天线可以看成变压器的初级绕组，通过施加高频电流，使得天线周围产生交变电场和磁场，距离天线一定距离的电磁场信号能够向空间外自由传播，这就将射频信号发射到空中了。射频信号的接收原理类似，就是空中的电磁场信号耦合到了天线上，相当于变压器的次级绕组。为什么电磁信号能够在空中自由的传播，我目前还不能够完全理解，大致就是变化的电磁和磁场能够相互感应产生，具体到理论上可能需要深入理解麦克斯韦方程。\n调制发射射频信号的意义很大程度上是为了在空中传递信息，因为低频的信号的天线不方便制作，因为天线需要1&#x2F;4波长的长度，当直接发射一个低频信号时所需的天线就显得太庞大了。把需要传递的信号叠加到高频信号上就是一个和好的方法，射频信号承载信息的过程就是调制，调制的方法由很多，有调相、调频等，还可以组合多种不同的调制方法以充分利用信道带宽。什么是信道？传输信息的通道，这里特指射频通道。强调信道的意义是因为所有的空中射频信号都同时存在，而却别它们的就只有频率不同而已，信号因为调频等原因它占用的频率不是一个固定的点，而是一段频率，例如蓝牙的某个信道频率范围是2401~2403MHz，显然整个自由空间的信道是有限的，因为高频信号的产生和传输都是很难的。通过混频器能够将低频信号和高频信号进行叠加合成出另一个射频信号，在这个射频信号中包含了我们先要传递的信号。而那个低频信号就是基带信号，高频信号就是有PLL产生的本振信号。\n阻抗匹配在一般的电路设计中都会考虑阻抗匹配，阻抗匹配是为了功率能够最大程度的传递出去，当阻抗不匹配，信号的功率就不能最大化的进行传递，导致信号质量不佳，更严重的是信号可能引起反射等问题。考虑一个简单的电压源，其内部电阻r，电压源外接一个电阻R构成一个简单的回路，为了使得电阻R的功率最大，显然当R&#x3D;r时其能够获得的功率最大，这时输出阻抗r和输入阻抗R相等，这就是阻抗匹配。在射频电路中除了电阻外，还有电抗(复阻抗中的虚部)，它们共同组成了射频电路中的阻抗。我尝试理解射频电路中的阻抗匹配，发现这是一门非常复杂的学问，还要解决一些偏微分方程。总之保证阻抗匹配是射频电路设计的一大要点。\n如果想要强行调整一个射频端口的阻抗怎么办呢，手动计算肯定是一个非常麻烦的过程，史密斯圆图是一个非常好的工具，它是用于确定射频传输阻抗的基本工具，通过它也能调整端口的阻抗，可以使用史密斯圆图软件进行阻抗的精确计算。史密斯圆图的用途非常广泛，矢量网络分析仪中表示端口的阻抗通常也是在史密斯图上表示。\n一般的射频连接件都使用50欧姆的阻抗进行设计，在设计射频电路时，不同射频模块的连接部分就需要考虑两端的阻抗要一致，对于印刷电路板来说，上面的导线也是射频电路的一部分，所有电路的走线也需要进行阻抗匹配，需要综合考虑PCB布线的线宽、拐角等，此外PCB基板材料的层厚、材料等都是影响PCB走线阻抗的因素，一般的RF4材料的PCB介电常数不稳定，通常不作为高质量射频电路板考虑，进口的罗杰斯PCB是射频电路板中用的较多的。最近国产的特氟龙材料的PCB也能实现稳定优质的介电常数，使用它做了一块天线阵列，效果还比较好。\nS参数学习射频信号，肯定离不开S参数，S参数不仅仅是用于射频领域，它用于所有信号领域。它是描述信号完整性的一个工具，S参数的全程是Scatter参数，即散射参数，一般用于描述一个二端口网络的频域特性。使用S11描述一个端口的反射特性，通常可以用它描述一个天线的质量好坏，S11可以转换为SWR(驻波)表示，一般天线的驻波小于1.2就说明天线质量比较好。S21通常用于描述二端口器件的插入损耗，对于一般的滤波器，在通带内S21大于-0.5dB。\n谐波谐波是一个很有意思的东西，正经的射频信号是标准的正弦波，但是如果它经过分频或者一些其它处理，那么在信号中就会产生谐波成分，谐波就是原始基波信号频率整数倍的频率的信号。一个信号分频后通常是方波，使用傅里叶分解后，很明显能够看到多阶的谐波。此外，一个标准的正弦波信号经过一个非线性元件时，在其内部同样会产生谐波信号的成分，非线性元件就是伏安特性曲线不是一条直线，在其非线性区域带入正弦信号表达式，经过泰勒展开后可以得到原始正弦信号的多阶谐波信号成分，通常阶数越高其振幅越弱。\n接收射频信号射频信号经过在空气中传输后，其信号强度肯定会衰减的，其信号衰减的规律符合自由空间损耗模型，信号衰减值与传播距离的对数线性相关，与信号频率的对数线性相关。大部分待接收的信号强度都比较低，一般在-80dBm以下。为了解析如此低的信号，就需要放大器来放大这个信号，一般使用低噪声放大器，它通常用于放大接收端的微弱信号。将接收到的信号可以采用和发射端类似的方法进行混频来解析我们想要的信号，也就是下变频。下变频后的信号称为中频信号，中频的意思就是中间频率，因为它还不是最终想要的信号。中频信号一般还需要使用带通滤波器进行处理，因为这里需要一把下变频带来的镜频干扰，过滤难度一般和中频大小和滤波器的带宽有关。中频信号经过ADC采样后就得到了基带信号。\nIQ调制现在接收芯片都使用IQ正交调制，即基带信号使用一对正交的信号进行表述，I相就是原始信号下变频后的信号，Q相信号时原始信号经过90度的相位旋转后下变频后的信号，IQ调制能够解决镜频干扰等问题，在信号发射端还能实现扩频的效果。在复平面坐标下，使用I表示实部，Q表示虚部，每一对IQ就表示一个复平面下的一个点，将基带数据映射到复平面上就是IQ调制的过程。\n调制方法信号的调制方法有调频、调幅、调相这三种或者同时使用多种不同类型的调制方法。调幅就是载波频率保持不变，载波信号随着基带信号调整幅度。调频就是载波信号幅度不变，但其瞬时频率的偏移随基带信号做线性变化。调相就是载波信号的相位随基带信号线性变化。\n具体来说，调整方法有AM、FM、PSK、QPSK、QAM、16QAM等。\n星座图表示方法对于具体的调整方法来说，都可以使用IQ调制实现，其调制符号在复平面上的图像就构成了一个星座图像，通过星座图像可以更加清晰理解信号解调的过程。这是一个8PSK调制的星座图。\nOFDMOFDM是正交频分复用的简称，它是一种信号复用的方法，它是一种应用在具体调制方法上层的技术。它将传统的一个信道划分为多个信道，能够更加充分的使用信道带宽。更具体的来说它主要是为了解决再宽带信道中的频率选择性衰落问题而广泛运用的。我自己使用OFDM+QPSK实现了OFDM的收发代码，主要是使用傅里叶变换来实现的，OFDM中使用循环前缀来进行数据同步是一个比较好的设计。不过我在实现OFDM时遇到过一个问题一直没有解决，就是当传输信道中存在相位噪音时，QPSK星座图出现了旋转偏移，显然对于QPSK来说偏移超过90度时就会导致无法正确解调，应该有方法能够解决星座图旋转的问题，不过我目前还不会。\n软件无线电(SDR)一般人很难同时接触射频电路设计和信号调制解调算法的设计。为了简化软件开发人员的学习难度，使用软件无线电技术，可以使用软件的方法直接输出射频信号。这里需要使用相关的射频开发板，通过USB和主机连接，再主机上通过一定的算法生成IQ信号，将IQ信号传输到射频开发板上由射频板输出信号，这对软件开发人员来说是一个很友好的过程。同理信号的接收也可以使用SDR完成。我自己也使用软件无线电开发实际参与多个项目开发，感受到了软件无线电的强大。\n我使用过两款SDR设备，LimeSDR和HackRF，都具有易用的SDR，使用体验也比较好。\n"},{"title":"在创建FreeRTOS任务时容易忽略的一个问题","url":"/2024/07/11/%E5%9C%A8%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/","content":"面向对象的编程思想经常出现在嵌入式软件开发过程中，通常将一组相关的业务逻辑及其相关联的数据封装为一个实例对象以方便数据和方法的集中管理，尤其是在该实例对象还涉及一个关联的任务时，为了将相关的数据传入线程，将所有的数据封装起来是一种非常合理的操作。下面是一段这样的代码：\ntypedef struct &#123;    TaskHandle_t task;    const char *str;    int cnt;&#125; hello_obj_t;void hello_task(void *pvParameters)&#123;    hello_obj_t *obj = (hello_obj_t *)pvParameters;    for(int i = 0; i &lt; obj-&gt;cnt; i++)&#123;        printf(&quot;%s\\n&quot;, obj-&gt;str);        vTaskDelay(1000);    &#125;    TaskHandle_t task = obj-&gt;task;    free(obj);    vTaskDelete(task);&#125;int main_test(const char *str, int cnt)&#123;    hello_obj_t *obj;    obj = malloc(sizeof(hello_obj_t));    obj-&gt;str = str;    obj-&gt;cnt = cnt;    static StackType_t stack[1024];    static StaticTask_t task;    obj-&gt;task = xTaskCreateStatic(hello_task, &quot;hello&quot;, 1024, obj, 10, stack, &amp;task);    return 0;&#125;\n\n这段代码展示一种常见的编程模式，即将任务线程相关的数据封装在一个结构体中，然后在任务创建时传入到任务函数中。当任务将相关业务数据处理完成后删除相关资源。\n上面这段代码看起来没什么太大的问题，对象分配的资源都在线程删除前得到释放。但上面这段代码仍然存在一个致命的缺陷，即可能出现hello_task线程无法被正常删除的情况。\nFreeRTOS在创建任务时，如果被创建的任务优先级高于当前上下文的优先级，会在任务创建函数返回前就调度到新创建的任务中执行，这使得使得任务创建函数没有及时的返回，导致obj-&gt;task无法取得正确的值。线程hello_task执行太快且没有释放CPU执行权时，会导致在任务删除时obj-&gt;task没有取到正确的值，从而导致任务无法被正确删除。\n可能大多数业务代码都不会执行的太快，但在一些极端情况还是需要考虑这个问题，例如上述代码中传入cnt为0时的情况。\n解决这个问题有两个思路，一是使用xTaskCreate()替代xTaskCreateStatic()，xTaskCreate函数通过传参的方式取得任务句柄，不会出现上述问题，它可以保证在任务执行前就将句柄赋予正确的值。二是在使用xTaskCreateStatic接口前关闭任务调度器，在任务创建完成后在打开任务调度，确保任务创建函数正常返回后再启动任务调度器。\n或许可以使用vTaskDelete(NULL)来删除当前线程，这样就能规避该问题。但通过上面这个示例可以看出这是一个时序不严谨的代码可能导致比较严重的问题，在实现其它类似这样的多线程代码时也应当注意类似的问题。\n"},{"title":"复刻一个BlackMagicProbe","url":"/2024/09/05/%E5%A4%8D%E5%88%BB%E4%B8%80%E4%B8%AABlackMagicProbe/","content":"Black MagicBlack Magic Probe是一个内建GDB server的嵌入式芯片调试器，可以用来调试ARM、riscv等单片机。关于该调试器的详细信息可以参考官网网。\n克隆版本我基于官方的固件，设计了一个电路板，做了一个自己的版本，主要的功能同官方版本一样，只是多了目标设备电源控制和电压检测功能。\n\n\n图1. 自己设计制作的BMP\n\n\n常用命令这里记录一些该调试器常用的一些命令，方便以后查阅。\n# 查询BlackMagic设备的串口号# powershellGet-CimInstance -ClassName Win32_SerialPort -Filter &quot;PNPDeviceID like &#x27;USB\\\\VID_1D50&amp;PID_6018&amp;MI_00%&#x27;&quot; | Select -ExpandProperty DeviceID | Set-Variable -Name BMP_GDB_PORT# 固件一键下载arm-none-eabi-gdb -nx --batch -ex &#x27;target extended-remote \\\\.\\\\COM21&#x27; -ex &#x27;monitor swdp_scan&#x27; -ex &#x27;attach 1&#x27; -ex &#x27;load&#x27; -ex &#x27;compare-sections&#x27; -ex &#x27;kill&#x27; binary.elf# GDB命令# 连接调试器target extended-remote \\\\.\\COM21# 使用SWD模式扫描设备monitor swdp_scan# 使用JTAG模式扫描设备monitor jtag_scan# 连接目标设备attach 1# 设置下载线频率monitor freq 900k# 目标设备供电控制monitor tpwr enablemonitor tpwr disable# 下载固件load binary.elf# 比较固件compare-sections# 使用RTT功能monitor rtt# 查看寄存器info registers# 运行目标设备startrun# 断点调试break &lt;function&gt;break &lt;file&gt;:&lt;line&gt;watch &lt;var&gt;# 退出调试器detachkill\n\n在STM32CubeIDE中调试新建一个调试配置，类型选择GDB Hardware Debug。\n在Debugger选项框中GDB命令输入arm-none-eabi-gdb。勾选Use remote target，Debug server选择Generic Serial, 协议选择extended-remote，端口选择BMP的串口号(例如\\\\.\\COM21 or COM6)。\n在Startup选项框中初始命令输入：mon tpwr enablemon freq 900kmonitor swdp_scanattach 1\n如果仅调试不下载程序则不勾选load image。可以为下载单独建立一个配置，否则每次下载都要执行一遍下载动作(影响芯片Flash寿命和调试的速度)。\n勾选Set breakpoint at, 后面输入main。表示在main函数建立一个默认断点。在下面的命令框中再输入run指令，这样可以每次启动调试都会复位一次程序，如果不想复位则不输入。\n保存该配置即可开始调试。\n在VSCODE中调试我最开始的想法是使用VSCODE中原生的调试组件，但是在进行了一些尝试后发现Native Debug存在一些问题。这似乎是cppdbg不太兼容串口远程调试，在执行附加进程时会出现一些故障，可能是GDB server交互存在一些兼容性问题。我在检索相关资料时也发现其它网友存在该问题。\n这个无法使用的调试配置也可以参考：\n&#123;    &quot;name&quot;: &quot;Black Magic Probe(invalid)&quot;,    &quot;type&quot;: &quot;cppdbg&quot;,    &quot;request&quot;: &quot;launch&quot;,    &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,    &quot;MIMode&quot;: &quot;gdb&quot;,    &quot;targetArchitecture&quot;: &quot;arm&quot;,    &quot;logging&quot;: &#123;&quot;engineLogging&quot;: true&#125;,    &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,    &quot;miDebuggerPath&quot;: &quot;arm-none-eabi-gdb&quot;,    &quot;customLaunchSetupCommands&quot;: [        &#123;&quot;text&quot;: &quot;cd $&#123;workspaceRoot&#125;/Debug&quot;&#125;,        &#123;&quot;text&quot;: &quot;file $&#123;workspaceFolderBasename&#125;.elf&quot;&#125;,        &#123;&quot;text&quot;: &quot;target extended-remote \\\\\\\\.\\\\COM23&quot;&#125;,        &#123;&quot;text&quot;: &quot;monitor tpwr enable&quot;&#125;,        &#123;&quot;text&quot;: &quot;mon freq 500k&quot;&#125;,        &#123;&quot;text&quot;: &quot;monitor swdp_scan&quot;&#125;,        &#123;&quot;text&quot;: &quot;attach 1&quot;&#125;,        &#123;&quot;text&quot;: &quot;load&quot;&#125;,        &#123;&quot;text&quot;: &quot;cd $&#123;workspaceRoot&#125;&quot;&#125;,        &#123;&quot;text&quot;: &quot;set mem inaccessible-by-default off&quot;&#125;,        &#123;&quot;text&quot;: &quot;break main&quot;&#125;    ],    &quot;serverLaunchTimeout&quot;: 10000,    &quot;windows&quot;: &#123;        &quot;miDebuggerPath&quot;: &quot;arm-none-eabi-gdb.exe&quot;    &#125;&#125;\n\n无法使用原生调试，那就只有依赖于VSCODE插件，很流行的一个调试插件cortex-debug支持Black Magic Probe，这里列出下载脚本和调试脚本。\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;BMP Download&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;executable&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;type&quot;: &quot;cortex-debug&quot;,            &quot;device&quot;: &quot;&quot;,            &quot;runToEntryPoint&quot;: &quot;main&quot;,            &quot;showDevDebugOutput&quot;: &quot;raw&quot;,            &quot;servertype&quot;: &quot;bmp&quot;,            &quot;interface&quot;: &quot;swd&quot;,            &quot;BMPGDBSerialPort&quot;: &quot;\\\\\\\\.\\\\COM23&quot;,            &quot;powerOverBMP&quot;: &quot;enable&quot;,            &quot;preLaunchCommands&quot;: [&quot;mon freq 500k&quot;]        &#125;,        &#123;            &quot;name&quot;: &quot;BMP Debug&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;executable&quot;: &quot;$&#123;workspaceRoot&#125;/Debug/$&#123;workspaceFolderBasename&#125;.elf&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;type&quot;: &quot;cortex-debug&quot;,            &quot;device&quot;: &quot;&quot;,            &quot;runToEntryPoint&quot;: &quot;main&quot;,            &quot;showDevDebugOutput&quot;: &quot;raw&quot;,            &quot;servertype&quot;: &quot;bmp&quot;,            &quot;interface&quot;: &quot;swd&quot;,            &quot;BMPGDBSerialPort&quot;: &quot;\\\\\\\\.\\\\COM23&quot;,            &quot;powerOverBMP&quot;: &quot;enable&quot;,            &quot;preAttachCommands&quot;: [&quot;mon freq 500k&quot;]        &#125;    ]&#125;\n\nBlack Magic还支持RTT功能，可以使用postAttachCommands选项去手动开启，我简单测试了一下，似乎会影响调试功能。\nPS:cortex-debug参数说明\n总结Black Magic Probe非常的灵活好用，不依赖特别的驱动，支持主流的三大操作系统，且不需要类似openocd的中间适配层就能实现完整的嵌入式调试。\n相较于Jlink等调试器来说，它的性能不算特别强大，但它可以和GDB调试器直接交互，使得它的灵活性更强。\n目前该调试器的缺陷是速度问题，USB2.0FS在某些情况下可能会出现一些意外的情况。后续我想制作一个高速版本的BMP来改进使用体验。\n"},{"title":"妙不可言的异常捕获机制","url":"/2024/04/25/%E5%A6%99%E4%B8%8D%E5%8F%AF%E8%A8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6/","content":"什么是异常捕获异常捕获是程序员在程序中捕获异常的一种方式，异常捕获可以避免程序崩溃，让程序继续运行。当程序的运行环境收到异常信息后，会自动寻址处理该异常的catch块处理该异常，这个过程被称为异常捕获。\n大部分高级的编程语言都提供了异常捕获机制，如Java、C++、Python等。C语言不提供异常捕获机制，尤其是在嵌入式开发中，C语言的异常捕获机制非常弱，而且容易导致程序崩溃。所有一般MCU提供了错误检测机制，如：HardFault等中断，但是这些中断是直接导致程序崩溃的，而不是异常捕获机制。\n本文提供了一种方法，可以捕获C语言中的异常，并且可以自定义异常处理过程，可以到达同一般异常捕获机制相似的效果。\n异常捕获的基本原理通过try语句标记捕获异常的代码，通过catch语句标记异常处理代码。所以在执行try语句时，需要保存程序上下文的信息，以便在catch语句中恢复执行。保存上下文的过程根据不同的处理器架构有所不同，但基本思路是保存处理器寄存器、堆栈指针、堆栈内容等。\n如何保存上下文信息这里通过特定的处理器来说明上下文信息是如何保存的，以Cortex-M7芯片为例，其它的芯片的实现方式类似。上下文信息包括：寄存器、栈指针、LR、PC、PSR。其中寄存器需要根据AAPCS规范来处理，即主要保存被调用者保存寄存器，包括R4-R11。调用者的寄存器在外层栈帧中已经处理过了，所以不需要保存。栈指针为SP寄存器。程序指针这里将使用LR指针，通过它可以快速返回到异常调用的出口位置。\nShow code:\n.global try_save_context.type try_save_context,%function.thumb_func// typedef int try_ctx_t[10];// int try_save_context(try_ctx_t ctx);try_save_context:    push &#123;r0, lr&#125;    mov r2, r0    mov r0, #0    mov r1, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;r0, lr&#125;    mov ip, sp    stmia.w r0!, &#123;r4, r5, r6, r7, r8, r9, sl, fp, ip, lr&#125;    mov r0, 0    bx lr\n这里实现了一个保存上下文函数的接口，用户传入一个try_ctx_t结构体指针，保存上下文。该指针将保存到FreeRTOS的线程本地存储中，方便后续恢复上下文。将处理器的r4、r5、r6、r7、r8、r9、sl、fp、ip、lr保存到try_ctx_t结构体中。最后函数返回0表示上下文保存完成。\n对于非RTOS的用户，这里的代码需要做相应的调整，可以使用一个独立的全局变量来存储ctx，这里就不再详细介绍了。后续的整个实现都是基于FreeRTOS来实现的。\n如何在中断内恢复到用户线程的上下文这是整个异常捕获机制中最复杂的部分。当处理器进入中断后处于handle模式，而用户的线程处于user模式。两者没有在同一个上下运行空间内。如何恢复到用户线程的上下文呢？\n基本思路是从FreeRTOS的线程本地存储中获取用户上下文信息，然后将其中主要的寄存器恢复到处理器寄存器中。然后在用户线程中模拟一个中断栈来保证当前的handle中断能够正常退出，使得用户返回到线程模式后能够继续执行，且用户栈和中断栈都满足平衡的要求。\nShow code:\n#define FAULT_THROW()                                                                           \\    &#123;                                                                                           \\        __asm volatile(                                                                         \\            &quot;dsb \\n isb                     \\n&quot;                                                 \\            &quot;push &#123;r0, r1, r2, r3, r12, lr&#125; \\n&quot;                                                 \\            &quot;tst lr, #4                     \\n&quot;                                                 \\            &quot;beq .end&quot; END_LINE &quot;           \\n&quot; /* Can&#x27;t try in Handle mode */                  \\            &quot;mov r0, #0                     \\n&quot;                                                 \\            &quot;mov r1, #0                     \\n&quot;                                                 \\            &quot;bl pvTaskGetThreadLocalStoragePointer\\n&quot; /* Get try context */                     \\            &quot;cmp r0, #0                     \\n&quot;                                                 \\            &quot;beq .end&quot; END_LINE &quot;           \\n&quot;                                                 \\            &quot;mov r12, r0                    \\n&quot;                                                 \\            &quot;mov r0, #0                     \\n&quot;                                                 \\            &quot;mov r1, #0                     \\n&quot;                                                 \\            &quot;mov r2, #0                     \\n&quot;                                                 \\            &quot;bl vTaskSetThreadLocalStoragePointer\\n&quot; /* Set try context to NULL */              \\            &quot;mov r0, r12                    \\n&quot;                                                 \\            &quot;ldr r1, [r0, 32]               \\n&quot; /* get sp in context */                         \\            &quot;ldr r2, [r0, 36]               \\n&quot; /* get pc in context */                         \\            &quot;sub r1, #32                    \\n&quot; /* adjust sp for user stack frame */            \\            &quot;str r2, [r1, 24]               \\n&quot; /* save PC to the user stack frame */           \\            &quot;mov r2, #0x1000000             \\n&quot; /* xPSR, bit24 is thumb state, it&#x27;s always 1 */ \\            &quot;str r2, [r1, 28]               \\n&quot; /* save xPSR to the user stack frame */         \\            &quot;mov r2, #0x40000000            \\n&quot;                                                 \\            &quot;str r2, [r1,  0]               \\n&quot; /* R0=0x40000000, it&#x27;s the throw value */       \\            &quot;ldmia r0!, &#123;r4, r5,  r6,  r7,    &quot;                                                 \\            &quot;            r8, r9, r10, r11&#125;  \\n&quot; /* restory context */                           \\            &quot;msr psp, r1                    \\n&quot; /* restore the PSP */                           \\            &quot;isb                            \\n&quot;                                                 \\            &quot;pop &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot; /* MSP stack balance */                         \\            &quot;orr lr, lr, #0x10              \\n&quot; /* clear floating-point flag */                 \\            &quot;isb                            \\n&quot;                                                 \\            &quot;bx lr                          \\n&quot; /* exit ISR and jump to user context */         \\            &quot;.end&quot; END_LINE &quot;:              \\n&quot;                                                 \\            &quot;pop &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot;);                                               \\    &#125;#define _STR2(x) #x#define _STR(x) _STR2(x)#define END_LINE _STR(__LINE__)\n这里实现了一个宏定义，用于捕获异常，并跳转到用户上下文。\n\n首先判断跳转到该中断前的处理器模式，如果不是用户模式，则直接返回，因为这不能捕获异常。\n然后判断当前线程本地存储指针内容，这是用于保存上下文信息的指针，如果指针为NULL，则表示当前没有执行try_save_context，所以直接返回。\n如果指针不为NULL，则表示当前执行了try_save_context。同时清空线程本地存储指针，表示当前的异常已经被处理了。\n从上下文信息中取出sp指针，以次为基础构造一个中断栈，这是为了当前的中断能够正常返回而必要的。”sub r1, #32”\n在调整的栈中保存PC指针(即原上下文中的LR寄存器)，构造一个合法的PSR寄存器，PSR寄存器中不需要浮点标志位、栈对齐等信息，只需要处理器模式为thumb模式即可。\n从上下文信息中取出r4-r11的值，依次恢复到各个寄存器中。\n通过msr指令将新的栈指针写入到psp中。\n通过lr寄存器退出当前的中断。特别注意，需要将lr寄存器的浮点上下文标志清除。\n\n当处理器执行bx lr时，处理器根据运行模式从psp中取出r0-r3的值恢复的处理器上，同时取出PC寄存器跳转到用户程序中，这样就完成了从中断上下文恢复到应用程序的上下文。这里涉及到了大量Cortex-M处理器的中断处理机制相关内容，这里就不展开了。\ntry语法糖前面实现了用户线程的保护和恢复，已经就能够实现异常捕获了，类似这样的代码：\nvoid test_func(void)&#123;    try_ctx_t ctx;    if(try_save_context(ctx) == 0)&#123;        printf(&quot;test_func\\n&quot;);        // do something        illegal_function_execution(); // Trigger exception        printf(&quot;never run here\\n&quot;);    &#125;else&#123;        printf(&quot;catch test_func exception\\n&quot;);    &#125;&#125;void test_func2(void)&#123;    _try&#123;        printf(&quot;test_func\\n&quot;);        // do something        illegal_function_execution(); // Trigger exception        printf(&quot;never run here\\n&quot;);    &#125;    _catch&#123;        printf(&quot;catch test_func exception\\n&quot;);    &#125;&#125;\n将test_func函数包装为test_func2函数，需要实现两个语法糖：_try、_catch。\nint try_save_context(try_ctx_t ctx);void try_clear_context(void);#define _try                                             \\    try_ctx_t CONNECT(__ctx, __LINE__);                  \\    if (try_save_context(CONNECT(__ctx, __LINE__)) == 0) \\    &#123;#define _catch           \\    try_clear_context(); \\    &#125;                    \\    else#define CONNECTION(text1, text2) text1##text2#define CONNECT(text1, text2) CONNECTION(text1, text2)\n\n这里需要注意一个问题，当用户程序未出现异常时，需要主动调用try_clear_context函数，这样才能将当前try的上下文环境清除掉，否则try的边界不清晰，导致异常捕获机制出现混乱。\n这里还需要注意的是该语法糖不支持ex消息传递。我最开始设计的时候是想要取得该消息的，但是后来在设计该语法结构时发现这需要使用finial块，但是finial块的意义并不大，且会导致该语法糖变得复杂，所以该语法糖不支持ex消息传递。此外还需要特别注意的是try语句不能独立出现，它必须和catch语句一起出现。\n在使用该语法糖时，还需要注意的一点时，在try语句块中不能直接出现return语句。return语句会破坏try的边界，导致异常捕获机制的混乱。但是在catch语句中可以使用return。\n从用户空间抛出一个异常也是一个有意思的设计。\n.global try_clear_context.type try_clear_context,%function.thumb_func// void try_clear_context(void)try_clear_context:    push &#123;lr&#125;    mov r0, #0    mov r1, #0    mov r2, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;pc&#125;.global _throw.type _throw,%function.thumb_func// void _throw(int ex)_throw:    push &#123;r0, lr&#125;    mov r0, #0    mov r1, #0    bl pvTaskGetThreadLocalStoragePointer    cmp r0, #0    beq .end_throw    mov r12, r0    mov r0, #0    mov r1, #0    mov r2, #0    bl vTaskSetThreadLocalStoragePointer    pop &#123;r0, lr&#125;    mov r1, r12    ldmia r1!, &#123;r4, r5, r6, r7, r8, r9, r10, r11, r12, lr&#125;    mov sp, r12    cmp r0, #0    it eq    moveq r0, #1    isb    bx lr.end_throw:    pop &#123;r0, pc&#125;\n在用户空间调用_throw可以主动抛出一个异常，ex为一个非零的异常编号。\ntry嵌套问题我最开始是想要设计异常捕获嵌套的，因为这不是一个复杂的技术问题，一个链式结构就能够实现。我之所以选择放弃这部分实现的原因是，我担心这会带来一些问题。因为C语言本身不支持垃圾回收，滥用异常捕获机制可能会导致资源泄漏的风险，所以我放弃了异常捕获嵌套的功能。这里实现的异常捕获机制也许更适合一个故障分析的场景，或者用于对一些关键代码进行保护。\n浮点寄存器相关问题这里的设计没有考虑保存浮点上下文，所以在使用的时候需要特别注意用法环境。此外对于惰性压栈机制，我这里使用DSB、ISB指令进行处理，确保浮点数的中断压栈正常，但我对这一块的具体细节不是很清楚，所以需要进一步研究。\n总结我最开始想要该功能的原因是我在执行一些第三方的代码时经常出现hard故障，我需要对这些不可信代码的执行做一个保护，于是写了一个简单的异常捕获机制，将异常捕获后返回一个错误码，然后根据错误码来判断是否需要重试。对于多任务环境，故障时直接将MCU挂起可能带来一些额外的风险，因为某些关键任务程序不能中断运行。这个异常捕获程序很好的解决了这方面的问题。\n测试附件int devide_zero(void)&#123;    int r;    volatile unsigned int a;    volatile unsigned int b;    SCB-&gt;CCR |= SCB_CCR_DIV_0_TRP_Msk;    a = 1;    b = 0;    r = a / b;    return r;&#125;int main_test()&#123;    _try&#123;        printf(&quot;devide zero test\\n&quot;);        // 对于一般的MCU，执行该函数会导致HardFault异常，使处理器停机。        // 但这里的异常捕获机制会使得程序能够继续运行。        devide_zero();    &#125;    _catch&#123;        printf(&quot;catch devide zero fault\\n&quot;);    &#125;    printf(&quot;mcu not stop\\n&quot;);    return 0;&#125;void HardFault_Handler(void)&#123;    FAULT_THROW();    while(1);&#125;\n\nRun output:\ndevide zero testcatch devide zero faultFault Analysis:Exception id: 3Systick: 25857Core register:R0:  00000001  R1:  00000000  R2:  e000ed00  R3:  00000000R4:  900ad014  R5:  24018140  R6:  900ad014  R7:  20003db0R8:  00000001  R9:  900ad014  R10: 00000000  R11: 24015180R12: fa000000  SP:  20003d48  LR:  9007f63f  PC:  9001905cPSR: 61000000  ERT: fffffffd  (PSP / User)Usage Fault:  Divide by zeroHard Fault:  Forced Hard FaultStack memory:20003d48: 00000000 00000001 900ad008 9007a61520003d58: 900ad008 24018140 900ad014 20003db020003d68: 00000001 900ad014 00000000 2401518020003d78: 20003d58 9007a609 00000001 900ad01420003d88: 24018140 00000000 00000000 a5a5a5a520003d98: a5a5a5a5 9007a969 00000001 a5a5a5a520003da8: a5a5a5a5 0da5a5a5 24018140 0000000020003db8: 00000000 00000000 00000000 0000000020003dc8: 00000000 00000000 00000000 0000000020003dd8: 00000000 00000000 00000000 0000000020003de8: 00000000 00000000 00000000 0000000020003df8: 00000000 00000000 00000000 0000000020003e08: 00000000 00000000 a5a5a5a5 a5a5a5a520003e18: a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a520003e28: a5a5a5a5 a5a5a5a5 a5a5a5a5 900834f520003e38: a5a5a5a5 a5a5a5a5 20003d4c 00006501Call stack backtrack:[9001905c] call from &lt;9007f63f&gt;, sp=20003d4c[9007f63f] call from &lt;9007a615&gt;, sp=20003d54[9007a615] call from &lt;9007a969&gt;, sp=20003d9c[9007a969] call from &lt;900834f5&gt;, sp=20003e34Show fault ASM code:9001904a: f043 0310   orr     r3, r3, #169001904e: 6153        str     r3, [r2, #20]90019050: 2301        movs    r3, #190019052: 9301        str     r3, [sp, #4]90019054: 2300        movs    r3, #090019056: 9300        str     r3, [sp, #0]90019058: 9801        ldr     r0, [sp, #4]9001905a: 9b00        ldr     r3, [sp, #0] &lt;break point&gt;9001905c: fbb0 f0f3   udiv    r0, r0, r390019060: b002        add     sp, #890019062: 4770        bx      lr90019064: ed00 e000   stc     0, cr14, [r0, #0]!90019068: b500        push    &#123;lr&#125;9001906a: b083        sub     sp, #129001906c: 9200        str     r2, [sp, #0]9001906e: 460a        mov     r2, r1mcu not stop\n经过测试，该功能工作正常，通过在线故障诊断，已经输出了错误时刻的详细信息，包括：寄存器、堆栈、调用栈、故障点附近的汇编代码。可以发现break point已经给出了故障具体的位置，配合寄存器，可以确认这是除零故障。\n如何在单片机内自诊断，生成详细的故障诊断报告也是一个非常有意思的功能，以后有时间再写一篇文章详细介绍。\n"},{"title":"实现独有的硬件通信总线","url":"/2023/05/07/%E5%AE%9E%E7%8E%B0%E7%8B%AC%E6%9C%89%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/","content":"背景前段时间开发了一个嵌入式软件，其中有一个功能是使用PWM驱动一个无源的蜂鸣器，根据以往的经验来看，这是一个非常简单的功能，不过在实际操作时遇到了一个很多人往往都忽略的问题。我们硬件选择的单片机没有硬件PWM功能，只有普通的定时器，这就意味着我们只能使用定时器+IO口模拟PWM。通过定时器中断操作IO口能够模拟一个较为准确的PWM信号，把这个信号输出到音频放大电路并驱动蜂鸣器后，蜂鸣器能够发出期望的声音，但是其中存在一点噪音，起初以为是驱动电路存在问题，但是经过排查确认是单片机输出的PWM信号频率成分不干净，除了期望的频率信号外，还存在其它频率的信号。如果使用频谱仪进行分析，就能发现其中的杂散成分。导致这个问题的原因是依靠因为CPU控制IO口的时间是不准确的。单片机存在其它高优先级的中断任务，导致定时器的中断被延时触发，进而导致PWM信号生成不准确。这种误差非常的小，大多数人可能都没有注意到模拟硬件IO时序上引入的误差，但它是客观存在的。\n使用软件模拟IO时序总体来说是不常见的，因为软件通常只能模拟一些简单的IIC、SPI、PWM等速度较低的信号。如果你想使用GPIO模拟几百兆时钟频率的USB信号，大多数CPU都是无法完成的。因为CPU侧重于计算而不是这种重复、繁琐的IO控制。当CPU的时钟频率越高，模拟的时序越复杂，CPU的负担也就越重，这种额外的开销对于CPU来说是非常不划算的，所以后面就诞生了FPGA之类的芯片。FPGA芯片几乎能够模拟出任何你想要的硬件时序，但是嵌入式开发中使用FPGA会带来额外的高昂成本，同时限制开发人员使用FPGA的另外一个难题是它复杂的开发方式。\n一种全新的方案-PIO2021年树莓派基金会推出了一款新的微控制器-RP2040，关于这款单片机的详细介绍可以从官网了解。它和一般的ARM微控制器大体上差不多，但是它存在一个特殊的外设-PIO，这是在以往的单片机中从未出现过的，通过PIO可以由硬件自动完成IO口的时序操作而无需CPU的干预。PIO能够独立运行一段简单的程序来控制IO从而实现特定的硬件时序。通过它控制IO是非常高效的，它甚至比CPU直接控制IO还要快。\nPIO的硬件结构RP2040单片机内有两个独立的PIO模块，每个PIO模块的结构如下：每个PIO有4个状态机，状态机是执行指令的实体。4个状态机共享32字的指令存储空间。每个状态机上连接了TXRX FIFO用于与CPU交互数据。FIFO事件和状态机的事件能够触发两个不同的中断，这两个中断是两个PIO共享的。状态机还能够绑定IO列表，用于控制IO口的输入和输出。\n每个状态机上有两个位移寄存器(ISR、OSR)，主要用于数据输出到IO上或者从IO上读取数据。还有两个缓存寄存器(X、Y)，用于保存临时数据和一些中间状态。PC寄存器记录当前的状态机执行到了那一条指令。此外每个状态机都能独立配置时钟，16位的整数分频加8位的小数分频能满足大多数时钟要求。\nPIO编程指南类似于C语言，PIO编程也是先编写PIO代码然后使用PIOASM编译器生成目标文件。生成的目标文件文件格式可以选择，为了方便集成到C-SDK中，PIOASM工具默认生成.h格式的目标文件。\nPIO源文件的组成\n1.注释代码中的注释可以使用分号;或者//作为注释内容的开头。按照官方示例的传统，建议使用分号。\n\n2.伪指令伪指令主要是用于描述一些配置的代码，伪指令以.开头，需要记住的伪指令有这些\n\n\n\n\n\n指令\n描述\n\n\n\n.define ( PUBLIC ) &lt;symbol&gt; &lt;value&gt;\n定义一个符号，类似于C语言中的define，附加public关键字后会在目标文件中也生成同步的宏定义。\n\n\n.program &lt;name&gt;\n声明程序的名称，并表示后续的代码即为程序代码，一个文件中可以包含多个不同名称的代码。\n\n\n.origin &lt;offset&gt;\n用于指定PIO程序必须加载到指定的存储空间地址下，这对于使用了绝对地址跳转的功能是有用的。\n\n\n.side_set &lt;count&gt; (opt) (pindirs)\n声明指令中允许使用侧设置指令来控制io，count表示io的数量，opt意味这代码中不需要每条指令都进行侧设置，pindirs表示设置的是io的方向而不是io的电平状态。\n\n\n其中最难理解的也许是side_set(侧设置)，它是用于控制IO状态的指令，要理解它，我们就将另外三种控制IO的指令拿出来一起说明。PIO有4中方式控制IO口，输入(IN)，输出(OUT)，设置(SET)，侧设置(SIDE_SET)。\n每种控制方式都需要配置一个连续的引脚范围用于控制，各个控制方式的引脚范围是可重叠的，这意味着一个引脚可以同时用4种方式进行控制。引脚数量除了SET、SIDE_SET控制外，其它三种方式都没有引脚数量的限制，SET能最多映射5个引脚，side_set受限与指令编码的位宽，最多5个IO口能够控制。\n输入用于读取IO的值到ISR寄存器中，通过位移的方式读取。输出是将OSR寄存器中的值输出到IO上，同样也是位移的方式。当位移寄存器满了或者空了之后，经过适当的配置，位移寄存器能够自动和FIFO交互数据。SET能够直接控制引脚的电平状态而不依赖位移寄存器。SIDE_SET是附加在一般指令中的指令，它与被附加的指令一起执行，通过它也能够直接设置IO的电平状态。\n此外还有JMP指令能够读取引脚状态，它可以单独配置一个引脚用于条件跳转。\n\n3.标签指令前可以使用一个命名标签用于表示代码段的位置，类似这样的：标签:    指令\n通过这样标签，使用JMP指令就能实现分支流程处理。\n\n指令所有的指令结构都为如下形式：\n&lt;指令&gt; (side &lt;侧设置电平状态&gt;) ([&lt;延时周期&gt;])\n每条指令都可以附加侧设置指令以在执行指令的过程中设置电平状态。延时周期则用于在指令执行完成后延时一段时间再执行下一条指令，如果指令导致状态机阻塞，延时的时间是从结束阻塞开始计算的。PIO支持的9条指令都是单周期指令，这是非常准确的，如果两个状态机设置为相同的时钟频率一起执行同一段代码，它们能够保证同步运行。\n侧设置电平状态和延时周期所占的编码位宽是共享的，如果配置了.side_set 2，意味着可以同时设置两个IO，但是延时时间就只能占用3个位了，即最长只能延时7个时钟周期。此外如果加入了opt选项.side_set 2 opt，意味着opt还要单独占用一位，延时时间只能使用2个位，最长的延时时间就是3个时钟周期。\n9条指令有 JMP、WAIT、IN、OUT、PUSH、PULL、MOV、IRQ、SET。每条指令的细节说明应当去看芯片手册，这里就不需要复述了。这些指令非常的灵活，有很多让人意外的用法，例如将FIFO中的数据取出后把它当作指令执行。\n中断前面提到了PIO具有两条中断线(irq0和irq1)，两个PIO模块是共享的。PIO模块的中断是系统级别的，和SPI等外设的中断在一个层次上，也是由NVIC进行管理的。PIO有12个事件能够触发中断，其中0 ~ 3是来自状态机内部的中断，4 ~ 11是4个状态机共8个FIFO的满空事件中断。\nPIO模块有两条中断线到NVIC，且每个中断事件都是可以单独路由的。举个例子方便理解，PIO0的中断0和中断2事件发送到irq0，PIO0的中断1和中断3事件发送到irq1，PIO1的中断0和中断1发送到irq0，这是可以混搭的。但实际上不会这么使用，因为要在中断处理中去分析PIO0和PIO1的具体中断事件比较麻烦，需要检查每个中断状态寄存器。\n除了PIO具有中断外，每个状态机也具有中断，或者说是中断标志位，PIO的4个状态机共享8个中断标志位，也就是说状态机可以使用8个中断。比如说可以在一个状态机中设置中断标志，在另一个状态机中等待中断标志，这样就实现了状态机的交互。这应该是状态机间进行直接交互的唯一方式了，因为状态机之间是不能传输数据的。8个中断标志位中的前4个可以上报到PIO并触发PIO的中断事件，后4个中断标志仅仅用于状态机内部。处理器通过PIO模块能够直接清除这8个中断标志。\n如果PIO打开了内部0 ~ 3的中断使能，那么任意一个状态机设置了0 ~ 3的中断标志位，中断都会上报到PIO中。由于状态机和CPU的NVIC都能处理一些相同的中断源，所以在使用时，需要注意等待中断中的竟态条件。\nIRQ 1         ;表示设置一个中断标志并继续运行，1表示中断标志位的序号IRQ WAIT 1    ;表示设置一个中断标志并等待该标志被清除IRQ CLEAR 1   ;表示清除一个中断标志\n\n中断标志位的序号有两种表示方式，绝对值和相对值，前面的三个写法都是绝对序号，举例说明一下相对序号的写法：\n; 状态机序号为 1IRQ 5 rel     ;表示设置的中断序号为6，6 = (设置序号 &amp; 4) + (设置序号 + 状态机序号) &amp; 3\n相对序号的具体细节还是要参考芯片手册。\nDMACPU和PIO的数据交互主要是FIFO，但该FIFO的容量有限，且需要通过轮询或者中断来触发数据传输，这对CPU来说是额外的负担，PIO提供了数据请求机制，通过该机制并结合DMA子模块，数据能够无需CPU干预从而在RAM和PIO状态机之间传输大量数据，数据传输速度为每个时钟周期1字节。\nPIO编程中的一些细节PIO状态机总是要一直运行的，可以通过JMP指令进行无条件跳转达到循环的目的，但是PIO提供了一种边界机制，当程序运行到边界后能够自动恢复到起始位置，这个边界默认是程序的起始和结束位置，当然也能够通过.wrap_target指定循环的起始位置，并用.wrap指定循环的结束位置。\n每个状态机都有输入和输出FIFO，用于数据的交互，但是某些应用仅仅输出数据或者读取数据，这样我们可以将它们的FIFO进行合并以扩大FIFO的使用空间。\n再说明一些数据方向的问题，OUT指令是将OSR寄存器的数据输出到PIN，当配置了autopull，OSR位移完成后，TXFIFO中的数据会转移到OSR中。PULL指令是主动将TXFIFO中的数据转移到OSR寄存器中。PULL指令默认是阻塞的，意味着TXFIFO中没有数据时状态机会阻塞运行。\nPIO代码经过PIOASM编译后生成的是一个.h文件，其中有些细节需要知道。如果我们声明的程序名为xx，即.program xx，那么.h文件中会生成一个类型为pio_program的变量，变量名为xx_program。这是用来加载程序的。此外在.program内定义的public符号在生成的.h文件中也会附件xx_的前缀。PIO中的相关配置会转化为一个配置获取函数xx_program_get_default_config()。PIO代码源文件代码是不区分大小写的。\n侧设置的执行和指令执行是同时发生的，在同一个时钟周期内完成。但是需要注意的是，许多指令能够导致状态机阻塞而暂停指令的执行，例如WAIT、PUSH、PULL等，当状态机阻塞时，侧设置是不会被影响的，它总能在第一个时钟周期内完成。\nAUTOPULL是怎么实现的呢？假如将OSR配置为8位，这就意味着当OSR移动了8位后，就需要执行PULL操作，状态机内部记录了OSR位移的量，所以才能够自动触发PULL。\nJMP指令跳转的目标地址在编译后都是相对0的绝对地址，当使用pio_add_program载入程序时，如果载入的偏移地址不是0，那么JMP指令中的目标地址会自动进行调整以保证程序正确运行。这是唯一一个会被重定位的指令。\nC-SDK编程为了用好PIO，还需要大量C-SDK中的接口来配合，实现配置、数据交互、程序加载等。下面说明一些常用的C函数的用法和功能。\n\n1.PIO程序加载类\n\nuint pio_add_program(PIO pio, const pio_program_t *program);加载一个程序，并将程序加载到的位置返回。\nvoid pio_remove_program(PIO pio, const pio_program_t *program, uint loaded_offset);从指令存储空间中卸载程序，需要提供加载地址。\nvoid pio_clear_instruction_memory(PIO pio);清空PIO的全部指令存储空间。\n\n2.状态机类\n\nint pio_claim_unused_sm(PIO pio, bool required);请求一个空闲的状态机。\nvoid pio_sm_init(PIO pio, uint sm, uint initial_pc, const pio_sm_config *config);初始化一个状态机，initial_pc就是程序的加载地址，config可以使用.h文件中生成的一个方法得到。\nvoid pio_sm_set_enabled(PIO pio, uint sm, bool enabled);启动或者关闭状态机。\nvoid pio_set_sm_mask_enabled(PIO pio, uint32_t mask, bool enabled);使用掩码同时启动或者关闭多个状态机。\nvoid pio_sm_restart(PIO pio, uint sm);状态机复位。\nvoid pio_restart_sm_mask(PIO pio, uint32_t mask);复位多个状态机。\nvoid pio_enable_sm_mask_in_sync(PIO pio, uint32_t mask);将多个状态机的时钟分频同步。\nuint8_t pio_sm_get_pc(PIO pio, uint sm);获取当前状态机执行的位置。\n\n3.状态机配置类\n\nvoid sm_config_set_out_pins(pio_sm_config *c, uint out_base, uint out_count);配置OUT引脚的范围，起始引脚和引脚数量。\nvoid sm_config_set_set_pins(pio_sm_config *c, uint set_base, uint set_count);配置SET引脚的范围，起始引脚和引脚数量。\nvoid sm_config_set_in_pins(pio_sm_config *c, uint in_base);配置IN引脚的起始引脚。\nvoid sm_config_set_sideset_pins(pio_sm_config *c, uint sideset_base);配置SIDE引脚的起始引脚。\nvoid sm_config_set_jmp_pin(pio_sm_config *c, uint pin);配置JMP引脚，JMP条件指令能够选择一个引脚的值作为条件，当引脚为高电平时，条件成立。\nvoid sm_config_set_clkdiv(pio_sm_config *c, float div);配置状态机的时钟分频。\nvoid sm_config_set_wrap(pio_sm_config *c, uint wrap_target, uint wrap);配置状态机的程序边界。\nvoid sm_config_set_in_shift(pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold);配置IN指令，shift_right为真时OSR为右移模式，autopush为真时，意味着OSR达到阈值后自动执行PUSH，从TXFIFO中取出数据到OSR中。push_threshold表示OSR的位宽。\nvoid sm_config_set_out_shift(pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold);配置OUT指令。\nvoid sm_config_set_fifo_join(pio_sm_config *c, enum pio_fifo_join join);配置FIFO的用法，有三种，0均匀分配，1将FIFO全部用于TXFIFO，2将FIFO全部用于RXFIFO。\n\n4.状态机IO配置\n\nvoid pio_gpio_init(PIO pio, uint pin);将IO口绑定到指定的PIO上。不允许多个PIO控制同一个引脚。\nvoid pio_sm_set_pins(PIO pio, uint sm, uint32_t pin_values);使用特定的状态机将PIO所属的IO全部设为指定值。\nvoid pio_sm_set_pins_with_mask(PIO pio, uint sm, uint32_t pin_values, uint32_t pin_mask);；使用掩码初始化IO。\nvoid pio_sm_set_pindirs_with_mask(PIO pio, uint sm, uint32_t pin_dirs, uint32_t pin_mask);设置IO的方向。\nvoid pio_sm_set_consecutive_pindirs(PIO pio, uint sm, uint pin_base, uint pin_count, bool is_out);设置一组连续IO的方向。\n\n5.数据交互类\n\nvoid pio_sm_clear_fifos(PIO pio, uint sm);清空状态机的FIFO。SDK14.0存在BUG。\nvoid pio_sm_drain_tx_fifo(PIO pio, uint sm);丢掉TXFIFO中的所有数据。\nvoid pio_sm_put(PIO pio, uint sm, uint32_t data);写入一个数据到TXFIFO中。如果FIFO满了则丢掉数据。\nvoid pio_sm_put_blocking(PIO pio, uint sm, uint32_t data);向TXFIFO中写入数据，如果TXFIFO已经满了则等待，直到能够写入数据。\nuint32_t pio_sm_get(PIO pio, uint sm);从RXFIFO中读取一个数据并返回。如果RXFIFO是空的，那么返回的值没有意义。\nuint32_t pio_sm_get_blocking(PIO pio, uint sm);从RXFIFO中读取数据，如果RXFIFO为空则等待，直到RXFIFO中存在新的数据。\nbool pio_sm_is_rx_fifo_full(PIO pio, uint sm);断言接收FIFO已满。\nbool pio_sm_is_rx_fifo_empty(PIO pio, uint sm);断言接收FIFO已空。\nuint pio_sm_get_rx_fifo_level(PIO pio, uint sm);读取RXFIFO中的数据个数，都是按字计算的。\nbool pio_sm_is_tx_fifo_full(PIO pio, uint sm);断言TXIFO已满。\nbool pio_sm_is_tx_fifo_empty(PIO pio, uint sm);断言TXFIFO为空。\nuint pio_sm_get_tx_fifo_level(PIO pio, uint sm);读取TXFIFO中的数据个数。\n\n6.中断管理类\n\nvoid pio_set_irq0_source_enabled(PIO pio, enum pio_interrupt_source source, bool enabled);设置IRQ0的中断事件源。\nvoid pio_set_irq1_source_enabled(PIO pio, enum pio_interrupt_source source, bool enabled);设置IRQ1的中断事件源。\nvoid pio_interrupt_clear(PIO pio, uint pio_interrupt_num);清除状态机内部的中断标志。\n除了C函数外，还需要Cmake来辅助实现编译PIO源文件。\n总结这只是我学习PIO的一个过程记录，到此已经能够基本读懂官方例程中的PIO例子。当然后面还需要自己大量的实践才能熟练掌握这个强大的PIO模块。\n\n示例代码解读一个简单的串口数据发送协议：\n.program uart_tx           ; 程序名称为uart_tx.side_set 1 opt            ; 代码中可以使用侧设置指令，控制的IO数量为1，侧设置指令是可选的。    pull       side 1 [7]  ; 从TXFIFO缓冲区中读取一个数据到OSR寄存器中，如果没有数据就等待。并将side引脚输出高电平。最少执行8个时钟周期。    set x, 7   side 0 [7]  ; 将7赋值到X寄存器。并将side引脚设为低电平。固定执行8个时钟周期。bitloop:                   ; 循环入口    out pins, 1            ; 从OSR寄存器中右移一位到输出OUT引脚上。单个周期。    jmp x-- bitloop   [6]  ; 如果X非0则跳转到bitloop。X=X-1。固定执行7个时钟周期。                           ; 到达程序边界后会自动跳回程序起始处。这是0周期执行的。\n\n与之配套的C相关函数如下：\nstatic inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint baud) &#123;    /* 设置引脚的初始电平状态和引脚方向 */    pio_sm_set_pins_with_mask(pio, sm, 1u &lt;&lt; pin_tx, 1u &lt;&lt; pin_tx);    pio_sm_set_pindirs_with_mask(pio, sm, 1u &lt;&lt; pin_tx, 1u &lt;&lt; pin_tx);    /* 初始化引脚 */    pio_gpio_init(pio, pin_tx);    /* 根据Pio源码的配置生成一个默认配置 */    pio_sm_config c = uart_tx_program_get_default_config(offset);    /* OSR寄存器采用右移输出，不会自动执行PUSH，数据位宽为32位 */    sm_config_set_out_shift(&amp;c, true, false, 32);    /* 绑定tx_pin到out输出引脚上 */    sm_config_set_out_pins(&amp;c, pin_tx, 1);    /* 绑定tx_pin到侧设置输出引脚上 */    sm_config_set_sideset_pins(&amp;c, pin_tx);    /* 将状态机的8个字FIFO全部分配给TXFIFO */    sm_config_set_fifo_join(&amp;c, PIO_FIFO_JOIN_TX);    /* 根据波特率计算时钟分频并设置状态机的分频系数，这里每输出1bit是8个周期 */    float div = (float)clock_get_hz(clk_sys) / (8 * baud);    sm_config_set_clkdiv(&amp;c, div);    /* 初始化状态机 */    pio_sm_init(pio, sm, offset, &amp;c);    /* 启动状态机 */    pio_sm_set_enabled(pio, sm, true);&#125;static inline void uart_tx_program_putc(PIO pio, uint sm, char c) &#123;    /* 阻塞的方式向状态机的TXFIFO中写入数据 */    pio_sm_put_blocking(pio, sm, (uint32_t)c);&#125;static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) &#123;    while (*s)        uart_tx_program_putc(pio, sm, *s++);&#125;\n\n下面是一个串口数据接收协议，并包含帧错误管理：\n.program uart_rxstart:    wait 0 pin 0        ; 等待第0个输入引脚变为低电平    set x, 7    [10]    ; 设置一个临时变量X=7bitloop:                ;     in pins, 1          ; 读取输入引脚的值，并通过右移保存到ISR寄存器    jmp x-- bitloop [6] ; 如果X非0则跳转到bitloop，X=X-1    jmp pin good_stop   ; 确认输入引脚为高电平，这里输入引脚也配置为了JMP引脚                        ; 如果为低电平则检查到帧错误    irq 4 rel           ; 设置一个IRQ标志表示发生了帧错误，rel将表示每个状态机设置的标志不同    wait 1 pin 0        ; 等待输入引脚恢复到高电平    jmp start           ; 返回到开始处重新接收数据good_stop:              ;     push                ; 接收到了正确的数据，将该数据推入到RXFIFO中\n\n"},{"title":"常见的字符串Hash算法","url":"/2021/04/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E7%AE%97%E6%B3%95/","content":"常见hash算法的碰撞概率统计\n\n\n\n10万\n50万\n100万\n500万\n1000万\n一亿\n1000万次的平均执行时间\n一亿次的平均执行时间\n一亿次的平均长度\n\n\n\nBKDRHash\n0.00002\n0.000112\n0.000251\n0.0011894\n0.0023321\n0.0229439\n0.0064134\n0.00968998\n9\n\n\nAPHash\n0\n0.000052\n0.000122\n0.0005794\n0.0011712\n0.01155826\n0.0061518\n0.01088634\n10\n\n\nDJBHash\n0.00001\n0.00011\n0.000204\n0.0011782\n0.0023154\n0.02294341\n0.0064836\n0.01098645\n9\n\n\nJSHash\n0\n0.000188\n0.00032\n0.001464\n0.0029323\n0.02876141\n0.0063464\n0.00904354\n9\n\n\nRSHash\n0.00001\n0.000122\n0.000245\n0.001154\n0.00233\n0.02290588\n0.0063627\n0.01168532\n9\n\n\nSDBMHash\n0.00002\n0.000132\n0.000235\n0.001175\n0.0023435\n0.02294529\n0.0064155\n0.01201398\n9\n\n\nPJWHash\n0.00312\n0.015032\n0.029957\n0.1386394\n0.251465\n0.83290663\n0.0067549\n0.00601705\n8\n\n\nELFHash\n0.00096\n0.005584\n0.011239\n0.0539746\n0.1028391\n0.52002744\n0.0060441\n0.00704438\n9\n\n\nMurmurHash\n0\n0\n0\n0\n0\n0\n0.0066868\n0.01194736\n19\n\n\nCityHash\n0\n0\n0\n0\n0\n0\n0.0066179\n0.01129171\n19\n\n\nFNVHash\n0.00005\n0.000186\n0.000349\n0.0016688\n0.0033469\n0.03279751\n0.0061614\n0.01018707\n9\n\n\ncrc64\n0\n0\n0\n0\n0\n0\n0.0064459\n0.01242473\n19\n\n\n1.BKDR hash function\nunsigned int bkdr_hash(const char *str)&#123;    unsigned int seed = 131; // the magic number, 31, 131, 1313, 13131, etc.. orz..    unsigned int hash = 0;    unsigned char *p = (unsigned char *)str;    while (*p)        hash = hash * seed + (*p++);    return hash;&#125;\n\n2.AP hash function\nunsigned int ap_hash(char *str)&#123;    unsigned int hash = 0;    int i;    for (i=0; *str; i++)        if ((i &amp; 1) == 0)            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));        else            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));    return (hash &amp; 0x7FFFFFFF);&#125;\n\n3.DJB hash function\nunsigned long hash_djbx33a(const char *str, size_t len)&#123;    unsigned long hash = 0U;    for(size_t i = 0;i &lt; len; ++i) &#123;        hash = hash * 33 + (unsigned long)str[i];        /* or, hash = ((hash &lt;&lt; 5) + hash) + (unsigned long)str[i];          * where, hash * 33 = ((hash &lt;&lt; 5) + hash)         */    &#125;    return hash;&#125;long long djb2(char s[])&#123;    long long hash = 5381; /* init value */    int i = 0;    while (s[i] != &#x27;\\0&#x27;)    &#123;        hash = ((hash &lt;&lt; 5) + hash) + s[i];        i++;    &#125;    return hash;&#125;\n\n4.JS hash function\nunsigned int js_hash(char*str)&#123;    unsigned int hash = 1315423911 ;    while(*str)    &#123;        hash ^=((hash &lt;&lt;5 ) + (*str++) + (hash &gt;&gt;2 ));    &#125;    return hash;&#125;\n\n5.RS hash function\nunsigned int RSHash( char * str)&#123;    unsigned int b = 378551;    unsigned int a = 63689;    unsigned int hash = 0;    while(*str)    &#123;        hash = hash * a + (*str++);        a *= b;    &#125;    return (hash &amp; 0x7FFFFFFF);&#125;\n\n6.SDBM hash function\nstatic unsigned long sdbm(unsigned char *str)&#123;    unsigned long hash = 0;    int c;    while (c = *str++)        hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;    return hash;&#125;\nsdbm_hash.c\n/* Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//* * sdbm - ndbm work-alike hashed database library * based on Per-Aake Larson&#x27;s Dynamic Hashing algorithms. BIT 18 (1978). * author: oz@nexus.yorku.ca * status: ex-public domain. keep it that way. * * hashing routine */#include &quot;apr_sdbm.h&quot;#include &quot;sdbm_private.h&quot;/* * polynomial conversion ignoring overflows * [this seems to work remarkably well, in fact better * then the ndbm hash function. Replace at your own risk] * use: 65599  nice. *      65587  even better.  */long sdbm_hash(const char *str, int len)&#123;    register unsigned long n = 0;#define DUFF/* go ahead and use the loop-unrolled version */#ifdef DUFF#define HASHCn = *str++ + 65599 * n    if (len &gt; 0) &#123;        register int loop = (len + 8 - 1) &gt;&gt; 3;        switch(len &amp; (8 - 1)) &#123;        case 0:do &#123;                HASHC;case 7:HASHC;        case 6:HASHC; case 5:HASHC;        case 4:HASHC; case 3:HASHC;        case 2:HASHC;case 1:HASHC;            &#125; while (--loop);        &#125;    &#125;#else    while (len--)        n = *str++ + 65599 * n;#endif    return n;&#125;\n\n7.PJWHash hash function\n/*  * A generic hash function HashPJW better than ElfHash point,  * but depending on the context. */#include &lt;limits.h&gt;#define BITS_IN_int     ( sizeof(int) * CHAR_BIT )#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))#define HIGH_BITS       ( ~((unsigned int)(~0) &gt;&gt; ONE_EIGHTH ))unsigned int HashPJW ( const char * datum )&#123;    unsigned int hash_value, i;    for ( hash_value = 0; *datum; ++datum )    &#123;        hash_value = ( hash_value &lt;&lt; ONE_EIGHTH ) + *datum;        if (( i = hash_value &amp; HIGH_BITS ) != 0 )            hash_value = ( hash_value ^ ( i &gt;&gt; THREE_QUARTERS )) &amp; ~HIGH_BITS;    &#125;    return ( hash_value );&#125;\n\n8.ELFHash hash function\n/* *    This function hash the input string &#x27;name&#x27; using the ELF hash *    function for strings. */static unsigned int hash(char* name)&#123;    unsigned int h = 0;    unsigned int g;    while(*name) &#123;        h = (h&lt;&lt;4) + *name++;        if ((g = (h &amp; 0xf0000000)))            h ^= g&gt;&gt;24;        h &amp;=~ g;    &#125;    return h;&#125;\n\n9.Murmur hash function\nuint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) &#123;    uint32_t h = seed;    if (len &gt; 3) &#123;        const uint32_t* key_x4 = (const uint32_t*) key;        size_t i = len &gt;&gt; 2;        do &#123;            uint32_t k = *key_x4++;            k *= 0xcc9e2d51;            k = (k &lt;&lt; 15) | (k &gt;&gt; 17);            k *= 0x1b873593;            h ^= k;            h = (h &lt;&lt; 13) | (h &gt;&gt; 19);            h = (h * 5) + 0xe6546b64;        &#125; while (--i);        key = (const uint8_t*) key_x4;    &#125;    if (len &amp; 3) &#123;        size_t i = len &amp; 3;        uint32_t k = 0;        key = &amp;key[i - 1];        do &#123;        k &lt;&lt;= 8;        k |= *key--;        &#125; while (--i);        k *= 0xcc9e2d51;        k = (k &lt;&lt; 15) | (k &gt;&gt; 17);        k *= 0x1b873593;        h ^= k;    &#125;    h ^= len;    h ^= h &gt;&gt; 16;    h *= 0x85ebca6b;    h ^= h &gt;&gt; 13;    h *= 0xc2b2ae35;    h ^= h &gt;&gt; 16;    return h;&#125;\n\n10.City hash function\n/*  * CityHash 的主要优点是大部分步骤包含了至少两步独立的数学运算 * 代码较同类流行算法复杂 */\n\n11.FNVHashFNV-1 hash\nhash = FNV_offset_basisfor each byte_of_data to be hashed    hash = hash × FNV_prime    hash = hash XOR byte_of_datareturn hash\nFNV-1a hash\nhash = FNV_offset_basisfor each byte_of_data to be hashed    hash = hash XOR byte_of_data    hash = hash × FNV_primereturn hash\n\n其它的比较\n\n\nHash函数\n数据1\n数据2\n数据3\n数据4\n数据1得分\n数据2得分\n数据3得分\n数据4得分\n平均分\n\n\n\nBKDRHash\n2\n0\n4774\n481\n96.55\n100\n90.95\n82.05\n92.64\n\n\nAPHash\n2\n3\n4754\n493\n96.55\n88.46\n100\n51.28\n86.28\n\n\nDJBHash\n2\n2\n4975\n474\n96.55\n92.31\n0\n100\n83.43\n\n\nJSHash\n1\n4\n4761\n506\n100\n84.62\n96.83\n17.95\n81.94\n\n\nRSHash\n1\n0\n4861\n505\n100\n100\n51.58\n20.51\n75.96\n\n\nSDBMHash\n3\n2\n4849\n504\n93.1\n92.31\n57.01\n23.08\n72.41\n\n\nPJWHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\nELFHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\n其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。\n经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。\n在信息修竞赛中，要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的。\n"},{"title":"我们需要谨慎操作Cache","url":"/2023/08/30/%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E%E6%93%8D%E4%BD%9CCache/","content":"\n成都有疫情有半个月了，在家办公的日子总是很枯燥的，很多的工作无法正常开展。今天有时间，我尝试对Ymodem的传输效率进行优化并完善其中的一些细节实现，本来一个简单的优化工作却牵出一个严重的问题，并最终折腾了一天才解决。这是一个并不典型的内存溢出问题，这种溢出的方式在以前的工作中完全没有遇到过。记录今天排查问题的过程以提醒自己，不严谨的Cache操作会导致内存溢出。\n\n今天一开始在修改并测试Ymodem相关的一些功能，主要是优化了内部数据封装逻辑，并改善数据传输速度。测试发现向单片机发送文件，速度有较大的改善。为了确认数据传输的正确性，使用Ymodem将单片机内的文件读取出来。\n惊！发送和接收到的文件数据不一致。\n查！🧐\n更换多个文件后测试发现，问题能够稳定复现，且每次从单片机内读取出的文件数据都不一样。是Ymodem在单片机内的发送有问题还是接收有问题呢？我决定使用系统内的FTP文件服务来协助排查，通过FTP能够非常方便的上传和下载文件。\n惊！😱\n通过FTP上传和下载的文件依旧存在问题。通过两种文件传输方式，每次文件都能稳定的传输，传输过程中没有出现任何问题，连Ymodem都没有发出NAK的消息，而且文件大小也没有问题，就唯独内容乱码，我是根据7zip的CRC校验来确认的。这就把问题牵扯到Ymodem功能以外的地方了，很显然该问题不是Ymodem直接导致的。\n到这里我认为这个问题比较严重了，这个工程代码中文件系统相关的代码一直运行都比较稳定。\n开始排查问题！\n我首先构造了一个内容清晰的文本文件abc.txt，约1700字节。使用FTP先上传到系统中，通过串口的命令行，使用指令查看文件内容，cat abc.txt。发现偶尔存在几行文本的乱码。但是更严重的是我发现连续发送cat abc.txt系统就崩溃了，最后一次的数据也没有显示出来。\n我到这里就基本上确认文件系统存在问题，且这个问题大概率是和文件传输不一致相关的问题。有了这个更容易复现的bug，我决定先从这里入手，相信这个问题很快就能解决。\n但实际上我真的低估这个问题了，我几乎花了一天的时间来排查这个问题，最终仅仅依靠一行代码解决。这充分诠释了一个真理，高端的BUG往往只需要最朴素的方式进行处理。\n下面我回顾一下我是如何一步一步排查问题的。\n问题的入口点肯定是cat指令，通过分析代码，定位到如下的逻辑：\nuint8_t tmp[4];file_h = vfopen(path, &quot;r&quot;);if(file_h)&#123;    while(1)&#123;        len = vfread(file_h, tmp, 4);        if(len &gt; 0)&#123;            output(tmp, len);        &#125;else&#123;            break;        &#125;    &#125;    vfclose(file_h);&#125;\n\n这段代码逻辑非常简单，打开文件，以4字节长度的方式依次读取数据并将它显示出来，直到全部数据读取完成。\n看到这里并没有什么好的想法，我决定打开调试器仿真。仿真起来后，发现问题点好像不是很稳定，偶尔会进入到hardfault，有时会陷入死循环。\n通过检查hardfault的触发原因，应该是访问了不该访问的地址，这个地址并没有什么意义，但是检查触发时的PC指针，基本能够定位到malloc模块中。\n进一步来看，前面说的还会进入死循环，这个循环也是在malloc模块中，死循环的原因是堆内存的空闲链表中出现了异常的值，导致链表出现问题。具体来说时malloc在分配内存时需要进行链表的操作，查询链表时无法正常触发结束条件导致进入了死循环。\n将问题定位到这里已经废了很大劲了，但是依然没有办法确定导致问题的原因。\n通过malloc的问题点进行栈回溯，确认是文件系统在申请内存，终于和文件系统关联上了。到此问题依然很迷茫，因为内存导致的问题通常不会花费我那么多时间。\n这个内存破坏分子到底是谁呢？？？\n我开始尝试打开内存的分配日志，保守起见，我先使用一种简单点的日志模型，它不会破坏现有的内存分配结构。\n通过日志我基本确认了出问题点前后所发送的事情，也就是在file_h &#x3D; vfopen(path, “r”);会触发两次内存申请的操作。在多次执行cat abc.txt时，可能是前面内存分配的数据结构出现严重问题，导致后面分配内存就会出错。\n我开始怀疑是栈溢出导致内存链表出现问题，但是通过内存的分配日志，逐渐将这个想法排除，因为所有的任务栈都不在这段内存附近。\n逐渐陷入僵局，居然连内存出现破坏的点都没有捕获到！\n我决定使用更高级的内存日志来分析问题，但这可能会导致问题不复现，因为这种内存日志分析方法会在用户申请的内存前后额外再申请一部分空间，用来检测内存边界上是否出现破坏。我一开始担心内存布局出现变化会导致问题不复现，但是测试后发现这种方法是可行的，我终于定位到内存破坏的点了。也就是vfopen返回的文件句柄，这是一个动态申请的内存，大小为4184字节。通过内存日志分析，该段内存在释放时检查发现内存末尾出现数据溢出的情况。\n通过添加多个内存检查点，基本确认了内存破坏的代码段，也就是在vfread函数中，但是我任然不是很确定。毕竟这是一个多任务的系统。\n我决定使用内存断点来排查问题，通常内存断点都是能够很轻松的解决这类内存溢出的问题，在内存溢出位置设置监视断点，很容易查到是什么代码在修改内存数据。但是这次内存断点并没有帮我解决问题，内存断点看起来并没有起作用。我没有在这里纠缠太久，我不想去查内存断点为什么没有生效。因为今天大部分时间都在盯着这个问题，精神也有点儿恍惚了。\n为什么读取文件数据会将句柄外的数据破坏了呢？我发现句柄结构体中末尾是一个4096字节的数据缓存，是在读取数据时导致内存溢出吗？\n我检查了许久文件系统中文件读取相关的代码，并没有可疑的地方。\n我开始尝试在存储介质上寻找原因，存储介质是一块8M的flash，spi总线访问。\n前面都没有提到这个存储介质，因为我能够确认这个存储介质是完好的，它能够稳定的存储数据，并可靠的读取出来。\n我通过日志分析从falsh读取数据时将数据填充到那些地址空间下。flash读取出的数据并没有填充到那个被破坏的地址下，这也就排除了DMA的问题。\n本来到此我决定放过存储介质上的驱动代码，但是我还是做了一些尝试。我在flash驱动的读取函数入口处先检查一遍那个内存边界是否破坏，在出口再检查一遍内存是否破坏。\n喜！🎉🎉🎉\n居然问题就在这个驱动函数中。通过逐行分析，最终确认问题点。\nflash读取函数大致是这样的：\n\n1.构造数据读取请求；\n2.发送数据读取请求；\n3.通过DMA将数据直接传输到内存中；\n4.将该段内存相对应的Cache清除；\n\n就是第4个代码存在问题，在存在Cache的系统中，使用DMA传输数据后，为了后面CPU从物理地址中取得有效数据，需要将Cache中的数据清除掉，这是非常必要且正常的逻辑(除非内存不具备Cache特性)。\n但是这里忽略了一个点，清除Cache的操作并不是想清除那段内存就清除那段内存，它是需要字节对齐的，32字节对齐，在这个系统中Cache的操作接口不是原生的CMSIS接口，而是包装过的，它为了保证数据操作可靠，它会自动对齐到32字节的边界上，首尾均是这样。如果操作的内存地址不是32字节对齐时，会导致在清除Cache时错误的将期望内存外的数据都清除掉了，而这部分数据可能还没有及时的写入到物理内存中。这类似与一种数据溢出的效果，但是又与一般的内存溢出有很大的区别。\n\n最终，我尝试了一个简单的解决办法，在触发DMA数据传输前，将Cache中的数据先同步到物理内存中，这样问题就解决了。只需要一行代码，完美解决了cat指令导致系统出错的问题，连同最开始文件传输数据异常都一并解决了。到这里也解释了为什么内存断点为什么没有生效，由Cache引入的内存问题使用内存断点的排查手段不一定有效。再说一句，通过DMA写入的内存数据，内存断点也是无法捕获的。\n这个问题以前没有暴露出来肯能是因为以前的那个内存地址正好是32字节对齐的。检查GIT提交记录，该问题已经暴露很长时间了。\n通过这个问题，反应了滥用SCB_InvalidateDCache_by_Addr()接口导致数据溢出的问题。后面需要再次排查系统中其它Cache操作，看看是否存在类似问题。\n"},{"title":"我们需要非常谨慎的使用Cache","url":"/2024/07/11/%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%9D%9E%E5%B8%B8%E8%B0%A8%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8Cache/","content":"最近在学习的过程中遇到一个软件上的问题，该问题非常折磨人。\n在一个嵌入式软件系统中使用WiFi网络并通过FTP服务读取设备内存储在SD上的文件，就是这样一个看起来非常简单的逻辑，最近在测试过程中出现了一点问题。\n发现小概率情况下文件传输会导致系统崩溃，崩溃的问题点也是非常奇怪的，会爆发出很多稀奇古怪的问题(包括但不限于malloc返回null、内存申请卡死、网络协议栈数据异常等等)，且该故障似乎很难在调试模式下复现。\n该故障仅在上述条件下会触发，其它情况下没有复现：\n\n通过FTP读取内存中的文件(ramfs)不会导致系统崩溃\n通过USB连接网络，仍然通FTP传输SD卡上的文件，系统不会崩溃\n在系统内通过文件拷贝方法在SD和nand直接传输文件，系统不会崩溃\n关闭系统D-Cache，使用wifi通过FTP读取SD卡的文件，系统不会崩溃\n\n分析以上情况，好像很难确定问题点。但该故障大概率是与Cache相关的，因为这可以解释为什么在调试模式下问题不那么容易复现。\n整个系统相当复杂，底层磁盘驱动、文件系统、文件系统抽象层、网络协议栈、FTP服务、WIFI驱动、操作系统等等。我花费了相当多的额时间去梳理WIFI驱动代码，这是我最不熟悉的一部分，但是WIIF驱动看来没有明显的问题。\n其中多个与硬件相关的组件均会使用到DMA和Dcache的操作，好像没有办法把问题聚焦到一个点上。\n系统出现故障时的一种常见现象是内存分配器出现故障，包括无法分配内存(但显示存在剩余内存)、无法释放内存等。\n我设计了一种检查机制，即在内存分配和释放的时候检查一下内存分配器的链表释放正常。该方法确实有用，它能够迅速的捕获系统最近出现故障的时刻，这使得复现和分析问题非常有帮助。\nvTaskSuspendAll();&#123;    int tot_len = 0;    BlockLink_t * pxBlock;    pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );    while( pxBlock != pxEnd )&#123;        tot_len += pxBlock-&gt;xBlockSize;        pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock-&gt;pxNextFreeBlock );    &#125;    configASSERT( tot_len == xFreeBytesRemaining );&#125;( void ) xTaskResumeAll();\n当发现系统内剩余内存和链表中描述的剩余内存不一致后立即中断系统运行。\n配合内存分配日志和Cache操作日志，确定是SD卡驱动的一次INVALID DCACHE操作后内存分配器就出现故障了。\nint sdmmc_read(void *buf, int len)&#123;    // 1:    CLEAN_DCACHE(buf, len);    // 2:    SD_ReadBlocks_DMA(buf, len);    // 3:    INVALID_DCACHE(buf, len);    return 0;&#125;\n\n解释一下这段代码的含义。第3行代码，当使用DMA读取数据后，需要将缓存中的数据清除掉，这是为了后续CPU读取数据时可以读取到物理内存中的数据，而非Cache中的数据。第1行代码，这段代码有点不太好解释，当buf和Cache边界未对齐时，后续的第三步可能会使得buf边界外到Cache边界中的数据被清除掉，这就使得系统内的数据完整性无法得到保证，所以设计了第1步的代码来将附近的数据全部同步到内存中。\n以上的设计在我以前的文章中提到过，可以去翻看一下。\n这样的设计在单线程环境下是没有问题的，但是在多线程下就会有点问题，因为第2行代码是一个耗时操作，这就使得已经被同步到内存中的数据可能又被另一个线程取出放入Cache，而后续的第3行代码还不知道这样的情况，直接将缓存清除掉了，导致系统内部分数据丢失，进而导致出现系统崩溃的情况。\n一个安全的做法是为DMA读取操作单独分配一块与Cache边界对齐的一块缓存，用它作为数据传输的桥梁，由DMA读取完成后再由CPU将数据搬运到其它内存空间下。但是这样有一些缺陷，即无法连续读取多块数据，这会导致SDMMC出现严重的性能瓶颈，一般SDMMC连续读取多块扇区有更明显的速度优势。\n所以需要设计另外一种方法来安全的清理Cache，且必须考虑线程安全问题。\n#define CACHE_SIZE (32)void InvalidDCache(void *addr, int len)&#123;    __disable_irq();    static char cache_head_buf[CACHE_SIZE - 1];    static char cache_end_buf[CACHE_SIZE - 1];    uint32_t cache_head_addr;    uint32_t cache_head_len;    uint32_t cache_end_addr;    uint32_t cache_end_len;    cache_head_addr = ((uint32_t)(addr) &amp; ~(CACHE_SIZE - 1));    cache_head_len = ((uint32_t)(addr) &amp; (CACHE_SIZE - 1));    cache_end_addr = ((uint32_t)(addr) + len);    cache_end_len = CACHE_SIZE - (cache_end_addr &amp; (CACHE_SIZE - 1));    if(cache_end_len == CACHE_SIZE)&#123;        cache_end_len = 0;    &#125;    if(cache_head_len &gt; 0)&#123;        memcpy(cache_head_buf, cache_head_addr, cache_head_len);    &#125;    if(cache_end_len &gt; 0)&#123;        memcpy(cache_end_buf, cache_end_addr, cache_end_len);    &#125;    SCB_InvalidateDCache_by_Addr(addr, len);    if(cache_head_len &gt; 0)&#123;        memcpy(cache_head_addr, cache_head_buf, cache_head_len);    &#125;    if(cache_end_len &gt; 0)&#123;        memcpy(cache_end_addr, cache_end_buf, cache_end_len);    &#125;    __enable_irq();&#125;\n这段代码可以解决缓存Invalidate带来的风险，它将边界上的内存主动保存了一遍。\n但还有一个问题似乎不可忽略，那就是缓存自动写入的情况，当切换线程上下文后执行了其它的内存密集操作，当缓存不足时，可能导致原先的缓存被自动写入到内存中，尤其是边界上的，这仍然可能出现数据失效的问题。\n最终，我选择牺牲性能来保证可靠性，通过一个中间缓存来读取数据，确保DMA和Cache的操作都是安全可靠的。当然在实现过程中可以通过检查输入的内存指针是否与Cache边界对齐，如果是对齐的情况，那么就可以绕过中间缓存直接读取数据。\nCache的问题总是那么有意思。最好的情况还是应该在软件设计时就能够保证数据边界对齐，或者牺牲一定的性能来保证数据的可靠性和系统安全性。\nPS：为什么wifi传输数据异常而USB网卡传输数据正常呢？因为USB网卡驱动内部没有频繁的内存申请操作，而wifi设备驱动中有频繁的内存申请操作。出现Cache问题的那块内存正好是从堆内获取的，且故障边界正好命中内存管理器的空闲链表数据项。所以频繁的内存申请操作会导致该问题更容易复现。\n"},{"title":"更优雅的使用Protothreads协程框架","url":"/2023/08/30/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Protothreads%E5%8D%8F%E7%A8%8B%E6%A1%86%E6%9E%B6/","content":"PT协程框架PT(Protothreads)是一个轻量级的多任务框架，区别于一般基于栈的RTOS，它实现多任务的基本原理是通过语句间的任意跳转来实现任务切换，所以实现多任务的开销比较小。\n我们看一段示例代码来了解其用法。\n/** * This is a very small example that shows how to use * protothreads. The program consists of two protothreads that wait * for each other to toggle a variable. *//* We must always include pt.h in our protothreads code. */#include &quot;pt.h&quot;#include &lt;stdio.h&gt; /* For printf(). *//* Two flags that the two protothread functions use. */static int protothread1_flag, protothread2_flag;/** * The first protothread function. A protothread function must always * return an integer, but must never explicitly return - returning is * performed inside the protothread statements. * * The protothread function is driven by the main loop further down in * the code. */static intprotothread1(struct pt *pt)&#123;  /* A protothread function must begin with PT_BEGIN() which takes a     pointer to a struct pt. */  PT_BEGIN(pt);  /* We loop forever here. */  while(1) &#123;    /* Wait until the other protothread has set its flag. */    PT_WAIT_UNTIL(pt, protothread2_flag != 0);    printf(&quot;Protothread 1 running\\n&quot;);    /* We then reset the other protothread&#x27;s flag, and set our own       flag so that the other protothread can run. */    protothread2_flag = 0;    protothread1_flag = 1;    /* And we loop. */  &#125;  /* All protothread functions must end with PT_END() which takes a     pointer to a struct pt. */  PT_END(pt);&#125;/** * The second protothread function. This is almost the same as the * first one. */static intprotothread2(struct pt *pt)&#123;  PT_BEGIN(pt);  while(1) &#123;    /* Let the other protothread run. */    protothread2_flag = 1;    /* Wait until the other protothread has set its flag. */    PT_WAIT_UNTIL(pt, protothread1_flag != 0);    printf(&quot;Protothread 2 running\\n&quot;);        /* We then reset the other protothread&#x27;s flag. */    protothread1_flag = 0;    /* And we loop. */  &#125;  PT_END(pt);&#125;/** * Finally, we have the main loop. Here is where the protothreads are * initialized and scheduled. First, however, we define the * protothread state variables pt1 and pt2, which hold the state of * the two protothreads. */static struct pt pt1, pt2;intmain(void)&#123;  /* Initialize the protothread state variables with PT_INIT(). */  PT_INIT(&amp;pt1);  PT_INIT(&amp;pt2);    /*   * Then we schedule the two protothreads by repeatedly calling their   * protothread functions and passing a pointer to the protothread   * state variables as arguments.   */  while(1) &#123;    protothread1(&amp;pt1);    protothread2(&amp;pt2);  &#125;&#125;\n一个任务就是一个单独的函数和一个记录任务状态的句柄。通过在一个循环中一直执行所有任务相关的函数就能够实现多任务的效果，因为它是非抢占式的，如果某个任务函数不需要执行的时机了，那么它就主动退出该函数并将执行时机转移到下一个任务函数。由于pt句柄记录了函数内部执行的位置，所以下次进入任务函数能够恢复上一次执行的位置。\n相比于传统的RTOS，PT协程的用法不够灵活，任务不能动态的创建，任务的调度是提前分配好的，如果需要实时的创建或者删除一个任务，上面的这种写法就不是很方便。\n基于PT实现一套更优雅的任务框架主要是需要解决PT协程框架不能动态创建任务的问题，解决的办法是使用链表将所有的任务管理起来，将创建好的任务就放入到链表中，如果任务结束或删除就将其从链表中删除。实现一个调度器自动调度并运行链表中的所有任务。为了完全保留原始PT的用法，这里只新增任务创建和调度的实现，其余用法保持不变。\n这里链表的引用参考Linux内核链表，其实现和使用都很简单。\n首先需要定义一个全局的链表，用于管理所有的任务。\n// pt_os.c#include &quot;list.h&quot;LIST_HEAD(pt_pool);\n\n剩余的内容就只需要在头文件中实现即可。\n// pt_os.h#ifndef _PT_OS_H#define _PT_OS_H#include &quot;pt.h&quot;#include &quot;list.h&quot;typedef struct&#123;    struct list_node list;    PT_THREAD((*task)(struct pt *pt));    struct pt pt;&#125; pt_item_t;extern struct list_node pt_pool;/** * Run pt os. * OS_SCHEDULE() executes an infinite loop. *  * Example usage: * @code&#123;c&#125; * int main(void)&#123; *     //... *     for(;;)&#123; *         OS_SCHEDULE(); *     &#125; *     return 0; * &#125; * @endcode */#define OS_SCHEDULE()                                           \\    do                                                          \\    &#123;                                                           \\        pt_item_t *pt_item;                                     \\        list_for_each_entry(&amp;pt_pool, pt_item, pt_item_t, list) \\        &#123;                                                       \\            if (pt_item-&gt;task(&amp;(pt_item-&gt;pt)) &gt;= PT_EXITED)     \\            &#123;                                                   \\                list_delete(&amp;(pt_item-&gt;list)); break;           \\            &#125;                                                   \\        &#125;                                                       \\    &#125; while (0)/**  * Create a new pt task. *  * Example usage: * @code&#123;c&#125; * PT_THREAD(iwdg_task(struct pt *pt))&#123; *      static struct timer periodic_timer; *      PT_BEGIN(pt); *      timer_set(&amp;periodic_timer, 100); *      while(1)&#123; *          HAL_IWDG_Refresh(&amp;hiwdg); *          PT_WAIT_UNTIL(pt, timer_expired(&amp;periodic_timer)); *          timer_reset(&amp;periodic_timer); *      &#125; *      PT_END(pt); * &#125; *  * int main(void)&#123; *     OS_TASK_RUN(iwdg_task); *     //... *     for(;;)&#123; *         OS_SCHEDULE(); *     &#125; *     return 0; * &#125; * @endcode */#define OS_TASK_RUN(func)                            \\    do                                               \\    &#123;                                                \\        static pt_item_t pt_##_func;                 \\        pt_##_func.task = func;                      \\        PT_INIT(&amp;(pt_##_func.pt));                   \\        list_add_head(&amp;pt_pool, &amp;(pt_##_func.list)); \\    &#125; while (0)#endif\n\n这里定义任务结构pt_item_t，相比与原生PT，每个任务会多占用12字节的RAM，此外就没有多余的开销了。使用OS_TASK_RUN()方法可以创建一个新的任务，它可以将PT任务添加到任务列表中。OS_SCHEDULE()方法用于调度所有的PT任务，它需要放入到一个循环中一直执行，当某个任务执行退出后可以将它从任务列表中自动删除。\n这里存在一些缺陷，任务的入口不能传递参数，如果一定要实现这个功能那也是很容易的，对pt_item_t中的任务签名做调整即可。 \n通过这段短小的代码(大约20行)就拓展了原生PT的实现，达到任务的自动调度，任务的动态创建和删除，这样在资源受限的单片机内能够实现更加灵活的异步编程。\n"},{"title":"移植MicroPython时的一些思考","url":"/2024/11/06/%E7%A7%BB%E6%A4%8DMicroPython%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","content":"今年4月份尝试手动将MicroPython移植到自己的平台上，在移植的过程中发现MicroPython的内部模块有大量的底层依赖，这使得移植工作视乎有点庞大。当时基本上仅完成了BASIC_FEATURES等级的移植，相当于完成了最小系统，在REPL可以良好运行，但是缺少了大量的基础库，使得它几乎没有太大的实用性。\n最近我又想起了这个以前遗留的工作，我决定将它完善一些，尽量达到EXTRA_FEATURES的移植等级，这意味着需要大量的移植工作，主要是多线程环境、文件系统、网络协议栈、芯片级外设等内容的移植。\n大部分移植工作都可以参考官方的ports例子做参考，但在文件系统、网络、多线程上却只能自己努力了，因为这部分内容是我的系统上特有的。这里说明一点，我将Micropython移植到我的系统中是作为一个单独的模块运行，可随时停止和重启，且它作为独立的线程运行不会对其它线程产生任何影响。\n首先网络部分的内容，由于我的本机已经运行了网络协议栈，所以在python中不单独运行协议栈了，通过NIC提供一套socket的控制接口到MicroPython内部就行了，这部分MicroPython考虑的比较周到，可以通过宏定义MICROPY_PORT_NETWORK_INTERFACES来导入自己的socket控制器。设计完自己的socket控制器需要通过mod_network_register_nic()注册到MicroPython内部socket模块。\n文件系统要稍微麻烦一些，无法直接接入自己的文件系统，最理想的办法是重构MBFS模块，MBFS文件系统本身作为一个待导入的文件系统模块，对它的修改不会对MicroPython的代码产生太多侵略性的修改。文件系统的接口仍然由系统平台提供，python直接向系统申请文件资源。\n这里说一个大坑，困扰我许久，在自定义构造文件对象是需要附带finaliser标记，否则GC回收对象时无法关闭系统中的文件。由于这个MicroPython作为一个子模块运行，它退出后系统还要继续运行，这使得它占用的文件未关闭且部分系统级的内存都没有得到释放，这会导致相当严重的问题。\n移植文件系统时需要注意到上下文管理器协议的存在，当执行__exit__()方法后文件已经关闭，但是后续在文件对象销毁时会再次执行__del__()方法来关闭文件，在__exit__()方法中关闭也许不是必要的，但是参考源码中实现的FAT、LFS等文件系统来看，它们的__del__()方法都是执行文件关闭的动作。所以这意味这在设计这部分内容时需要特别注意文件关闭多次执行的问题，需要正确处理文件的打开状态以确保文件不会被执行重复关闭的动作。\n对多线程模块的支持仍然花费了相当多的调试精力，主要是在GC机制上费了些功夫。MicroPython的GC仅使用标记清除算法，没有引用计数，所以在标记阶段需要特别注意。\nGC机制通过搜索处理器栈上的实例对象来进行标记有效内存区域。对于当前线程来说，除了栈区域，还有CPU中的寄存器也需要进行搜索。当搜索到gc内存对象后就进行标记处理。对于多线程来说，每次标记阶段都需要检查所有线程的栈空间，其它线程的寄存器数据已经压入栈了，所以只需要考虑栈空间即可。获取线程的栈指针地址需要依赖于多线程的底层实现，我这里的多线程是由FreeRTOS提供的，所以通过线程句柄可以访问到其它线程的实时栈指针。在GC标记时需要充分遍历所有线程的栈空间，确保所有的root节点都被正确标记，否则会导致严重的运行时问题。每次执行GC时所有未被标记的内存区域都将被回收，所以不要将一个有用的GC内存放到栈以外的区域，如果有必要保存一些全局gc内存变量，最好是将它放到mp_state_ctx内部进行自动管理，或者是在编写gc_collect()时特殊处理。\nMicroPython的GC在回收内存时，如果内存被标记了finaliser，则GC会自动调用对象的析构函数来处理对象。如果没有finaliser，即使对象含有析构函数，在内存回收时析构函数也不会执行。在MicroPython中__del__()方法没有特殊地位，它不会在对象删除时自动执行，这是和CPython的一个明显的区别点。在实现内部模块时需要注意一点，主动执行gc_free()也不会执行finaliser的析构函数，这可能导致一些资源泄露的问题，在实现内部模块时需要特别注意。所以对于内存的管理来说，申请的内存最好不要显式的释放，可以放心的交给GC去处理。\n外设的移植完成了Pin模块的部分内容，可以实现GPIO的正常读写，中断的支持还未完成。\n到目前为止，除外设功能外已经完成了EXTRA_FEATURES的所有功能，编写了一些程序来运行，基本上符合预期，执行效率上明显慢于C代码。受限与运行时上有限的heap内存空间，多创建一些对象后就会导致内存溢出的问题。通过python间接调用系统层面的文件io和hash模块来实现一个文件md5计算器。计算一个2兆字节的文件大约耗时350ms，而直接在系统层面通过C计算同样的文件md5值，耗时约75ms。还测试了一个大数阶乘计算程序，计算10000的阶乘耗时约2.4s，计算30000的阶乘耗时约22秒，MicroPython内置了大整数计算也是它的优势。\n"},{"title":"第一次向FreeRTOS内核提交代码","url":"/2024/06/20/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%91FreeRTOS%E5%86%85%E6%A0%B8%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/","content":"背景前段时间我在测试wolfSSL中RSA相关代码的时候，发现在进行加密、解密、key生成过程中存在一些性能问题。在分析问题的过程中，发现算法对堆内存的申请非常频繁。生成一对2048长度的公钥和私钥，会进行10万次以上的内存申请。我为了跟踪函数在执行过程中的内存具体使用情况，决定设计一套堆内存跟踪机制来评估函数的内存使用情况。\n在设计内存跟踪机制的过程中，我发现了一个FreeRTOS内核中的Bug，最终该Bug由我亲自修复，相关修复代码已经合并入内核代码主线。\n设计一个内存跟踪机制原本想设计一个不依赖堆实现的的内存跟踪机制，但我发现各种堆内存的实现可能都存在一些差别，尤其是不太好分析内存释放时相关内存块的大小(C库的实现就是这样)。妥协后我决定基于目前的情况，配合FreeRTOS的heap实现来设计相关的内存跟踪机制。\nFreeRTOS预留了traceMALLOC(pv, size)和traceFREE(pv, size)两个跟踪宏，用于指示内存申请和释放。它会指示内存指针和内存的大小。\n基于这两个宏，我就能记录内存的分配次数、释放次数、内存的实时用量、内存的最大用量、内存泄露等。再通过一个简单的异或操作，可用非常方便的检测内存的申请和是否是否成对。\n整个跟踪机制的代码如下：\n// heapt.h#ifndef _HEAPT_H#define _HEAPT_H#include &lt;stdint.h&gt;typedef struct &#123;    uint32_t trace_enable;    uint32_t malloc_count;    uint32_t free_count;    uint32_t malloc_used_count;    uint32_t malloc_max_count;    uint32_t memory_used;    uint32_t memory_max_used;    uint32_t ptr_xor;    uint32_t malloc_faild;&#125; heapt_info_t;void heapt_init(void);void heapt_deinit(void);const heapt_info_t *heapt_get_info(void);// FreeRTOS hookvoid heapt_trace_malloc(void *ptr, uint32_t size);void heapt_trace_free(void *ptr, uint32_t size);#endif\n#include &quot;heapt.h&quot;#include &lt;string.h&gt;static heapt_info_t heapt_info;void heapt_init(void)&#123;    memset(&amp;heapt_info, 0, sizeof(heapt_info));    heapt_info.trace_enable = 1;&#125;void heapt_deinit(void)&#123;    memset(&amp;heapt_info, 0, sizeof(heapt_info));&#125;const heapt_info_t *heapt_get_info(void)&#123;    return &amp;heapt_info;&#125;void heapt_trace_malloc(void *ptr, uint32_t size)&#123;    if(heapt_info.trace_enable == 0)&#123;        return ;    &#125;    if(ptr == NULL)&#123;        heapt_info.malloc_faild++;        return ;    &#125;    heapt_info.malloc_count++;    heapt_info.malloc_used_count++;    heapt_info.memory_used += size;    if(heapt_info.malloc_used_count &gt; heapt_info.malloc_max_count)&#123;        heapt_info.malloc_max_count = heapt_info.malloc_used_count;    &#125;    if(heapt_info.memory_used &gt; heapt_info.memory_max_used)&#123;        heapt_info.memory_max_used = heapt_info.memory_used;    &#125;    heapt_info.ptr_xor ^= (uint32_t)ptr;&#125;void heapt_trace_free(void *ptr, uint32_t size)&#123;    if(heapt_info.trace_enable == 0)&#123;        return ;    &#125;    heapt_info.free_count++;    heapt_info.malloc_used_count--;    heapt_info.memory_used -= size;    heapt_info.ptr_xor ^= (uint32_t)ptr;&#125;int heapt(int argc, char * const argv[])&#123;    int ret;    if(argc &lt; 2)&#123;        printf(&quot;Usage: %s PROG [ARGS]\\r\\n&quot;, argv[0]);        return 1;    &#125;    heapt_init();    ret = run_cmd(argc - 1, &amp;argv[1]);    const heapt_info_t *info = heapt_get_info();    printf(&quot;max heap use: %lu\\r\\n&quot;, info-&gt;memory_max_used);    printf(&quot;max alloc nm: %lu\\r\\n&quot;, info-&gt;malloc_max_count);    printf(&quot;malloc count: %lu\\r\\n&quot;, info-&gt;malloc_count);    printf(&quot; free  count: %-8lu&quot;  , info-&gt;free_count);    if(info-&gt;malloc_count != info-&gt;free_count)&#123;        printf(&quot; [Warning]\\r\\n&quot;);    &#125;else&#123;        printf(&quot;\\r\\n&quot;);    &#125;    if(info-&gt;memory_used != 0)&#123;        printf(&quot;used at exit: %-8lu [Warning]\\r\\n&quot;, info-&gt;memory_used);    &#125;    if(info-&gt;ptr_xor)&#123;        printf(&quot;mem ptr xor : %08lx [Warning]\\r\\n&quot;, info-&gt;ptr_xor);    &#125;    if(info-&gt;malloc_faild)&#123;        printf(&quot;malloc faild: %-8lu [Warning]\\r\\n&quot;, info-&gt;malloc_faild);    &#125;    heapt_deinit();    return ret;&#125;\n\n基于该内存跟踪，我测试了一些常用的代码，发现它都工作良好，直到我测试RSA相关代码时。RSA一个解密操作就动辄100k+次的内存申请量，导致系统出现了一些意外的情况。\n系统日志显示：\nmax heap use: 17264max alloc nm: 16malloc count: 279544 free  count: 279544used at exit: 4294967288 [Warning]\n日志显示内存分配和释放的内存字节数不相等，导致程序退出时内存记录的量不为0。起初我以为是内存有用法问题，但wolfSSL作为一款商业级的软件，应该不存在这样低级的错误。且mem ptr xor也没有报告内存泄露，内存申请和释放次数也是相等的。至此我不得不怀疑FreeRTOS提供的traceMALLOC(pv, size)和traceFREE(pv, size)存在问题。\n发现FreeRTOS内核代码存在问题FreeRTOS的heap4实现是基于空闲块链表实现的，将所有的可用内存块以链表的形式连接起来，当分配的内存小于内存块时，会将内存块进行分割，将其中一部分返回到用户，另一部分重新插入到空闲链表中。\n// pvPortMalloc()// ....if( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )&#123;    /* This block is to be split into two.  Create a new        * block following the number of bytes requested. The void        * cast is used to prevent byte alignment warnings from the        * compiler. */    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );    configASSERT( ( ( ( size_t ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == 0 );    /* Calculate the sizes of two blocks split from the        * single block. */    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;    pxBlock-&gt;xBlockSize = xWantedSize;    /* Insert the new block into the list of free blocks. */    pxNewBlockLink-&gt;pxNextFreeBlock = pxPreviousBlock-&gt;pxNextFreeBlock;    pxPreviousBlock-&gt;pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );&#125;else&#123;    mtCOVERAGE_TEST_MARKER();&#125;xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;if( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )&#123;    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;&#125;else&#123;    mtCOVERAGE_TEST_MARKER();&#125;// ....traceMALLOC( pvReturn, xWantedSize );//...\n传入到traceMALLOC(pv, size)的size参数是用户传入的内存大小，这里返回到用户的内存卡大小可能比用户预期想要的要大。因为内存块可拆分的条件是内存块拆分后剩余的大小必须大于16字节，如果不满足条件则该内存不拆分且不会进一步去寻找其它的内存块，这样返回到用户的内存块大小实际上要比用户预期的要大一些。\n// vPortFree()// ...vTaskSuspendAll();&#123;    /* Add this block to the list of free blocks. */    xFreeBytesRemaining += pxLink-&gt;xBlockSize;    traceFREE( pv, pxLink-&gt;xBlockSize );    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );    xNumberOfSuccessfulFrees++;&#125;( void ) xTaskResumeAll();// ...\n而传入到traceFREE(pv, size)的size正好是内存块的大小。这就导致了malloc和free时记录到的内存用量不一致。\n这真是一个有意思的发现。traceMALLOC机制由早在2013年的V7.5.3版本引入，在过去的这段时间内大家似乎并没有经常使用它，导致这个问题潜伏了10年之久。好在这仅仅是一个作为调试功能存在的bug，而且它不会影响FreeRTOS的主要功能。\n6月5日，我在FreeRTOS-Kernel上提交了相关Issue，内核开发小组很快确认该问题并建议我提交一个Pull Request来修复它。注：存在该问题的最后版本应该为V11.1.0\n修复内核代码这个问题看起来非常简单，只需要将实际分配的内存块大小传入到 trace_MALLOC()函数中即可。但实际操作起来却让我非常为难。\n\n当内存申请失败时，该size是0还是用户想要的内存大小xWantedSize？\n直接修改xWantedSize还是新建变量进行处理？\nheap1和heap3是否需要同步修改？\n\n我向内核提交的第一版代码是在内存块不拆分时修改xWantedSize，这样就能够使得trace_MALLOC获得正确的大小。但是官方在第一次审核我的代码时建议我建立一个新的变量用于表示内存块的大小而非使用xWantedSize，于是我修改了代码，这样看起来代码的可读性更高。由于不同处理器架构的heap实现有多个，我没法逐个去测试验证。PR代码只测试了heap4，但是其它的修改是一致的，且代码会经过GIT服务器上的自动化流程测试。确保代码在代码风格、可集成性、功能上都满足规范要求。\n从我提交PR - Fix traceMALLOC() allocated bytes到将代码合并入主干仅花了两天时间，过程很顺利。由于我的github账号是中文昵称，这导致合并到主线的代码作者名称显示为中文昵称，而不是我的英文名。这在Git-Graph中看起来怪怪的，似乎我没有看到其它开发者使用中文昵称提交的代码。😅\n在我发现问题和解决问题的过程中，内核开发者都比较友好，也对我做的工作给予了肯定。这也是第一次尝试在大型开源项目中贡献代码，一段非常有意思的经历。\n"},{"title":"简单尝试一下ITCM","url":"/2023/12/15/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8BITCM/","content":"ITCM简介在STM32高性能单片机中存在一种供内核专用的内存TCM-SRAM，称为紧耦合内存。为了区分不同的用途，又存在称为DTCM和ITCM的两种不同内存，这两种内存本质上是一致的，但是其背后默认的MPU策略不同，所以一般将DTCM用于存储关键的堆栈数据，将ITCM用于存储关键代码的指令。\n由于TCM内存拥有独立的总线直连Cortex内核，它不经过AXI总线矩阵，所以理论上它应该要块很多才对。那TCM相比于一般的内存到底快多少呢？这里做一些简单的测试来说明一下。\nITCM运行测试构造一个简单的函数作为测试的对象：\nvoid runtest(void)&#123;  for(int i = 0; i &lt; 2000 * 1000; i++)&#123;    __NOP();    __NOP();    __NOP();    __NOP();  &#125;&#125;\n\n测试的芯片选用STM32H7B0芯片，其主频280MHz，理论上主频越高，ITCM的优势越明显。\n这里还需要说明一下D-Cache，指令缓存也能显著提高代码的运行速度，所以这里设计了4中不同的测试场景。通过统计被测函数的执行时钟周期来反应代码的执行速度。\n注：测试时未开启编译优化，调用函数在Flash中，运行栈为AXI-SRAM\n\n1.关闭D-Cache，被测函数在Flash中执行运行周期：26065054\n2.关闭D-Cache，被测函数在ITCM中执行运行周期：15088644\n3.开启D-Cache，被测函数在Flash中执行运行周期：16019317\n4.开启D-Cache，被测函数在ITCM中执行运行周期：14017011\n\n通过以上的数据不难看出ITCM的优势。在ITCM中运行的指令比在Flash中开启了D-Cache的指令运行还要块。测试的第4中情况相比于第1种情况性能更是提升了45%以上。\n如何使用ITCM这里简单介绍在gcc开发平台下如何方便快捷的使用ITCM。\n首先需要在链接脚本中为函数分配独立的字段，用于将相关函数链接到ITCM中。\n/* Initialized ramfunc sections goes into RAM, load LMA copy after code */_siramfunc = LOADADDR(.ramfunc);.ramfunc :&#123;  . = ALIGN(4);  _sramfunc = .;     /* create a global symbol at data start */  *(.RamFunc)        /* .RamFunc sections */  *(.RamFunc*)       /* .RamFunc* sections */  . = ALIGN(4);  _eramfunc = .;     /* define a global symbol at data end */&#125; &gt;ITCMRAM AT&gt; FLASH\n这里需要注意，RamFunc可能已经存在于data字段中，需要将其中data字段中删除。\n这段链接脚本将函数的存储地址放到Flash中用于持久固化，将函数运行地址放到ITCM中用于执行。\n之后需要代码将Flash中的代码数据搬运到ITCM中，这部分工作最好在汇编代码中完成。\n/* 这部分放到最前面 */.word _siramfunc.word _sramfunc.word _eramfunc/* 这部分插入到启动汇编代码中 *//* Copy RamFunc segment from flash to RAM */  ldr r0, =_sramfunc  ldr r1, =_eramfunc  ldr r2, =_siramfunc  b LoopCopyRamFuncCopyRamFunc:  ldr r3, [r2], #4  str r3, [r0], #4LoopCopyRamFunc:  cmp r0, r1  bcc CopyRamFunc\n如果认为汇编较复杂，也可以使用C代码替代，作用是一样的：\nextern uint8_t _siramfunc;extern uint8_t _sramfunc;extern uint8_t _eramfunc;memcpy(&amp;_sramfunc, &amp;_siramfunc, (uint32_t)(&amp;_eramfunc - &amp;_sramfunc));\n\n这样当声明函数时就可以将函数存放到ITCM中，并实现持久化的运行：\nvoid runtest(void) __attribute__((section(&quot;.RamFunc&quot;)));void runtest(void)&#123;  for(int i = 0; i &lt; 2000 * 1000; i++)&#123;    __NOP();    __NOP();    __NOP();    __NOP();  &#125;&#125;\n\n其它的开发平台也是类似的原理。\nITCM的一些限制ITCM用起来也不是完美的，当涉及较多的函数间调用时，如果指令地址频繁在Flash、ITCM直接来回切换，会产生许多不必要的开销，因为它们两个区域的地址跨度太大，无法直接跳转，编译器会产生一些虚拟函数来实现这个跳转的过渡，无论是Flash到ITCM，还是ITCM到Flash都会有这样的操作。\nITCM主要是用于执行一些时间敏感的函数，例如中断函数，使得中断能够更快响应。还有就是例如FFT这种纯粹的计算型函数，它不会发生较多的其它函数调用且函数执行时间较长，这也能发挥ITCM的关键优势。\n"},{"title":"简单聊聊LevelX","url":"/2024/12/11/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8ALevelX/","content":"简介LevelX，一款专为嵌入式存储打造的存储中间件，常与ThreadX等产品协同作业。它为嵌入式实时系统提供了卓越的Flash存储磨损均衡功能，即便独立使用也游刃有余。LevelX能够与各种文件系统和实时系统完美融合，适应多变的应用场景。\nThreadX及其相关组件最早是由Express Logic开发。该实时操作系统获得了多项安全认证。它以支持Cortex-M处理器为主，在Cortex-A处理器上，ThreadX也得到了很好的支持。除了RTOS外，它提供的文件系统、网络协议栈、USB协议栈、GUI等软件也非常优秀。2019年，微软将ThreadX及其相关组件收购，并改名为Azure RTOS。2023年底，微软宣布将Azure RTOS及其组件转移到Eclipse基金会并并宣布开源，同时更名为Eclipse ThreadX。虽然几经易主，但它任然是一款久经考验、相当成熟稳定的产品。\n为了避免不同时期产品的命名差异，后面统一使用ThreadX和LevelX。相比于Threadx其它优秀的组件，LevelX看起来非常的普通，少有单独使用它的情况。我最近在测试某个nand flash芯片时准备使用该磨损均衡实现，实测一下效果。搭配FileX文件系统对比一下内建了磨损均衡的文件系统LittleFS的差异。\n磨损均衡奥秘磨损均衡技术的核心在于确保数据能够均匀地分布在存储器的各个区域，从而避免某一区域因长期写入而导致Flash写入不均衡。其关键策略在于避免数据的就地更新，而是通过分配新块来写入数据，实现数据的均匀分布。\n关键术语解析在文件系统、存储组件及芯片手册中，经常能看到看到扇区(sector)、块(block)、页(page)的描述，在不同的场景下可能存在表达含义的差异。为了后续内容便于理解，这里规定这几个词的含义。扇区对应一个可读写的存储单元，通常应用于文件系统、FTL层的接口中。块是页的集合，是最小的擦除单位。页是最小的读写单位。\nLevelX工作原理 (Nand flash)LevelX针对nor flash和nand flash实现了两套存储方案，关于nand和nor的差异这就不展开说明了，这里仅讨论关于LevelX针对nand flash的实现部分。\nLevelX实现了一套扇区读写接口，通过一套内部机制，将扇区映射到存储器的页上，实现了FTL的功能。同时在块分配过程中通过寻找最小擦除次数的块来分配新的块，实现写入磨损的均匀分布。\nLevelX存储在flash上的数据分为两种，一种是元数据(meta data)，另一种是真实的扇区数据。元数据和扇区数据分别存储在相对各自独立的块中，即元数据所在的块不会写入扇区数据。\n元数据包括flash设备信息、擦除计数表、块映射表、块状态表等。其中最关键的是块映射表，它是实现逻辑扇区到flash物理页映射的关键。块状态表用于标记块的状态，包括是否被分配使用、是否是坏块等。\n执行_lx_nand_flash_format()函数的过程就是重建元数据的过程。执行_lx_nand_flash_open()函数的过程就是将在flash上查找元数据并全部保存到内存中。由于需要将元数据全部加载到内存中，使用LevelX是比较耗费内存的，大约需要使用的字节数为8倍块数+2倍的页字节数。\nLevelX是基于块进行映射的，而不是基于扇区进行映射。所以相邻逻辑扇区的数据必定位于同一块中。例如扇区0和扇区1的数据被映射到物理块7的第1页和第2页(LevelX要求逻辑扇区大小等同于物理页大小)。假设一个块有64页，那么这个块存储的逻辑扇区必定是n+0~n+63。扇区在块内的排列可能是连续的，也可能是非连续的，这里后续会详细说明。\nnand flash在每个页上除了存储数据的区域外，还附随了一个spara区域，用于存储该页相关联的一些数据，一般包括坏块标记和ECC校验信息。spara区域是LevelX这类FTL软件能够正常工作的必要条件。\n执行_lx_nand_flash_sector_read()用于读取扇区数据。首先通过逻辑扇区号计算出逻辑块号(&#x3D;扇区号&#x2F;块内页数)，通过块映射表定位到数据所在的物理页。此时定位到了数据所在的块，这时需要分两种情况，通过块状态表查询该块内存储的扇区是否是连续的，如果扇区是连续的，那么直接通过扇区偏移(&#x3D;扇区号%块内页数)就能得到逻辑扇区所对应的物理地址数据。如果扇区编号不是连续的，那么需要遍历块内的每个页，每个页的spara区域中存储了该页实际的逻辑扇区号，通过比对逻辑扇区号和当前页的逻辑扇区号，就可以找到对应的物理地址数据。这里可以看出非连续模式下，数据的读取效率非常低，因为它需要遍历块内的所有数据。实际上只需要遍历块内的所有spara数据即可，但是由于接口设计的原因，存储区域内的数据还是会读取，导致效率低下。\n如果某个扇区的数据未写入，那么它所在的块可能未分配，在映射表中将返回未映射的状态。或者块已经分配了，但是块内的数据页没有写入，这时_lx_nand_flash_sector_read()将返回全为0xff的数据。\n数据的读取流程比较简单，主要都是一些数据的检索过程。数据写入将会非常复杂，除了扇区数据的写入外，还需要更新元数据。此外还需要考虑电源故障等安全问题。\n为了克服电源故障，LevelX的元数据更新采用两次写入机制，即所有的元数据会有一个备份，且备份存在于不同的块中。所以写入新的元数据时，总有另外一个元数据是安全的。假设块映射表元数据占用4个页(0-1-2-3)，那么每次更新时，先定位到待修改元数据的页，将该页标记为无效，同时在内存中将新的元数据写入到一个新的页中。即使元数据在块上不连续，_lx_nand_flash_open()函数会在读取元数据时自动合并各个元数据块。\nlx_nand_flash_sector_write()函数用于写入扇区数据。类似于读取流程，先根据扇区号定位到块号，在通过块映射表查找数据所在物理块。如果块未分配，那么执行块分配流程。如果块已经分配，那就再块内写入新的扇区数据，如果存在原数据，需要将原数据页标记为无效。如果新新写入的数据导致块内数据不连续，那么需要更新块状态为无序状态(NON_SEQUENTIAL)。如果一个块内的数据页都被分配了，那么将执行块拷贝流程，即分配新的块，并将现有块中的有效数据全部拷贝过去，然后再写入新的数据。\n块分配流程比较简单，首先通过块状态表查询出空闲的块列表，找到最后一个空闲块进行分配。为什么是最后一个？因为空闲表是一个有序表，它是按照擦除次数进行排序的。每次有新的空闲块插入表中，都会执行一个有序插入的过程。这个块分配机制在一定程度上保证了磨损均衡。LittleFS的磨损均衡采用hash函数随机分配新的块，通过hash函数的随机性来保证写入的均匀性。后者的分配效率高一些。\n分配了新的块或者将旧块拷贝到新块后需要更新对应的映射表元数据，先更新内存，再更新flash上的元数据。旧的块应当被擦除(元数据需要更新空闲表、擦除计算表)。块的擦除次数如果超过一定的阈值后，会将这个块上的数据全部移动到一个擦除次数较少的块上。\nCOW机制贯穿LevelX的整个流程，它保证了数据写入的安全性。\nLevelX还提供了软件ecc实现，但仅支持256字节长度的数据，如果扇区超过256字节的话还要分片处理。现在大部分nand芯片都提供了硬件ecc，我就没有测试这里的ecc算法，不过看了下代码，ecc的生成和校验都不依赖额外的内存空间，这点比较好。\n注：本文基于LevelX v6.4.1版本进行阐述。\n实测体验在实测过程中，我尝试将LevelX与W25N01G芯片结合使用，并验证了其大量数据读写的稳定性。然而，在搭配FatFS和FileX文件系统使用时，发现写入性能不尽如人意。使用50MHz的SPI总线，在大量文件重复写入的情况下，文件写入速度在50kb&#x2F;s左右，严重低于心里预期。读取速度好一些，可以达到几兆字节每秒。后面又移植了FileX文件系统，读写性能没有太大的提升，我看到部分网友与我有类似的情况。经过分析，这主要归因于LevelX在检索扇区号时的高开销。\n相较于LittleFS，LevelX在性能稳定性方面略逊一筹。LittleFS的性能波动较小，而LevelX在块分配混乱后性能下降明显，影响系统实时性。然而LittleFS和LevelX本就是针对不同的存储介质而设计的，两者相比较似乎不能判断孰优孰劣。\nLevelX和FileX都是耗内存大户，两者一搭配，RAM内存直接占用近30kb，对资源受限的设备不友好。尽管LevelX在性能和资源占用方面存在一定不足，但其在嵌入式存储领域的独特价值和广泛应用前景不容忽视。\n\n以上部分内容由腾讯浑元大模型AI美化及生成，希望本文能为您提供有益的参考和启示。\n"},{"title":"统计FreeRTOS中各个线程的处理器利用率","url":"/2023/08/30/%E7%BB%9F%E8%AE%A1FreeRTOS%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/","content":"\n大约是在一年前，我在工作中遇到了需要分析嵌入式系统性能的需求，需要查看系统在关键时间点上，部分任务是否存在执行时间过长导致系统实时性能降低的情况。我在基于FreeRTOS的系统中设计了一段非侵入式的代码，能够获取到各个线程实时的处理器利用率，进而分析系统是否设计合理。最近我在整理以前的代码时又看到当时设计的这个功能，我发现当时仅仅是满足了一个基本的功能需求，部分地方还设计的不是足够的合理，所以最近抽空想把这个功能整理完善，以备以后工作之需。\n\n处理器利用率如何理解处理器利用率？这里摘抄了Linux系统中对这个词的理解：\nCPU Usage:The task&#x27;s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time.\n翻译过来差不多就是指在一段时间长度T内，线程A的运行时间占用了t，则在这段T时间端内，线程A的处理器利用率为 t&#x2F;T。如果了解操作系统运作的原理，再来理解处理器利用率是非常简单的。\n统计每个线程的执行时间FreeRTOS操作系统内核本身是支持统计任务执行时间的，但是它是统计从任务开始运行时计算的，这种统计方法无法分析实时的处理器利用率，而且长时间的记录会导致内部时间计数器溢出，所以需要重新设计统计线程执行时间的功能。\n统计一个任务的执行时间长度需要在任务开始运行和结束运行的时间点上计时，这里的开始运行和结束运行是指任务对处理器的占用情况，而不是指任务真正的开始和结束。结合FreeRTOS内核可以利用内核提前设计好的Hook机制找到任务进入和退出的时机，也就是下面两个宏：\n#ifndef traceTASK_SWITCHED_IN/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the selected task. */    #define traceTASK_SWITCHED_IN()#endif#ifndef traceTASK_SWITCHED_OUT/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the task being switched out. */    #define traceTASK_SWITCHED_OUT()#endif\n\n这里的注释非常好理解，根据这两个Hook函数和pxCurrentTCB就能够掌握每个线程的切换情况。这里先说明一点，这个功能对FreeRTOS内核是非侵入的，不会到FreeRTOS内核代码做任何改动。\n接下来就是需要设计一个高精度的定时器，以我的经验来看定时器精度至少要达到微秒级别以上才行，因为有时候线程的切入和切出非常的块，定时器精度不够的话就无法准确的计算执行时间。\n这里我采用的高精度定时器是DWT内核调试模块的计时单元，它的运行频率和处理器一致，所以定时精度是足够的，而且32位的计数器也能够满足一定时间长度的计时需求，这个内核调试模块在ARM Cortex-M处理器中都存在。\n这里是我设计的DWT计时功能代码：\n/* cpu tick timer config. */#define TIME_SEC_TO_US (1000000u)#define CPU_CLK_FREQ() (SystemCoreClock)#if defined(DWT) &amp;&amp; defined(CoreDebug)static unsigned int fclk_pre_us;static inline void cpu_ts_time_init(void)&#123;    fclk_pre_us = CPU_CLK_FREQ() / TIME_SEC_TO_US;    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;    DWT-&gt;CTRL        |= DWT_CTRL_CYCCNTENA_Msk;    DWT-&gt;CYCCNT       = 0;&#125;static inline unsigned int cpu_ts_timrd(void)&#123;    //return us    return (DWT-&gt;CYCCNT / fclk_pre_us);&#125;static inline void cpu_ts_reset(void)&#123;    DWT-&gt;CYCCNT = 0;&#125;\n提供了计数器初始化、复位、记录时间的功能。\n记录FreeRTOS各个任务的运行时间建立一个长度为MAX_TASK_NUMS的数组task_runtime用于存储每个任务的执行时间，数组中的每一项对应一个任务，所以需要为每个任务分配一个唯一的ID，FreeRTOS内核为每个任务分配了独立的ID，但是这些ID是不受控制的，即ID的分配总是递增的，任务删除后不会回收。所以需要为每个任务重新分配ID并在任务删除后做回收的处理。\n#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;\n\n分配ID的过程是足够简单的，不会对系统的性能产生太多额外的影响。同样的利用Hook机制，把它嵌入到FreeRTOS内核中。\n// FreeRTOSConfig.h#define traceTASK_CREATE(pxTCB)  alloc_task_id(pxTCB)#define traceTASK_DELETE(pxTCB)  release_task_id(pxTCB)\n\n通过task_runtime[(TASK_ID(pxCurrentTCB))]就能记录和访问线程的运行时间。\n接下来就是最关键的traceTASK_SWITCHED_IN()和traceTASK_SWITCHED_OUT()，它们看起来还是比较简单的，一个最基础的逻辑如下：\nstatic uint32_t switch_in_time = 0;static uint32_t task_runtime[MAX_TASK_NUMS] = &#123;0&#125;;void task_switched_out(void)&#123;    task_runtime[(TASK_ID(pxCurrentTCB))] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();&#125;\n\n到此就实现了记录任务的运行时间，但是这和FreeRTOS内部的实现是类似的，我们需要在适当的时候清空所有的任务运行时间并重置计数器，保证系统总是记录任务最新的处理器利用率。\n记录任务实时的处理器利用率如果只有一个缓存记录处理器的运行时间，就会存在一个这样的情况，当运行时间情况的时候，正好需要查看处理器的利用率，那此时就看不到准确的数据。所以设计两个缓存，一个用于记录当前的数据，另一个用于缓存上一次的数据并给予用户访问。\n最终完整的设计实现如下：\nextern void* pxCurrentTCB;#define STAT_PERIOD (3000000u)#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])#define CURRENT_TASK_ID (TASK_ID(pxCurrentTCB))#define MAX_TASK_NUMS (32)static uint32_t switch_in_time = 0;static uint32_t task_runtime_buf1[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_runtime_buf2[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_total_runtime = 0;static uint32_t *task_current_runtime = task_runtime_buf1;void task_switched_out(void)&#123;    task_current_runtime[CURRENT_TASK_ID] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();    if(switch_in_time == 0)&#123;        cpu_ts_time_init();        switch_in_time = cpu_ts_timrd();    &#125;    if(switch_in_time &gt; STAT_PERIOD)&#123;        cpu_ts_reset();        task_total_runtime = switch_in_time;        switch_in_time = 0;        if(task_current_runtime == task_runtime_buf1)            task_current_runtime = task_runtime_buf2;        else            task_current_runtime = task_runtime_buf1;        for(int i = 0; i &lt; MAX_TASK_NUMS; i++) task_current_runtime[i] = 0;    &#125;&#125;/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;static int task_id_exist(int id)&#123;    return (id_pool &amp; (1 &lt;&lt; id));&#125;static const uint32_t *get_task_runtime(void)&#123;    if(task_current_runtime == task_runtime_buf1)        return task_runtime_buf2;    else        return task_runtime_buf1;&#125;int show_cpu_usage(int argc, char **argv)&#123;    char buf[1024] = &#123;0&#125;;    int buf_len = 0;    // os_enter_critical();    const uint32_t *tick_buf = get_task_runtime();    float r = 0;    uint32_t irq_runtime = task_total_runtime;    for(int i = 0; i &lt; MAX_TASK_NUMS; i++)&#123;        if(!task_id_exist(i))&#123;            continue;        &#125;        if(i == 0)&#123;            if(tick_buf[i] &gt; 0)                buf_len += sprintf(buf + buf_len, &quot;&gt;32 --  &quot;);            else                continue;        &#125;else&#123;            buf_len += sprintf(buf + buf_len, &quot;%2d  --  &quot;, i);        &#125;        if(tick_buf[i] == 0)&#123;            buf_len += sprintf(buf + buf_len, &quot;0\\n&quot;);        &#125;else&#123;            r = 100.0f * (float)tick_buf[i] / task_total_runtime;            if(r &lt; 0.01f)                buf_len += sprintf(buf + buf_len, &quot;&lt;0.01%%\\n&quot;);            else                buf_len += sprintf(buf + buf_len, &quot;%.2f%%\\n&quot;, r);        &#125;        irq_runtime -= tick_buf[i];    &#125;    r = 100.0f * (float)irq_runtime / task_total_runtime;    buf_len += sprintf(buf + buf_len, &quot;IS  --  %.2f%%\\n&quot;, r);    // os_exit_critical(0);    puts(buf);    return 0;&#125;\n记录周期为3000ms，这个时间需要结合定时器的溢出时间、系统性能要求做调整，时间太短会影响系统调度性能，太长会导致处理器利用率统计的实时性降低，且计数器存在溢出的风险。\n最后这里写了一段简单的代码来输出各个任务的CPU利用率，经过我的测试，它能够很好的工作。访问数据时建议进入到临界区处理，这样更加安全。在实际使用时，每个线程使用ID表示的，ID和任务名称的关系可以通过FreeRTOS内核函数vTaskList()得到，一一对应即可。\n总结内容我写的比较仓促，其中部分细节我没有太多的说明，但我认为这些都是比较好理解。关于任务ID的分配，还有些细节没有说明，我将超过31个任务后面的任务ID统一分配为0，它们的处理器利用率将一并计算，这是我的ID分配器决定的，它只能分配31个ID。\n当时我实现这个功能时忽略了FreeRTOS内核对任务ID的分配策略，当时我直接引用系统分配的ID，如果不对任务进行删除操作，他还是能够可靠的工作。但是如果需要进行任务删除，那么就会出现一些奇怪的问题。我也是最近才发现这个问题。主要是当时对FreeRTOS内核内的一些细节还是不够了解。\n关于中断的执行时间，我这里只是粗略的估算了一个irq_runtime ，它包含了大部分任务调度的时间，并不能够保证把所有的中断时间统计在内。\n这里涉及到了高精度定时器、快速ID的分配、双缓冲机制、内核调度、非侵入式设计等内容，每个都能够拿出来细讲，限于时间和篇幅就点到为止。如果你有幸看到这篇文章，对其中的内容有疑问或者建议，欢迎一起沟通学习。\n"},{"title":"重新做了一版ARM仿真器","url":"/2025/02/14/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%86%E4%B8%80%E7%89%88ARM%E4%BB%BF%E7%9C%9F%E5%99%A8/","content":"简介我最近又重新设计制作的了一款ARM仿真器，相比于之前做的版本，增加了一块屏幕，并使用编码器拨轮进行交互，还内置了一块电池，可以实现脱机程序烧录。\n下面是主要配置：\n\n160x128 像素分辨率的1.8寸屏幕\n\nRP2350 MCU\n\n内置16MB存储空间+8MB扩展运行内存+32GB TF卡支持\n\n900mAh/3.7V 锂电池\n\n一路UART接口\n\n一路SWD接口，支持20MHz速率\n\n可对外提供3.3v/1A供电\n\n\n支持的主要功能有：\n\nCMSIS-DAP调试器功能\n\nGDB调试器功能\n\n脱机下载功能，支持上百款MCU\n\n脱机串口功能，可在屏幕上实时显示串口接收到的数据\n\n设备内文件管理功能\n\n模拟U盘功能\n\n\n开发过程1.硬件部分其实上一版开发完成后，我就准备着手这个新版本的开发了，主要是上一个版本的功能亮点不足，最终我决定再进行一次大的升级。主要是围绕设备能够脱机使用，添加了脱机下载和脱机串口功能。\n首先是硬件开发方面，将MCU由RP2040更换为RP2350，其主频、SRAM、IO数量都做了升级。选择该芯片的原因是RP2350芯片的价格已经比较实惠了且性能有了比较大的提升，最关键的是由于增加了不少外设(屏幕、存储等)使得IO分配比较紧张。\n该MCU还支持外扩PSRAM，所以加了一颗AP6404L的芯片，扩展SRAM主要是为了提高脱机下载时的速度，有了充足的SRAM就可以将固件全部加载到内存中进行再下载。\n在存储方面，没有直接使用存放固件的flash来存储数据，而是单独添加了一块norflash芯片，还添加了TF卡的卡座，norflash和tf卡共用一条SPI进行数据传输。屏幕为一块ST7735主控的LCD屏幕，还是使用SPI进行数据传输，为了保证屏幕刷新和存储数据的读写，屏幕和存储芯片各自使用一个独立的SPI。\n拨轮是SIQ-02FVS3，为AB编码器接口，原本计划使用PIO驱动，但是开发软件时才发现IO分配不合理导致只能使用中断驱动。\n电源方面的电路变化不大，主要是增加了充电芯片和开关机管理电路，充电芯片为TP4057，对于这个简单的设备来说，暂时不需要快充等功能。开关机管理使用一些MOS管进行搭建，如下图：\n\n\n开关电路\n\n\n开关机按键复用编码器拨轮的按键，器件选择上主要是要考虑电流参数。\n在这一版中，外部的SWD接口和UART接口上都添加了ESD保护芯片。这样外部的包括USB在内的三个插拔接口都有了防静电保护。\n来看看PCB：\n拨轮的安装比较特殊，在PCB上挖了一个洞，使得波轮能够沉到底部，在背部焊接。如果正常安装焊接，它将是整个PCB上最高的元件。现在这种安装方式可以减小整个PCB的厚度。\nPCB上电池座子的+-符号标识反了，但是不影响正常使用。所有的元件都是用风枪焊上去的，焊接效果还比较满意，这次温度把控的比较好，塑料件没有任何变形。\nTips:MCU旁边有颗电容尺寸不对，原本应该用0402的封装，但是该容值的电容手边没有，所以用0603的封装\n2.软件部分硬件弄好后就是软件开发工作，在软件开发方面，首先是需要将主要的外设驱动开发完成，包括屏幕、NorFlash、TF卡，编码器等。\nST7735驱动都有现成比较好用的，主要是要考虑异步渲染和刷新的性能问题，其它就是调试一下屏幕边界和颜色翻转就完成了，淘宝上5块钱买的屏幕，效果只能说一般般。\nTF卡的驱动要麻烦一些，RP2350没有SDIO接口，用PIO模拟目前也不会。只能使用SPI进行通讯了，时钟速度20MHz，NorFlash和它共用SPI，NorFlash速度本可以再高一些，但是只能兼顾TF的速度了，速度再高一些TF卡似乎存在一些问题。TF卡使用FatFS驱动，文件读写可以在400kB/s左右，NorFlash使用LittleFs读取速度要快一些。\nST7735的SPI采用DMA传输数据，考虑到使用DMA会到了额外的中断上下文切换和线程切换，对于小于15字节的传输任然采用阻塞传输会比较好。通过后续测试发现部分页面上的全屏动效运行起来的CPU占用也就不到50%。\n对于W25Q128和TF卡共用的SPI来说，使用DMA要稍微复杂一些。这里我也是摸索了好久才找到正确的写法，RP2350的SPI必须要有TX的数据才能完成正常的一次数据传输，所以最开始我只写了DMA接收，发现DMA并没有启动传输，那是因为SPI没有发出数据，自然也就无法接收数据，所以数据收发必须成对，即使用DMA也必须要这样。对于数据接收来说，我是这样写的：\nint spi_shard_read(uint8_t *buf, int len){    int ret;    if(len &lt;= 15){        ret = spi_read_blocking(SPI_INS, 0xff, buf, len);    }else{        uint8_t tx_dummy = 0xff;        /* DMA read dummy data Not increment */        dam_channel_read_increment(dma_tx_chan, false);        /* Read the data from the SPI FIFO by DMA */        dma_channel_transfer_to_buffer_now(dma_rx_chan, buf, len);        /* Write the dummy data to the SPI FIFO by DMA, Used to generate clock signals */        dma_channel_transfer_from_buffer_now(dma_tx_chan, &amp;tx_dummy, len);        /* Wait Rx DMA to complete */        if(xSemaphoreTake(spi_dma_rx_sync, pdMS_TO_TICKS(200)) == pdFALSE){            ret = 0;        }else{            ret = len;        }        /* Recover Tx channel auto increment */        dam_channel_read_increment(dma_tx_chan, true);        /* Clear the Tx sync semaphore */        xSemaphoreTake(spi_dma_tx_sync, 0);    }    return ret;}\n\n创建了两个DMA请求，但是Tx发送的数据临时关闭了地址自增，因为发送的数据本就是dummy，所以不需要地址自增。DMA请求发出后，DMA就会自动从SPI的FIFO中将数据读取出来，等待DMA中断发出的同步信号就表示数据传输完成。\n对于SPI的DMA发送来说，也有一些情况需要处理：\nint spi_shard_write(const uint8_t *buf, int len){    int ret;    if(len &lt;= 15){        ret = spi_write_blocking(SPI_INS, buf, len);    }else{        /* Write the date to the SPI FIFO by DMA */        dma_channel_transfer_from_buffer_now(dma_tx_chan, buf, len);        /* Wait for the DMA to complete */        if(xSemaphoreTake(spi_dma_tx_sync, pdMS_TO_TICKS(200)) == pdFALSE){            ret = 0;        }else{            ret = len;        }        /* Wait for the SPI to complete */        while(spi_is_busy(SPI_INS)){            if(spi_is_readable(SPI_INS)){                (void)spi_get_hw(SPI_INS)-&gt;dr;            }            taskYIELD();        }        /* Clear the RX FIFO and clear the overrun flag */        while(spi_is_readable(SPI_INS))            (void)spi_get_hw(SPI_INS)-&gt;dr;        spi_get_hw(SPI_INS)-&gt;icr = SPI_SSPICR_RORIC_BITS;    }    return ret;}\n\n这里只创建DMA数据发送请求即可，SPI接收回来到RxFIFO中的数据可能会溢出，但是可以忽略它们。需要注意的是，DMA传输完成不代表SPI已经传输完成，因为SPI内部是带有FIFO的，这里简单的用spi_is_busy来判断SPI是否传输完成，传输完成后再将RxFIFO中的数据清空以避免对后续的数据读取产生干扰。这里更严格的写法是使用的SPI的RxFIFO为空中断去处理SPI等待的问题，不过考虑到FIFO本身并不大且SPI的时钟速率较高，这里阻塞的时间可以忽略。\n看门狗如何检测两个MCU核心都在正常工作呢？刚开始就出现系统的一个核心已经死机了，但是喂狗的操作在另一个核心上，导致系统无法及时复位。后面我想到了一个比较好的办法：\nstatic void watchdog_task(void *ptr){    if (watchdog_caused_reboot()){        reset_usb_boot(0, 0);    }    watchdog_enable(1000, 1);    while(1){#if (configNUMBER_OF_CORES &gt; 1)        /* Update watchdog on all cores */        for(int i = 0; i &lt; configNUMBER_OF_CORES; i++){            vTaskCoreAffinitySet(NULL, 1 &lt;&lt; i);            watchdog_update();            vTaskDelay(pdMS_TO_TICKS(500));        }#else        watchdog_update();        vTaskDelay(pdMS_TO_TICKS(500));#endif    }}\n\n通过FreeRTOS创建一个最低优先级的任务(比IDLE线程优先级高)来运行看门狗。看门狗的超时时长设置为1秒，该任务准备每500ms进行一次喂狗操作，即使高优先级的任务有时间片抢占的情况，还有500ms的冗余空间。这里比较取巧的是我每次喂狗完成后就将任务切换到下一个核心上运行，这样就确保能够对所有的核心都起到监控的作用。\nSWD那部分的布线或者电路可能还需要优化，芯片和软件支持的最高速率是37.5MHz，而实际上在30MHz时钟下工作会出现无法识别外部芯片的问题，目前最高只能工作在20MHz，我怀疑是走线不规范或者阻抗相关的问题，如果要做下一版再去着重解决。\nSWD的底层采用PIO来驱动，时序上肯定没有问题，但是目前遇到一个与PIO交互的性能问题，与PIO交互是通过一个硬件FIFO实现的，每次遇到FIFO为空或满时都需要进行阻塞式的等待，这会使得低优先级的任务被长时间阻塞。如果采用中断信号通知FIFO状态，我担心频繁的中断信号也会带来性能问题，这个地方或许还要好好想想怎么优化，或许需要大改底层的SWD实现方法。\n在软件功能设计上，CMSIS-DAP和GDB调试功能在上一个版本就已经开发完成了，本次主要的开发工作都是围绕GUI相关功能进行的。GUI部分采用LVGL9图形框架，搭配GUI-Guider进行开发，目前GUI-Guider还不支持LVGL9，所以UI的开发工作还是比较多。\n在GUI上除了设计UI耗费时间外，文件管理功能和脱机下载功能耗费了比较多的开发时间，NorFlash和TF工作在两套不同的文件系统下，要实现文件的统一管理，必须设计更上层的抽象接口层。TF卡还需要允许通过USB挂载到电脑上，其中的功能细节也比较多。为了获得最佳的下载速度，我将固件从文件中读取并解析完成后全部存储在RAM中，然后再进行下载，这对于HEX类固件来说可以显著提高下载速度。\n目前主要支持hex格式的固件下载，bin格式的固件只能下载到芯片内Flash首地址上，还不支持自定义，主要是设备没有键盘和触摸屏，不方便输入。对于elf格式的固件还在准备开发中。\n分享一个开发工程中遇到的一个竞态问题，一个很有意思的问题。该问题出现在USB串口功能中，我创建了一个独立的线程用于将硬件UART上收发到的数据传输到USB协议栈中。问题现象是USB协议栈收到电脑发来的数据后从硬件串口发出后异常，小概率出现数据中多了一段乱码的数据。导致该问题的原因是在UART的DMA中断处理函数中出现了重入，导致对FIFO的操作出现了抢占，导致FIFO内的数据长度异常。为什么中断函数会重入？因为RP2350是一个双核MCU，它允许中断同时在两个核心上运行，根据PICO-SDK的手册来看irq_set_exclusive_handler()和irq_set_enabled()函数都是只对MCU当前的核心生效，为什么中断会同时运行在两个核心上？经过仔细的分析，首先解释第一点，为什么该中断函数通过irq_set_exclusive_handler会同时将中断绑定两个核心上，根据芯片手册，两个核心拥有独立的中断向量表。但是这里我忽略了一点，第二个核心是由FreeRTOS启动，它默认直接复用了核心1的中断向量表，导致两个核心将共享中断向量表。\nFreeRTOS对于RP2350的port文件：\nBaseType_t xPortStartScheduler( void ){    ...    multicore_reset_core1();    multicore_launch_core1( prvDisableInterruptsAndPortStartSchedulerOnCore );    xPortStartSchedulerOnCore();    /* Should not get here! */    return 0;}\n\n启动第二给核心的函数是multicore_launch_core1(),在它内部的实现上会复用当前中断向量表地址。如果要给第二个核心赋予独立的中断详表，应该使用multicore_launch_core1_raw接口。到了这里就明白了为什么第二个核心会存在中断函数。再解释第二点，为什么该中断被使能了。\n在创建UART任务时是这样写的：\nxTaskCreate(cdc_thread, \"UART\", configMINIMAL_STACK_SIZE, NULL, UART_TASK_PRIO, &amp;uart_taskhandle);#if (configNUMBER_OF_CORES &gt; 1)vTaskCoreAffinitySet(uart_taskhandle, 1 &lt;&lt; 0);#endif\n\n可以看到已经通过vTaskCoreAffinitySet函数将该任务绑定到了核心0上，但是我忽略了一点，由于当前任务的优先级比创建的UART任务优先级低，导致UART任务创建完成后就立即执行，而任务函数内进行中DMA中的开关操作，导致核心1上的DMA中断也打开了。这是在极短时间内出现的。这是一种非常典型的竟态问题，修复的手段也非常简单，就是在串口任务的入口处，将任务本身绑定到和核心0上。再说一下为什么在任务内进行了中断的开关操作，因为FIFO数据接口的操作需要锁定，理论上来说刚开机初始化时没有数据收发才对，但由于串口刚开始莫名奇妙收到一个字符，就是这一连串的问题导致了这个bug。分析这个问题至少花了大半天时间，可以看看这个commit。\nRP2350+FreeRTOS的低功耗模式也有进行测试，开启configUSE_TICKLESS_IDLE是必要的，这样运行systick的核心0可以正常进入休眠状态。如果第二个核心也运行了，那还需要开启configUSE_PASSIVE_IDLE_HOOK，让第二个核心通过WFI指令进入睡眠状态。只有两个核心都进入休眠，RP2350才能进入低功耗模式。开启低功耗模式后，系统功耗有一定降低，但是我我的设备功耗本身不高，可以轻松待机10小时以上，所以低功耗模式是没有开启的。\n2025.3.4 UPDATE:最近对该项目的一些细节问题进行了研究，包括SWD时钟速率和SD卡的驱动方式。最近发现，PIO模块内部为了避免输入IO上存在抖动，对输入信号经过了一个触发同步器，导致输入信号有额外2个时钟的延迟，考虑到信号采样时间，输入IO可能存在3个时钟周期。如果IO输入信号的延时超过SWD的半个周期，这就会导致SWD信号读取时无法得到准确的值。当系统时钟为150MHz时，则允许的SWD最大时钟为25MHz。实际测试发现可工作到21.54MHz，继续增大时钟将导致通讯错误。为了降低信号输入延时，PIO允许关闭输入同步系统。输入同步主要是优化异步通讯时使用的。我们这里有独立的时钟信号，所以可以关闭输入同步。实际测试发现关闭输入同步后可以将SWD的时钟频率提高到30MHz。最近还将SD的驱动方式从SPI改为SDIO模式，SDIO通过PIO实现，读写速度有了大幅度的提升。在测试开发板上，在15MHz时钟的SDIO接口下，SD的读写速度可达6.5MB/s，相比于SPI模式的读写速度提升了4倍。优化PCB线路后并提高SDIO时钟速率可进一步提高读写速度。\n3.外壳部分我使用UG为整个设备设计了一个外壳，好像很长一段时间没用UG建模，感觉不是很熟练了😅。\n\n\n\n\n\n\n\n\n本次设计的PCB和外壳都是在嘉立创制作的，3D打印的外壳还比较便宜，原计划使用CNC做一个金属的外壳，不过看了价格，还是放弃了。3D打印只要5块钱，CNC应该不低于300元，价格劝退，外壳上的结构特征基本上都是为了方便CNC加工而设计的。\n功能展示原本打算拍个视频来展示一下这个设备的功能，后面感觉拍不好就算了。我在设备内做了一个截图功能，就截取一些操作界面进行展示吧。\n\n\n    \n        1.主界面\n        2.一个列表式的文件管理器\n        3.串口接收界面\n        4.设置界面\n    \n    \n        5.固件下载过程\n        6.下载完成界面 1MHz时钟\n        7.下载完成界面 20MHz时钟\n        8.添加了一个小游戏😄\n    \n\n\n\n下载一个92k字节的固件，除去擦除时间，下载时间只有388ms，速度非常块。\n再来看看设备运行起来后MCU的状态：\nCPU freq:150MHzStat Period: 3000000usID   Name         CPU State Priority  Stack       MSP   Static SFREE  SC       DelayTime 1 DAP           0.00%  S      3    0x2002b7d0 0x2002bb58  D   224    0 2 TUD           1.11%  B      2    0x2002c6a0 0x2002ca30  D   182    3001      1 3 UART          0.30%  B      3    0x2002cb30 0x2002cea8  D   210    600       2 4 BMP           0.09%  X      3    0x2002cfc0 0x2002dc98  D   767    30 5 IDLE0        98.58%  R      0    0x2002e050 0x2002e3d8  D   212    2993 6 IDLE1        98.55%  X      0    0x2002e4e0 0x2002e888  D   228    2992 7 Tmr Svc       0.00%  B     31    0x2002ea70 0x2002f9e0  D   986    0         -1 8 GUI           0.77%  B      1    0x200301a8 0x200310b8  D   326    156       5Task scheduler CPU percent -- 0.57%MEM: 23304/153600 (15%)\n\n正常空闲状态下，CPU的占用都比较低，USB在传输数据时会占用一部分CPU。第一次使用FreeRTOS的双核特性，两个核心的调度还是比较合理的，即使GUI线程的CPU达到90%以上后，两个空闲线程的CPU占比都能够做到均匀分配。设备功耗不到0.2W，独立工作也能有较长的续航时间。\n最后来看看组装好的效果：\n\n最后还需要在上面盖一块亚克力的面板，这样就能将四个螺丝隐藏掉，整体外观效果就会好很多了。\n"},{"title":"锁相环(PLL)基本原理","url":"/2024/03/03/%E9%94%81%E7%9B%B8%E7%8E%AF(PLL)%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","content":"\n本文转载自《模拟对话》卷52，文章原作者是Ian Collins，《模拟对话》是亚德诺半导体的一份技术期刊，专注于电子模拟技术的最新进展和应用。原作者和亚德诺半导体对本文保留所有权利。本文不采用 BY-NC-SA 许可协议。PLL被广泛应用于嵌入式系统开发中的时钟同步和频率合成，本文可以帮助嵌入式软件开发工程师理解PLL的基本工作原理。\n\nIan Collins “AnalogDialogue” Volume 52, July 2018\n摘要：锁相环(PLL)电路存在于各种高频应用中，从简单的时钟净化电路到用于高性能无线电通信链路的本振(LO)，以及矢量网络分析仪(VNA)中的超快开关频率合成器。本文将参考上述各种应用来介绍PLL电路的一些构建模块，以指导器件选择和每种不同应用内部的权衡考虑，这对新手和PLL专家均有帮助。本文参考ADI公司的ADF4xxx和HMCxxx系列PLL和压控振荡器(VCO)，并使用ADIsimPLL（ADI公司内部PLL电路仿真器）来演示不同电路性能参数。\n基本配置：时钟净化电路锁相环的最基本配置是将参考信号(FREF)的相位与可调反馈信号(RFIN)F0的相位进行比较，如图1所示。图2中有一个在频域中工作的负反馈控制环路。当比较结果处于稳态，即输出频率和相位与误差检测器的输入频率和相位匹配时，我们说PLL被锁定。就本文而言，我们仅考虑ADI公司ADF4xxx系列PLL所实现的经典数字PLL架构。\n该电路的第一个基本元件是鉴频鉴相器(PFD)。PFD将输入到REFIN的频率和相位与反馈到RFIN的频率和相位进行比较。ADF4002是一款可配置为独立PFD（反馈分频器N&#x3D;1）的PLL。因此，它可以与高质量压控晶体振荡器(VCXO)和窄低通滤波器一起使用，以净化高噪声REFIN时钟。\n\n\n图1. PLL基本配置\n图2. PLL基本配置\n\n\n鉴频鉴相器\n\n图3. 鉴频鉴相器\n\n\n图3中的鉴频鉴相器将+IN端的FREF输入与和-IN端的反馈信号进行比较。它使用两个D型触发器和一个延迟元件。一路Q输出使能正电流源，另一路Q输出使能负电流源。这些电流源就是所谓电荷泵。有关PFD操作的更多详细信息，请参阅”用于高频接收器和发射器的锁相环“。\n使用这种架构，下面+IN端的输入频率高于-IN端（图4），电荷泵输出会推高电流，其在PLL低通滤波器中积分后，会使VCO调谐电压上升。这样，-IN频率将随着VCO频率的提高而提高，两个PFD输入最终会收敛或锁定到相同频率（图5）。如果-IN频率高于+IN频率，则发生相反的情况。\n\n\n图4. PFD错相和频率失锁\n图5. 鉴频鉴相器、频率和锁相\n\n\n回到原先需要净化的高噪声时钟例子，时钟、自由运行VCXO和闭环PLL的相位噪声曲线可以在ADIsimPLL中建模。\n\n\n图6. 参考噪声\n图7. 自由运行VCXO\n图8. 总PLL噪声\n\n\n从所示的ADIsimPLL曲线中可以看出，REFIN的高相位噪声（图6）由低通滤波器滤除。由PLL的参考和PFD电路贡献的所有带内噪声都被低通滤波器滤除，只在环路带宽外（图8）留下低得多的VCXO噪声（图7）。当输出频率等于输入频率时，PLL配置最简单。这种PLL称为时钟净化PLL。对于此类时钟净化应用，建议使用窄带宽(&lt;1kHz)低通滤波器。\n高频整数N分频架构为了产生一系列更高频率，应使用VCO，其调谐范围比VCXO更宽。这常用于跳频或扩频跳频(FHSS)应用中。在这种PLL中，输出是参考频率的很多倍。压控振荡器含有可变调谐元件，例如变容二极管，其电容随输入电压而改变，形成一个可调谐振电路，从而可以产生一系列频率（图9）。PLL可以被认为是该VCO的控制系统。\n反馈分频器用于将VCO频率分频为PFD频率，从而允许PLL生成PFD频率倍数的输出频率。分频器也可以用在参考路径中，这样就可以使用比PFD频率更高的参考频率。ADI公司的ADF4108就是这样的PLL。PLL计数器是电路中要考虑的第二个基本元件。\n\n\n图9. 压控振荡器\n\n\nPLL的关键性能参数是相位噪声、频率合成过程中的多余副产物或杂散频率（简称杂散）。对于整数N PLL分频，杂散频率由PFD频率产生。来自电荷泵的漏电流会调制VCO的调谐端口。低通滤波器可减轻这种影响，而且带宽越窄，对杂散频率的滤波越强。理想单音信号没有噪声或额外杂散频率（图10），但在实际应用中，相位噪声像裙摆一样出现在载波边缘，如图11所示。单边带相位噪声是指在距离载波的指定频率偏移处，1Hz带宽内相对于载波的噪声功率。\n\n\n图10. 理想LO频谱\n图11. 单边带相位噪声\n\n\n整数N和小数N分频器在窄带应用中，通道间隔很窄（通常&lt;5MHz），反馈计数器N很高。通过使用双模P&#x2F;P + 1预分频器，如图12所示，可以利用一个小电路获得高N值，并且N值可以利用公式N &#x3D; PB + A来计算；以8&#x2F;9预分频器和90的N值为例，计算可得B值为11，A值为2。对于A或2个周期，双模预分频器将进行9分频。对于剩余的(B-A)或9个周期，它将进行8分频，如表1所示。预分频器一般利用较高频率电路技术设计，例如双极性射极耦合逻辑(ECL)电路，而A和B计数器可以接受这种较低频率的预分频器输出，它们可以利用低速CMOS电路制造，以减少电路面积和功耗。像ADF4002这样的低频净化PLL省去了预分频器。\n\n\n图12. 具有双模N计数器的PLL\n\n\n表1. 双模预分频器操作\n\n\n\nN Value\nP&#x2F;P + 1\nB Value\nA Value\n\n\n\n90\n9\n11\n2\n\n\n81\n9\n10\n1\n\n\n72\n8\n9\n0\n\n\n64\n8\n8\n0\n\n\n56\n8\n7\n0\n\n\n48\n8\n6\n0\n\n\n40\n8\n5\n0\n\n\n32\n8\n4\n0\n\n\n24\n8\n3\n0\n\n\n16\n8\n2\n0\n\n\n8\n8\n1\n0\n\n\n0\n8\n0\n0\n\n\n带内（PLL环路滤波器带宽内）相位噪声受N值直接影响，带内噪声增幅为20log(N)。因此，对于N值很高的窄带应用，带内噪声主要由高N值决定。利用小数N分频合成器（例如ADF4159或HMC704），可以实现N值低得多但仍有精细分辨率的系统。这样一来，带内相位噪声可以大大降低。图13至图16说明了其实现原理。在这些示例中，使用两个PLL来生成适合于5G系统本振(LO)的7.4GHz至7.6GHz频率，通道分辨率为1MHz。ADF4108以整数N分频配置使用（图13），HMC704以小数N分频配置使用。HMC704（图14）可以使用50MHz PFD频率，这会降低N值，从而降低带内噪声，同时仍然支持1MHz（或更小）的频率步长——可注意到性能改善15dB（在8kHz偏移频率处）（图15与图16对比）。但是，ADF4108必须使用1MHz PFD才能实现相同的分辨率。\n对于小数N分频PLL务必要小心，确保杂散不会降低系统性能。对于HMC704之类的PLL，整数边界杂散（当N值的小数部分接近0或1时产生，例如147.98或148.02非常接近整数值148）最需要关注。解决措施是对VCO输出到RF输入进行缓冲，以及&#x2F;或者做精心的规划频率，改变REFIN以避免易发生问题的频率。\n\n\n图13. 整数N分频PLL\n图14. 小数N分频PLL\n图15. 整数N分频PLL带内相位噪声\n图16. 小数N分频PLL带内相位噪声\n\n\n对于大多数PLL，带内噪声高度依赖于N值，也取决于PFD频率。从带内相位噪声测量结果的平坦部分减去20log(N)和10log(FPFD)得到品质因数(FOM)。选择PLL的常用指标是比较FOM。影响带内噪声的另一个因素是1&#x2F;f噪声，它取决于器件的输出频率。FOM贡献和1&#x2F;f噪声，再加上参考噪声，决定了PLL系统的带内噪声。\n用于5G通信的窄带LO对于通信系统，从PLL角度来看，主要规格有误差矢量幅度(EVM)和VCO阻塞。EVM在范围上与积分相位噪声类似，考虑的是一系列偏移上的噪声贡献。对于前面列出的5G系统，积分限非常宽，从1kHz开始持续到100 MHz。EVM可被认为是理想调制信号相对于理想点的性能降幅百分比（图17）。类似地，积分相位噪声将相对于载波的不同偏移处的噪声功率进行积分，表示通过配置可以计算EVM、积分相位噪声、均方根相位误差和抖动。现代信号源分析仪也会包含这些数值（图18），只需按一下按钮即可得到。随着调制方案中密度的增加，EVM变得非常重要。对于16-QAM，根据ETSI规范3GPP TS 36.104，EVM最低要求为12.5%。对于64-QAM，该要求为8%。然而，由于EVM包括各种其他非理想参数（功率放大器失真和不需要的混频产物引起），因此积分噪声通常有单独的定义（以dBc为单位）。\n\n\n图17. 相位误差可视化\n图18. 信号源分析仪图\n\n\nVCO阻塞规范在需要考虑强发射存在的蜂窝系统中非常重要。如果接收器信号很弱，并且VCO噪声太高，那么附近的发射器信号可能会向下混频，淹没目标信号（图19）。图19演示了如果接收器VCO噪声很高，附近的发射器（相距800kHz）以-25dBm功率发射时，如何淹没-101dBm的目标信号。这些规范构成无线通信标准的一部分。阻塞规范直接影响VCO的性能要求。\n\n\n图19. VCO噪声阻塞\n\n\n压控振荡器(VCO)我们的电路中需要考虑的下一个PLL电路元件是压控振荡器。对于VCO，相位噪声、频率覆盖范围和功耗之间的权衡十分重要。振荡器的品质因数(Q)越高，VCO相位噪声越低。然而，较高Q电路的频率范围比较窄。提高电源电压也会降低相位噪声。在ADI公司的VCO系列中，HMC507的覆盖范围为6650MHz至7650MHz，100kHz时的VCO噪声约为-115dBc&#x2F;Hz。相比之下，HMC586覆盖了从4000MHz到8000MHz的全部倍频程，但相位噪声较高，为-100dBc&#x2F;Hz。为使这种VCO的相位噪声最小，一种策略是提高VCO调谐电压VTUNE的范围（可达20V或更高）。这会增加PLL电路的复杂性，因为大多数PLL电荷泵只能调谐到5V，所以利用一个由运算放大器组成的有源滤波器来提高PLL电路的调谐电压。\n多频段集成PLL和VCO另一种扩大频率覆盖范围而不恶化VCO相位噪声性能的策略是使用多频段VCO，其中重叠的频率范围用于覆盖一个倍频程的频率范围，较低频率可以利用VCO输出端的分频器产生。ADF4356就是这种器件，它使用四个主VCO内核，每个内核有256个重叠频率范围。该器件使用内部参考和反馈分频器来选择合适的VCO频段，此过程被称为VCO频段选择或自动校准。\n多频段VCO的宽调谐范围使其适用于宽带仪器，可产生范围广泛的频率。此外，39位小数N分辨率使其成为精密频率应用的理想选择。在矢量网络分析仪等仪器中，超快开关速度至关重要。这可以通过使用非常宽的低通滤波器带宽来实现，它能非常快地调谐到最终频率。在这些应用中，通过使用查找表（针对每个频率直接写入频率值）可以绕过自动频率校准程序，也可以使用真正的单核宽带VCO，如HMC733，其复杂性更低。\n对于锁相环电路，低通滤波器的带宽对系统建立时间有直接影响。低通滤波器是我们电路中的最后一个元件。如果建立时间至关重要，应将环路带宽增加到允许的最大带宽，以实现稳定锁定并满足相位噪声和杂散频率目标。通信链路中的窄带要求意味着使用HMC507时，为使积分噪声最小（30kHz至100MHz之间），低通滤波器的最佳带宽约为207kHz（图20）。这会贡献大约-51dBc的积分噪声，可在大约51μs内实现频率锁定，误差范围为1kHz（图22）。\n相比之下，宽带HMC586（覆盖4GHz至8GHz）以更接近300kHz带宽的更宽带宽实现最佳均方根相位噪声（图21），积分噪声为-44dBc。但是，它在不到27μs的时间内实现相同精度的频率锁定（图23）。正确的器件选择和周围电路设计对于实现应用的最佳结果至关重要。\n\n\n图20. 相位噪声HMC704加HMC507\n图21. 相位噪声HMC704加HMC586\n图22. 频率建立：HMC704加HMC507\n图23. HMC704加HMC586\n\n\n低抖动时钟对于高速数模转换器(DAC)和高速模数转换器(ADC)，干净的低抖动采样时钟是必不可少的构建模块。为使带内噪声最小，应选择较低的N值；但为使杂散噪声最小，最好选择整数N值。时钟往往是固定频率，因此可以选择频率以确保REFIN频率恰好是输入频率的整数倍。这样可以保证PLL带内噪声最低。选择VCO（无论集成与否）时，须确保其噪声对应用而言足够低，尤其要注意宽带噪声。然后需要精心放置低通滤波器，以确保带内PLL噪声与VCO噪声相交——这样可确保均方根抖动最低。相位裕度为60°的低通滤波器可确保滤波器峰值最低，从而较大限度地减少抖动。这样的话，低抖动时钟就落在本文讨论的第一个电路的时钟净化应用和所讨论的最后一个电路的快速开关能力之间。\n对于时钟电路，时钟的均方根抖动是关键性能参数。这可以利用ADIsimPLL估算，或使用信号源分析仪测量。对于像ADF5356这样的高性能PLL器件，相对较宽的低通滤波器带宽(132kHz)，配合WenxelOCXO之类的超低REFIN源，允许用户设计均方根抖动低于90fs的时钟（图26）。操纵PLL环路滤波器带宽(LBW)的位置表明，如果降低太多，VCO噪声在偏移较小时（图24）将开始占主导地位，带内PLL噪声实际上会降低，而如果提高太多的话，带内噪声在偏移处占主导地位，VCO噪声则显著降低（图25）。\n\n\n图24. LBW &#x3D; 10 kHz，331 fs抖动\n图25. LBW &#x3D; 500 kHz，111 fs抖动\n图26. LBW &#x3D; 132 kHz，83 fs抖动\n\n\n参考电路Collins, Ian. “用于无线应用的集成PLL和VCO.” Radio Electronics, 2010年。\nCurtin, Mike and Paul O’Brien. “用于高频接收器和发射器的锁相环。” 《模拟对话》，第33卷，1999年。\n作者Ian Collins毕业于爱尔兰科克大学，拥有电气和电子工程学位并从2000年起在ADI公司的射频和微波部工作。他目前是微波频率生成部的应用经理，主要负责锁相环(PLL)和压控振荡器(VCO)产品方面的工作。非工作时间或不陪伴家人时，Ian喜欢摄影和戏剧（无论是在台上还是在台下）、阅读以及听音乐。\n"},{"title":"阻抗匹配","url":"/2024/02/18/%E9%98%BB%E6%8A%97%E5%8C%B9%E9%85%8D/","content":"\n本人非专业领域工作者，内容难免瑕疵，所以仅供参考。\n\n什么是阻抗匹配？阻抗匹配的概念应用在各个工程领域，但在射频电路领域，阻抗匹配有更加重要的意义。阻抗匹配的目的在于将能量完整的从一个端口传输到另一个端口上，当负载的输入阻抗和源的输出阻抗共轭相等时则认为阻抗匹配。当源和负载的阻抗不相等时，可以在其之间插入一个无源网络进行阻抗转换，使得源和负载之间达到阻抗匹配的要求。\n什么是阻抗？阻抗是一个表征电路特性的一个重要参数，通常定义为电路在给定频率下对交流电的总阻抗。它是一个矢量值，实数部分可以理解为一般的电阻，虚数部分为电抗，电抗是由电容或电感导致的。这里说一下电容和电感的阻抗计算公式，对于电感来说：\n对于电容来说：\n电阻、电容和电感串并联后的阻抗值计算方法仍然同初中时学习的电阻串并联规则类似，只是将实数替换为了复数。\n和串联的总阻抗为。\n和并联的总阻抗为，并满足关系。为了方便表述可以记为\n说到阻抗可以顺便说一下Q值，这里主要是说电感电容的Q值，也就是元件的品质因数。由于实际的电容和电感存在ESR，所以实际的元件电抗不纯。为了表征元件电抗的纯粹程度，使用Q值来表示，其值为：\n对于源阻抗和负载阻抗，其满足匹配的要求是，即阻抗共轭相等。\n电抗计算器\n\n\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    电感:    \n    \n        nH\n        uH\n        mH\n        H\n    \n    感抗:    Ω \n    计算\n\n\n\n\n\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    电容:    \n    \n        pF\n        nF\n        uF\n        mF\n        F\n    \n    容抗:    Ω \n    计算\n\n\n\n\n阻抗并联计算器\n    阻抗A:    \n    阻抗B:    \n    并联阻抗:    Ω \n    计算\n\n\n阻抗匹配的方法如果源端口的阻抗和负载的阻抗不一致，会导致能量无法最大化的传输，为了使能量最大化的传输，在源和负载之间插入一个无耗匹配网络来使得源阻抗和匹配网络的输入端匹配，匹配网络的输出端和负载匹配，这样就间接使得源和负载达成匹配条件。\n这里看一个一般情况，就是常见的L型匹配网络：\n\n\nL型匹配\n\n\n其中源阻抗为，负载阻抗是，根据串并联规则，满足匹配的条件为：\n就是从负载点开始，串联元件就是相加，并联元件就是并联计算。复杂的匹配网络仍然遵循该规则。\n通常L型匹配网络的Q值较差，更复杂的Pi型匹配和T型匹配可以获得更高的Q值，但是计算会更加复杂，但计算原理是一致的。\n匹配网络中可以使用电阻元件，但是使用电阻会导致匹配网络带来插入损耗，因为电阻会消耗能量，而电感和电容不会消耗能量。使用电阻进行匹配仍然满足上述的串并联计算公式。\n通过匹配条件方程来解算L和C的值是非常麻烦的，更推荐的方法是使用一些现成的工具进行计算，如Smith工具和ADS仿真软件等。\nLC巴伦前面提到了LC匹配网络，这里再顺带说一下LC巴伦，这也是射频电路中常见到的。\n\n\n4 element balun\n\n\n该电路的解为：为了使得L和C具有实数解，通常LC巴伦两端的阻抗都为实数阻抗，或者保证根号内为实数即可。如果为复数，但是为实数，可以考虑再前串联电感、电容或者LC网络来进行阻抗转换。\n相关的计算工具有AppCAD。\n4元件实数LC巴伦设计\n    频率:    \n    \n        Hz\n        kHz\n        MHz\n        GHz\n    \n    ZL:    Ω\n    Zs:    Ω\n    计算\n    电感:   \n    电容:   \n\n\n\ninput{\n    width: 230px;\n    height: 30px;\n    border: 1px solid #D4D6D9;\n    border-radius: 4px;\n    padding-left: 8px;\n    padding-right: 8px;\n    box-sizing: border-box;\n}\ninput:disabled{\n    background-color: #E6E8EB;\n}\nselect{\n    width: 76px;\n    height: 30px;\n    border: 1px solid #D4D6D9;\n    border-radius: 4px;\n    padding-left: 8px;\n    padding-right: 8px;\n    box-sizing: border-box;\n}\nbutton{\n    width: 76px;\n    height: 32px;\n    line-height: 32px;\n    text-align: center;\n    box-sizing: border-box;\n    color: #fff;\n    background-color: #2F51FF;\n    border-radius: 4px;\n    border: none;\n}\n\n\n\n\n    function calc_ind(){\n        var freq = $(\"#ind_freq\").val() * $(\"#ind_freq_unit\").val()\n        var value = $(\"#ind_value\").val() / $(\"#ind_value_unit\").val()\n        var ret = 2 * Math.PI * freq * value\n        $(\"#ind_result\").val(ret.toFixed(3))\n    }\n    function calc_cap(){\n        var freq = $(\"#cap_freq\").val() * $(\"#cap_freq_unit\").val()\n        var value = $(\"#cap_value\").val() / $(\"#cap_value_unit\").val()\n        var ret = -1/(2 * Math.PI * freq * value)\n        $(\"#cap_result\").val(ret.toFixed(3))\n    }\n    function complex_add(a, b){\n        return [a[0] + b[0], a[1] + b[1]]\n    }\n    function complex_mul(a, b){\n        return [a[0] * b[0] - a[1]*b[1], a[0]*b[1]+a[1]*b[0]];\n    }\n    function complex_conjugate(a){\n        return [a[0], -a[1]]\n    }\n    function complex_div(a, b){\n        var p = complex_mul(b, complex_conjugate(b));\n        if(p[0] == 0){\n            return [0, 0];\n        }\n        var m = complex_mul(a, complex_conjugate(b));\n        return [m[0] / p[0], m[1] / p[0]];\n    }\n    function calc_parallel(){\n        var a = $(\"#imp_a\").val();\n        var b = $(\"#imp_b\").val();\n        var as = a.split(/\\+|\\-/);\n        var bs = b.split(/\\+|\\-/);\n        var a_real = Number(as[0]);\n        var a_imag = 0;\n        if(as.length > 1){\n            a_imag = Number(as[1].substring(1))\n            if(a[a.indexOf('j')-1] == '-'){\n                a_imag = -a_imag\n            }\n        }\n        var b_real = Number(bs[0]);\n        var b_imag = 0;\n        if(bs.length > 1){\n            b_imag = Number(bs[1].substring(1))\n            if(b[b.indexOf('j')-1] == '-'){\n                b_imag = -b_imag\n            }\n        }\n        var pa = [a_real, a_imag]\n        var pb = [b_real, b_imag]\n        var ans = complex_div(complex_mul(pa, pb), complex_add(pa, pb));\n        var flag = \"+\";\n        if(ans[1] < 0){\n            flag = \"-\";\n            ans[1] = -ans[1]\n        }\n        $(\"#imp_pra\").val(ans[0].toFixed(3).toString(10) + flag + \"j\" + ans[1].toFixed(3).toString(10))\n    }\n    function calc_balun(){\n        var zs = $(\"#balun_Zs\").val();\n        var zl = $(\"#balun_Zl\").val();\n        var freq = $(\"#balun_freq\").val() * $(\"#balun_freq_unit\").val()\n        var tmp = Math.sqrt(1.0 * zs * zl);\n        var cap = 1 / tmp / (2 * Math.PI * freq);\n        var cap_unit = 0;\n        while(cap > 0 && cap < 1 && cap_unit < 5){\n            cap = cap * 1000;\n            cap_unit = cap_unit + 1;\n        }\n        var cu = \"F\";\n        if(cap_unit == 0) cu = \"F\";\n        else if(cap_unit == 1) cu = \"mF\";\n        else if(cap_unit == 2) cu = \"uF\";\n        else if(cap_unit == 3) cu = \"nF\";\n        else if(cap_unit == 4) cu = \"pF\";\n        else if(cap_unit == 5) cu = \"fF\";\n        else cu = \"\"\n        var ind = tmp / (2 * Math.PI * freq);\n        var ind_unit = 0;\n        while(ind > 0 && ind < 1 && ind_unit < 3){\n            ind = ind * 1000;\n            ind_unit = ind_unit + 1;\n        }\n        var iu = \"\";\n        if(ind_unit == 0) iu = \"H\";\n        else if(ind_unit == 1) iu = \"mH\";\n        else if(ind_unit == 2) iu = \"uH\";\n        else if(ind_unit == 3) iu = \"nH\";\n        else iu = \"\"\n        $(\"#balun_L_value\").val(ind.toFixed(3).toString(10) + iu)\n        $(\"#balun_C_value\").val(cap.toFixed(3).toString(10) + cu)\n    }\n\n"},{"title":"从SHA204A思考关于嵌入式固件加密的问题","url":"/2025/10/27/%E4%BB%8ESHA204A%E6%80%9D%E8%80%83%E5%85%B3%E4%BA%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9B%BA%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%9A%84%E9%97%AE%E9%A2%98/","content":"从SHA204A思考关于嵌入式固件加密的问题前段时间在家整理东西时，发现一枚未使用的 SOP-8 封装芯片 —— 没有包装，也无其他信息，仅用一块泡沫加透明胶带包裹着。通过查看芯片丝印我才想起，这是几年前购入的加密芯片 ATSHA204A。\n当时因项目需求买入这款芯片，本打算用于相关功能测试，却因某些原因最终未能用上，便被我遗忘了。本着不浪费的原则，也为了学习这款芯片的用法及固件加密的工作原理，我决定花些时间测试其功能。\n此前我在一块开发板上找到了合适的测试位置，上面恰好预留了一个 SOP-8 封装的焊盘，且已连接至 STM32H7 的硬件 IIC 接口。因此，我无需花费过多时间搭建硬件测试环境。\n在 GitHub 上很容易找到该芯片的相关驱动代码，我没有选用官方代码库 —— 其体积过于庞大。我采用了网友移植的驱动，核心文件仅两三个，移植起来十分便捷。不过在具体移植过程中仍遇到了一些问题，主要是 MCU 主频不一致导致的通讯超时问题，做些适配调整即可解决。\nSHA204A 芯片实际提供的是一种校验机制，用于判定硬件是否为克隆版本，其本身并不具备固件加密功能。使用时，需先向 SHA204A 芯片写入不可读取的密钥，之后主机 MCU 通过校验该密钥，判断 SHA204A 是否为克隆版。即便攻击者能克隆整个电路板（包括 MCU 内的固件），但由于 SHA204A 内未写入正确密钥，MCU 仍能检测出异常。\nSHA204A 芯片会通过 SHA256 算法计算内部密钥的哈希值，MCU 端则用相同的 SHA256 算法对同一密钥计算哈希值，若两者一致则判定校验通过。由于 MCU 与 SHA204A 芯片的通讯过程可能被捕获，为避免通讯层面的重放攻击，主机 MCU 可向 SHA204A 芯片提供一个随机数（challenge），实际计算的哈希值为 SHA256（key + challenge）。这样一来，即便密钥固定不变，每次计算的哈希值也会不同。\n更进一步，若主机 MCU 没有安全的随机数发生器，搭配 NONCE 指令同样能避免重放攻击。具体流程为：主机先写入一个随机数（challenge，即便安全性不足也可），此时芯片内部会生成一个安全性极高的随机数（random）并返回给主机 MCU；芯片内部同时计算 token &#x3D; SHA256（challenge + random），该 token 主机无法访问；随后 SHA204A 芯片进一步计算哈希值 &#x3D; SHA256（key + token）；MCU 端则用相同算法计算哈希值。这种方式虽流程更复杂，但能进一步提升安全性。\n写到这里，我已基本理解该芯片的工作机制（滚动密钥等其他功能未进一步探索）。但该芯片能否成为硬件防克隆的可靠保障呢？这需要一个关键前提：MCU 内的固件需确保不被读取。若 MCU 固件被提取，意味着 MCU 侧存储的密钥存在泄露风险；一旦密钥泄露，SHA204A 的校验机制便会完全失效。\n为何会存在这种风险？本质上是对称加密导致的问题：SHA204A 芯片与 MCU 内运行相同的加密算法、使用相同的密钥。这意味着，只要 MCU 内的信息泄露，整个系统就会被破解。因此，我们需要一种非对称加密机制来保障系统安全性 —— 加密芯片与 MCU 分别存储私钥和公钥，即便公钥泄露，也能确保系统安全。\nSHA204A 的后续同类产品中，已有支持非对称加密的型号。以 ATECC608B 为例，它在兼容 ATSHA204A 的基础上，新增了密钥生成、密钥交换算法、签名与验签算法等非对称加密指令。但将其用于设备防克隆时，我认为仍存在应用缺陷：它无法写入自定义私钥，只能在芯片内部随机生成新私钥，再读取公钥。而我的设备需要批量生产，为保证设备固件的统一性，加密芯片内部的私钥最好能统一且由用户自行写入。\n这类验证机制有哪些应用场景呢？目前多数 MCU 的 Flash 都具备读写保护机制，在这类场景下，可能无需额外使用独立加密芯片；但对于 Flash 外置的 MCU，加密芯片仍有其用武之地。以 RP2040 为例，该芯片本身不具备安全启动功能，用 RP2040 量产的设备，其固件存在被破解的风险。\n最新的 RP2350 芯片新增了安全启动功能：通过 ECC 验签机制确保固件不被篡改，同时通过自定义 Bootloader 实现固件的 AES 加密。但该方案需将固件解密后加载到 SRAM 中运行，由于 SRAM 空间有限，对于固件体积较大的软件而言，此方案仍不适用。此时，搭配使用外置加密芯片或许是更优选择。\n不过，外置加密芯片并非防止固件克隆的绝对安全方案：一旦固件被破解，攻击者可通过逆向固件、篡改关键代码执行流程，直接绕过外置加密芯片。尽管逆向固件的难度极高，但面对高价值设备，逆向其固件仍有利可图，因此风险依然存在。\n行业内是否存在较好且通用的嵌入式固件防克隆解决方案呢？\n由于我在这一领域接触有限，但我认为，在嵌入式场景下，几乎不存在完全通用的解决方案。防止固件克隆需要从软件、硬件多个层面综合实施防御策略：\n\n物理不可克隆，避免固件被恶意提取。例如开启 Flash 读写保护、关闭调试接口等；\n\n若无法避免固件被提取，则需确保固件全流程加密 —— 包括固件的部署、更新、执行环节，均需保护原始固件信息不被泄露；\n\n安全启动与可信执行。固件全流程加密的前提是具备安全启动环境，在不可信环境中解密并执行固件，会存在信息泄露风险；\n\n良好的软件设计。部分设计缺陷可能导致攻击者通过任意代码执行，进而 dump 出全部固件内容。\n\n\n"}]
[{"title":"ARM嵌入式开发中的栈回溯机制","url":"/2021/06/01/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%A0%88%E5%9B%9E%E6%BA%AF%E6%9C%BA%E5%88%B6/","content":"两种ABI规范根据编译器的实现不同，存在两种ABI机制，分别为APCS(ARM Procedure Call Standard)和AAPCS(ARM Archtecture Procedure Call Standard)。两种机制存在明显的区别，且单独APCS和AAPCS又有很多变种，这里就不详细展开叙述其本质。本文主要讨论分析栈帧相关的内容，所以这里仅仅介绍这两种ABI机制下栈帧的区别。\nAPCS规范下函数调用和栈帧相关寄存器APCS中规定了几个别名寄存器，分别是fp、ip、sp、lr、pc寄存器，它们实际对应的寄存器及含有有下表：\n\n\n\nAPCS\nReg\n意义\n\n\n\nfp\nr11\n栈帧指针寄存器\n\n\nip\nr12\n临时变量寄存器\n\n\nsp\nr13\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧函数调用入口处将pc、lr、sp、fp寄存器依次入栈。入栈前先将sp保存到ip，入栈后再将ip的值给fp，这样fp的值就是当前栈帧的起始位置。后续如果需要使用局部变量，就将sp减一个值实现在栈空间上开辟局部变量的空间。函数退出前将sp寄存器处理到堆栈平衡状态，再通过fp寄存器找到当前函数的栈帧位置，通过栈帧找到返回函数的fp寄存器和sp寄存器、lr寄存器。简要的代码如下：\n&lt;func1&gt;:mov ip, sppush &#123;fp, ip, lr, pc&#125;sub fp, ip, #4sub sp, sp, #8      ;8 字节局部变量空间;...sub sp, fp, #12ldm sp, &#123;fp, sp, pc&#125;\n通过分析栈帧格式我们能够知道在函数任意位置，都能够通过fp寄存器找到当前栈帧位置，而不必考虑当前使用了多少局部变量空间，栈帧中能够得到当前函数的返回地址(lr)，当前运行地址(pc)，栈地址(sp)，同时根据栈帧中上一个函数的fp寄存器再找到上一层函数的栈帧数据，这样层层回溯就实现了栈的回溯。\n如何使用APCSgcc手册上对使用APCS有相关的描述和控制选项，-mapcs-frame选项编译出来的代码就是使用APCS规范，默认情况是-mno-apcs-frame，关于这个选项的描述GCC手册原文是：\nGenerate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying -fomit-frame-pointer with this option causes the stack frames not to be generated for leaf functions. The default is -mno-apcs-frame. This option is deprecated.\n这里说明了使用相关选项可以保证APCS的栈帧格式，如果不适用这个选项则不保证。APCS为1993年推出的标准，在后续推出AAPCS相关版本后它已经显得太旧了。在gcc5.0之后，该选项已经被遗弃，所以新版本的编译器已经不能使用APCS调用方式进行栈回溯。\nAAPCS下函数的调用相关寄存器AAPCS相比于APCS少了几个别名寄存器。它有sp、lr、pc寄存器，对应表如下：\n\n\n\nAPCS\nReg\n意义\n\n\n\nsp\nr13(ARM)/r7(THUMB)\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧在这种调用规范下，栈的回溯要比APCS下要复杂的多，函数的调用过程中不保存栈帧的指针，而且栈帧中也没有固定的格式，所以不能通过当前的栈帧层层返回数据。所以仅仅通过堆栈数据是不能进行栈回溯的。那么这种模式下如何保证堆栈平衡，能不能通过汇编代码的堆栈平衡实现栈回溯呢？通过前面我们知道APCS模式下函数进入到退出时的堆栈平衡时通过保存sp寄存器和恢复sp寄存器实现的。而AAPCS模式下堆栈平衡是直接依靠pop和push平衡实现的，即不会直接修改sp来实现堆栈平衡。通过前面的分析，如果我们能够准确知道每个函数关于栈的操作，这样也能够实现栈的跟踪。通过适当的编译选项，我们能够将这部信息收集到一起，这就是arm exception handler index，简称ARM.exidx，这段数据就能指导我们实现栈回溯，把这种栈回溯方式称为unwind。\nARM.exidx位置和结构不同的编译器如何编译出exidx表具有不同的方式，但是如果可执行文件中包括exidx表，那么使用readelf -S file.elf 能够看到可执行文件中存在一个名为.ARM.exidx，类型为ARM_EXIDX的段。这就表示编译器已经生产的exidx段。关于exidx的结构及其含义这里做一个简单介绍，详细信息可以参考ARM官方网站。exidx是一个由多个相同单元组成的表，每个单元由两个uint32_t的数据构成，结构类似于：\nstruct &#123;    uint32_t offset;    uint32_t world;&#125;\n其中offset表示目标函数到当前位置的偏移，它的最高位固定为0。而world中存放了编码数据，它表示了对栈的不同操作，通过操作它就能够知道目标函数上关于栈的操作。\nLinux中的栈回溯Linux中关于ARM架构的栈回溯就是使用的exidx表实现的，这里以linux5.3版本内核中关于unwind frame的代码进行演示。涉及的主要代码文件有arch/arm/kernel/unwind.c arch/arm/include/asm/unwind.h arch/arm/include/asm/ptrace.h stacktrace.h等。主要将unwind.c移植到我们的嵌入式平台就能够使用unwind栈回溯了。\n代码移植由于linux中存在内核空间和用户空间，两种空间下存在各种的exidx表，而通常我们的代码没有所谓的两个地址空间。所以需要将涉及到地址空间判断的全部判断为是否为代码空间段，linux对于用户空间段的exidx表是通过链表由用户手动添加的，内核段的exidx表是直接由编译符号完成的。其他的代码修改主要是涉及到Linux平台特性的。下面介绍的相关修改都是基于gcc编译器(ver&gt;5.0)实现的。\n\n1.实现两个关键的函数： #define core_kernel_text(addr)    ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)#define kernel_text_address(addr) ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)\n2.添加日志输出的相关接口，主要就是两个，其中pr_debug日志可以选择不输出。 #define pr_debug(...) printf(__VA_ARGS__)#define pr_warn(...)  printf(__VA_ARGS__)\n3.关于分支预测的代码，可能在某些arm平台下不支持分支预测，所以这里的移植就把这个特性关闭掉。 #define likely(c)   (c)#define unlikely(c) (c)\n4.字节对齐函数，用于把某个数据按多少字节对齐。 #define ALIGN(x,a) (((x)+(a)-1)&amp;~(a-1))\n5.内存操作的相关接口，这里其实并不会使用到内存相关申请，它只是在添加用户空间exidx表时才使用，而我们的嵌入式平台上是显然是用不到的。 #define kmalloc(size, flag)  malloc(size)#define kfree(ptr)           free(ptr)\n6.exidx表的位置，不同的编译器在链接脚本中关于exidx表的起始终止位置的描述可能不一样，这里需要重新定义一下。 #define __start_unwind_idx __exidx_start#define __stop_unwind_idx  __exidx_end\n7.实现获取关键寄存器的操作，主要是获取sp寄存器，如果不是在gcc编译器中，还需要实现获取lr寄存器和sp寄存器 register char * stack_ptr asm(&quot;sp&quot;);#define current_stack_pointer ((unsigned long) stack_ptr)\n8.linux中针对部分代码使用了spinlock进行保护，在我们的嵌入式平台上通常是不需要的，当然如果有必要可以进行选择性的实现类似spinlock的操作。\n9.关于代码是arm模式还是thumb模式，如果代码是thumb模式，还需要定义一个宏，他将决定fp寄存器是r7还是r11 #define CONFIG_THUMB2_KERNEL\n10.对于.h文件，主要是是保留unwind.h文件，删除其中不相干的代码，其他头文件中可能只是会引用部分数据和数据结构可以直接拷贝到unwind.h文件中。\n11.可以选择是否保留关于添加unwind_table的相关函数，这些函数通常不会使用。\n\n除了上述代码的移植外，编译时需要开启-funwind-tables选项，使编译器能够正常生产exidx段。在连接时要保证链接脚本中有存放exidx段的位置，以及预留出索引exidx段的起止符号，类似这样的链接脚本：\n.ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH.ARM : &#123;  __exidx_start &#x3D; .;  *(.ARM.exidx*)  __exidx_end &#x3D; .;&#125; &gt;FLASH\n将代码移植到ARMCC编译器中keil作为一个应用在嵌入式开发领域的一个重要软件，如果能够将这个功能应用到ARMCC编译器环境下，那这个功能将显得更加具有现实意义。前面的移植主要是在gcc编译平台下完成的，下面介绍如何将这段代码和功能移植到ARMCC编译平台下。\n\n1.编译环境相关的设置 要使编译器能够正常编译出代码exidx数据段的代码需要开启特别的选项 –exceptions –exceptions-unwind，它的意义是开启异常处理机制，因为最初exidx段设计来就是用于处理类型c++中的异常机制的。在开启了这些选项后编译出的代码就会包含exidx段，可以使用指令进行检验查看，如readelf -S main.o，其中就能够看到相关的数据段。当然不同的文件中的exidx段还没有链接到一起，要把它们链接到一起还比较麻烦。 由于ARMCC的优化策略，未使用的数据段都会在链接阶段被优化掉，而我们由不能直接使用到exidx中的数据(没有相关的符号指向这里)，所以正常情况下，即使开启的前面的编译选项，最终编译出来的文件也没有任何区别。在链接阶段添加选项–keep *(.ARM.exidx)，这个选项的意思就是在链接时保留exidx段(注意.ARM.exidx是exidx段的标准名称，前面没有提到，不同的编译器编译出来都是这个段名，且段类型都是未ARM_EXIDX)，这样链接出来的文件可以发现会比未加这个选项的文件大了些，这就新增的exidx段数据导致的。 但是这时候还是存在一个问题，编译出的文件包含了exidx段的数据，但是却没在我们想要的地方，或者说没没办法确定这段数据在哪儿。readelf -S能够看到段的结构没有增加，而ER_IROM1段的数据变多了，这就说明exidx段的数据与代码数据放入了同一个段，这显然不是我们想要的。 修改分散加载文件，在链接选项中指定使用自定义分散加载文件。我们起始可以看到原sct文件的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address &#x3D; execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n 我们在这里添加exidx段的声明后的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address &#x3D; execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    ER_EXIDX +0 0x00020000 &#123;        .ANY (.ARM.exidx)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n 经过对编译器链接器的设置，我们终于将exidx段的数据放到了期望的地方，在编译器中使用符号Image$$ER_EXIDX$$Base和Image$$ER_EXIDX$$Limit就能访问到exidx段的数据(编译器特性)。\n2.处理完成了编译器的相关内容，还需要修改源代码以适应ARMCC编译器，需要修改的地方主要体现在使用到了gcc内建函数的地方，以及gcc支持的一些拓展语法上，具体如何修改这里不做详细的介绍了。以上包括gcc和keil平台下的移植都经过测试，能够非常准确的回溯函数的调用链，包括在使用函数指针的地方都能进行准确的回溯，对于分析软件bug具有一定的帮助。\n\n技术参考本文中所设计到的内容主要来自于ARM官方的技术文档库，GCC编译手册，Linux内核源码等。可自行检索参考。\n"},{"title":"FreeRTOS上实现swap机制","url":"/2022/08/11/FreeRTOS%E4%B8%8A%E5%AE%9E%E7%8E%B0swap%E6%9C%BA%E5%88%B6/","content":"为什么需要引入SWAP机制在小容量SRAM的单片机上使用RTOS是一种很尴尬的事情，因为每个任务都需要分配独立的线程栈，栈空间少则512字节，复杂任务的栈空间则达到了几千字节的大小，这对于仅有8k字节SRAM的单片机来说显得压力太大了，两三个任务就导致内存不足。\n使用协程方案在在小容量单片机上是一个不错的方案，但是协程相比于实时操作系统具有很多的缺点。比如任务实时性不足、在用法上不灵活等。\n根据现代操作系统的SWAP机制，我在FreeRTOS操作系统上也实现了任务栈的swap机制，通过外部存储设备扩展单片机内的可用栈空间大小，可显著降低片内SRAM空间的消耗。同时该方案对任务来说是无感的，也就是说它和普通任务一样在用法上没有区别，可以按照传统的RTOS任务进行设计，这对于任务的移植来说能够降低复杂性。\n方案介绍使用SWAP机制一个重要前提是需要一个大容量的片外存储设备来进行内存交换。比如说片外的PSRAM，通过SPI总线访问的那种。一个基本的设想是先分配一段实际的物理空间，这将作为所有线程的栈空间，线程A在使用完这段空间后，切换到线程B时，先将线程A的栈空间数据存放到外部分配的SWAP空间上，同时将线程B保存在外部SWAP空间上的栈数据恢复到共享的栈空间上。通过预留在FreeRTOS内的HOOK接口很容易就能实现这些功能，且对FreeRTOS的原有代码没有明显的入侵。\n具体实现的要点\n1.任务创建为了指定任务运行时实际的栈空间地址，使得栈空间数据可控，需要使用xTaskCreateStatic()接口创建任务。此外，创建任务时会对栈空间数据进行必要的初始化操作，所有创建任务时的上下文栈空间不能处于共享栈空间上，否则会出现数据冲突。任务的删除也需要特别设计，任务删除仅仅需要删除分配的TCB块空间，栈空间不会收，但是需要释放外部分配的SWAP空间。\n\n2.任务切换时栈空间存储将当前任务的栈空间存储到SWAP空间时，没有必要将整个栈空间都进行存储，因为栈的使用是线性连续的，通常使用栈底的部分数据，所以仅需保存部分数据到SWAP空间即可，这样可以提升线程的切换速度。在任务切换时还需要做适当的判断，避免无效的栈空间交换。我们仅仅需要在从一个共享栈任务切换到另一个共享栈任务时需要触发SWAP机制，其它情况都不需要进行内存交换。例如，Tiemr线程的栈时独立分配的，那么从timer切换到共享栈任务A在切换到timer过程中，显然都是不需要进行栈交换的。可以使用traceTASK_SWITCHED_IN()作为内存交换点。\n\n3.SWAP存储作为栈的交换存储空间，读写速度是非常关键的，将一次栈切换的时间控制在1ms以内时非常有必要的。所有内存交换的机制应当尽量设计的简单可靠，避免使用文件等复杂的存储过程。存储空间的大小和访问方式也很关键，最好是字符设备，块设备的读写在这里是低效的。存储空间应当能够覆盖所有共享的内存数据以及管理这些数据的额外数据开销。\n\n\n方案测试我选择了STM32L051C8T6单片机(8k字节SRAM)配合APS6404L片外的PSRAM进行测试，PSRAM使用16Mhz的SPI总线连接。创建了Timer任务、IDLE任务和一个普通的用户任务，这三个任务使用了独立的栈空间分配，分别为512、512、1024字节。此外还分配了3个栈空间共享的任务，栈空间大小均为1024字节。在这种情况下，所有任务运行起来后FreeRTOS的heap剩余空间仍然超过了1k。额外创建一个栈空间共享的任务开销约100字节左右。\n缺陷\n无法在栈共享任务上创建一个新的栈共享任务，这个在实现要点1上已经解释了。\n任务栈内的局部变量数据无法传递到栈外，这是特别关键的。通常栈内的数据通过邮箱等传递到其它线程后，通过阻塞的方式等待响应，所以该栈内的局部变量数据传递到其它线程后依然有效。但是对于栈共享的任务来说是无法实现的。\n栈共享的任务实时性无法得到保障，因为它在线程唤醒时需要进行栈空间的恢复操作，任务响应时间肯定比栈独立的任务要长。所有对于需要快速响应的任务任然可以使用一般的任务创建方式创建任务，因为从栈共享任务切换到一般任务是不需要触发SWAP机制的。\n\n"},{"title":"Exception Failure - Breaking the STM32F1 Read-Out Protection","url":"/2022/03/28/Exception%20Failure%20-%20Breaking%20the%20STM32F1%20Read-Out%20Protection/","content":"Marc Schink &amp; Johannes Obermaier Tuesday, 17 March 2020\n\nThe firmware of microcontrollers usually contains valuable data such as intellectual property and, in some cases, even cryptographic material. In order to protect the confidentiality of these assets, most microcontrollers feature some kind of firmware read-out protection. This security feature shall prevent adversaries with physical access to a device from reading out the internal flash memory. Nevertheless, security researchers as well as hobbyists showed repeatedly that these security features can be circumvented. In this research article, we examine the flash read-out protection (RDP) of the STM32F1 series from STMicroelectronics. We discuss a novelly discovered vulnerability whose exploitation would be the first non-invasive way to circumvent the feature. The issue results from an insufficient access restriction: flash data reads via the debug interface are blocked but the CPU’s exception handling process is still able to read from flash memory via the ICode bus. We explain in detail why and how this vulnerability exposes major parts of the internal memory, thereby affecting device security.\n\n\n\n\n\nIntroductionFor the protection of intellectual property and other sensitive data such as cryptographic material, securing the internal flash memory of a microcontroller is of utmost importance. If an attacker gains access to the firmware, they can clone the product, alter its functionality or extract security credentials. Thus, the hardening of microcontroller plays a major role in today’s embedded system security — not only for high-security devices but also for commercial microcontrollers.\nThe deactivation of the debug interface is one usual way to prevent adversaries from gaining access to the flash memory, however, the implementation differs between microcontrollers. For example, the debug interface of the STM32F0 series can be entirely switched off. In contrast, the STM32F1 series does not directly support this, but relies on another approach. One of its main security features is the flash memory read-out protection (RDP). This security feature blocks all data accesses to the flash memory via the debug interface once a debug probe is attached to the microcontroller. This means that an attacker is able to attach a debug probe to the microcontroller but cannot read out the flash memory content.\nHowever, research has shown for some microcontrollers that this protection mechanism is flawed. For the STM32F0 series, for instance, Johannes Obermaier and Stefan Tatschner presented an attack in Shedding too much Light on a Microcontroller’s Firmware Protection that is able to extract protected data from flash memory. Some researchers assumed that this vulnerability might also affect other series such as the STM32F1. However, one of the authors contradicted that the STM32F1 microcontroller family exhibits the same vulnerability in the debug interface. Until now, the flash read-out protection mechanism of the STM32F1 series was considered as being secure and there was no evidence that it can be circumvented. In this article, we discuss a vulnerability (CVE-2020-8004) that leads to the first non-invasive attack against the flash protection mechanism of the STM32F1 family.\nDiscovering the VulnerabilityThe STM32F1 series does not provide a feature to permanently disable the debug interface. For that reason, an attacker with physical access to the debug interface is always able to gain debug access to the microcontroller. However, the integrated flash read-out protection prevents any data access to the flash memory once a debug probe is attached to the microcontroller.\nIn order to examine the flash read-out protection feature, we use an STM32 Nucleo-64 development board with an STM32F103RB microcontroller. The read-out protection of the microcontroller is enabled which means that the flash memory is not accessible via the debug interface. The microcontroller is attached via the SWD debug interface to an external SEGGER J-Link debug probe, as depicted in Figure 1.\n\n\n Figure 1: STM32 Nucleo-64 development board with attached SEGGER J-Link debug probe.\n\n\nWe begin our examination by establishing a debug connection to the target microcontroller. For that, we start OpenOCD with the following command:\nopenocd -f interface/jlink.cfg -c &quot;transport select swd&quot; -f target/stm32f1x.cfg\nAfter that, we open a Telnet session on OpenOCD such that we can control the microcontroller. Finally, we perform a device reset with the command and get the following output in our Telnet session:reset halt\ntarget halted due to debug-request, current mode: ThreadxPSR: 0x01000000 pc: 0x08000268 msp: 0x20005000\nAt a first glance, there is nothing special with this output. However, when you take a closer look at the second line, especially one value should pop into your eyes: the program counter (PC) value is a valid address located in flash memory. This is of major importance because a reset is a special kind of exception. Every time an exception is generated, the processor loads the corresponding exception entry address from the vector table into the PC. This procedure is sometimes referred to as vector fetch. After a device reset, the vector table is located in flash memory. Hence, this observation implies that the processor fetches the reset vector from flash memory even though the read-out protection is enabled.0x08000268\nBut why is the exception entry process able to read the reset vector from flash memory? The STM32F1 reference manual provides a hint:\n\nThe Cortex®-M3 CPU always fetches the reset vector on the ICode bus, which implies to have the boot space available only in the code area (typically, Flash memory).\n\nThe reset vector is fetched via the ICode bus and thus handled like instruction fetches which are allowed despite the activated read-out protection. The read-out protection seems to take care of data accesses via the data bus (DCode bus) only and hence the reset vector can still be fetched over the ICode bus. The Cortex-M3 Technical Reference Manual provides additional information regarding vector fetches in general:\n\nThe vector fetch is performed over either the System bus or the ICode bus depending on where the vector table is located […]\n\nIn summary, the flash read-out protection of the STM32F1 does not block memory accesses via the ICode bus. Once an exception takes place, the corresponding entry address stored in flash memory is fetched through the ICode bus and thereby exposes the memory content through the PC.\nExploitationOur observation shows that once an exception takes place, the vector fetch exposes protected flash memory content through the PC. In this section, we discuss how this behaviour can be exploited to bypass the read-out protection of the STM32F1.\nWe already mentioned the vector table: it contains the initialization value of the main stack pointer (MSP) followed by an entry address for every exception. The vector table for microcontrollers based on the ARMv7-M architecture is shown in Table 1. The table lists the exceptions with their memory offset relative to the beginning of the vector table. The first 16 exceptions of the vector table are mandatory and specified by the ARMv7-M architecture. All other exceptions are so called external interrupts, they are optional and device specific.\n\n\n\n\n\nException number\nException\nOffset\n\n\n\n-\nMain stack pointer (MSP) initialization value\n0x0\n\n\n1\nReset\n0x4\n\n\n2\nNMI\n0x8\n\n\n3\nHardFault\n0xc\n\n\n4\nMemManage\n0x10\n\n\n5\nBusFault\n0x14\n\n\n6\nUsageFault\n0x18\n\n\n7-10\nReserved\n0x1c\n\n\n11\nSVCall\n0x20\n\n\n12\nDebugMonitor\n0x24\n\n\n13\nReserved\n0x28\n\n\n14\nPendSV\n0x2c\n\n\n15\nSysTick\n0x30\n\n\n16\nExternal Interrupt 0\n0x34\n\n\n…\n…\n…\n\n\n\n\nTable 1: Vector table for microcontrollers implementing the ARMv7-M architecture.\n\n\nThe basic exploitation idea is to deliberately generate exceptions such that the corresponding vector table entry is fetched from flash memory and exposed through the PC. However, Table 1 shows that some entries are reserved and are not mapped to an exception, namely the entries 7 to 10 and 13. Also needless to say, the initialization value for the MSP is not mapped to an exception. For that reason, the corresponding table entries cannot be extracted via this approach. We ignore this for the moment and address these limitations in more detail later in this article.\nVector Table OffsetAt this point, the following question may arise: why should I care about the confidentiality of the vector table content?\nIndeed, the content of the vector table is usually not confidential as it only contains the exception entry addresses. But note that the ARMv7-M architecture specifies a Vector Table Offset Register (VTOR) that determines the location of the vector table inside the address space. This feature is usually used to relocate the vector table when there are multiple applications on the microcontroller, for example, a bootloader and a main application. With that, both applications can have their own vector table and exception handlers. The crucial point here is again, that we have debug access to the entire device except for the flash memory. With help of the VTOR, we are able to relocate the vector table within the flash memory region and extract large amount of its data.\nIn order to use the vector table relocation, we split the flash memory into equally sized blocks of 32 words, as depicted in Figure 2. The block size is related to the vector table size and, as required by the ARMv7-M specification, must be a power of 2. For example, the STM32F103 has 59 exceptions and therefore the actual vector table size is 64. However, this means that we do not have enough exceptions to access all its table entries. For that reason, we use the largest possible vector table that fits in 59 which is 32.\n\n\nFigure 2: Relocation of the vector table within the flash memory. Inaccessible table entries are highlighted.\n\n\nThe seven highlighted memory words in Figure 2 cannot be extracted. The first two words are the initialization value for the MSP and the reset vector. The other words correspond to the reserved entries of the vector table. The MSP initialization value and the reset vector are special and can only be extracted when the vector table is located at the beginning the of the flash memory, its default location. The reason is that a device reset is necessary to extract these value, however, this also resets the VTOR and relocates the vector table to the beginning of the flash memory region.\nThese limitations can be reduced by using exceptions that exceed the vector table size. In this case, exceptions with a number greater than 31. According to section 4.4.4 of the STM32F1 programming manual, the vector table location must be aligned to the actual vector table size, 64 in case of the STM32F103. But what happens when our vector table is unaligned and we generate exceptions with numbers greater than the vector table size? It turns out that these exceptions are mapped to the beginning of the vector table. Figure 3 illustrates this wrap-around behaviour for an unaligned vector table with 32 entries. On the left-hand side, the regular vector table with its inaccessible entries highlighted is depicted. On the right-hand side, the figure shows how the wrap-around behaviour makes the inaccessible parts of the vector table accessible. The highlighted vector table entries are now accessible by exceptions that exceed the vector table size.\n\n\nFigure 3: Wrap-around behaviour of an unaligned vector table. Inaccessible entries (red) become accessible (blue) when an exception exceeds the table size.\n\n\nNote that in Figure 3, the focus is on the inaccessible parts of the vector table. The other entries can also be extracted via the wrap-around behaviour, however, this is not necessary since they can be extracted regularly. With the help of the wrap-around, we are now able to extract vector table entries that were reserved or inaccessible before. Even the first two entries which were only extractable when the vector table is located at the beginning of the flash memory region. The only limitation that remains is that we can use this approach only for unaligned vector tables. Nevertheless, we reduced the number of inaccessible memory words by a factor of two. Note that this approach is one way to make use of the additional external interrupts. We use this way because it is very convenient to implement.\nNow, we have almost everything we need to extract nearly arbitrary parts of the flash memory. In the next section, we describe the last missing piece: how to generate exceptions on purpose.\nException GenerationTo generate each individual exception for firmware extraction, we continue as follows. We need three steps to trigger an exception:\n\nPerform a device reset such that the microcontroller is in a defined state and to recover it from possible faults and lockups.\nConfigure the microcontroller such that the indented exception is pending.\nPerform a single step to make the pending exception active.\n\nThe Non-Maskable Interrupt (NMI), PendSV and SysTick exception can easily made pending by setting the corresponding bits , and respectively. These bits can be found in the Interrupt Control and State Register (ICSR). The same holds for the DebugMonitor exception which can be made pending by setting the bit in the Debug Exception and Monitor Control Register (DEMCR).NMIPENDSETPENDSVSETPENDSTSETMON_PEND\nFor example, the following OpenOCD commands makes the PendSV exception pending:\nmww 0xe000ed04 0x10000000\nSince the processor is in debug mode and halted, we need to give it the chance to execute the exception. For that, we use the command to execute only a single instruction. In order to avoid side-effects by the executed instruction, we execute a single instruction placed in SRAM at address .stepnop0x20000000\nmwh 0x20000000 0xbf00reg pc 0x20000000\nNote that it is necessary to disable interrupt masking. This feature is enabled by default and can be deactivated with the following command:\ncortex_m maskisr off\nThis command changes the single-stepping behaviour and controls the bit in the Debug Halting Control and Status Register (DHCSR). This bit determines whether PendSV, SysTick and all external interrupts shall be masked. By default, is set to auto which means that a command first allows pending interrupt handlers to execute and then steps over the desired instruction.C_MASKINTSmaskisrstep\nNote\nThe command is not available for so called high-level adapters (HLA) in OpenOCD. For that reason, we do not use the integrated ST-LINK debug probe of the Nucleo-64 development board.maskisr\nOnce an exception is generated, you may experience that there is a mismatch between the exception entry address in the vector table and the PC value. The least-significant bit (LSB) may be incorrect. The reason is that the LSB of the exception entry address is not loaded into the PC but used as Thumb state of the processor. Since the Thumb state is encoded in the Execution Program State Register (EPSR), we are able to recover the entire exception entry address by combining the PC and the Thumb state bit.\nWe have all building blocks required to extract vector table entries. In the following, we elaborate how to generate the remaining exceptions. For simplicity, we omit the first and last step of the exception generation process throughout the remainder of this article.\nBusFaultA BusFault exception occurs, for example, when a memory instruction accesses an invalid memory region. Hence, we can generate a BusFault by executing a load instruction that performs a read access on an invalid memory region.\nFor that, we place an into the SRAM at address and configure the base register and the PC accordingly:ldr r0, [r1, #0]0x20000000r1\nmwh 0x20000000 0x0868reg r1 0xf0000000reg pc 0x20000000\nThe address stored in is part of the vendor-specific memory region. In case of the STM32F1, this address is not mapped in the memory space. Therefore, every memory operation on this address is illegal and thus suitable to generate a BusFault exception. All other addresses that are not mapped work as well.0xf0000000r1\nBefore we are able to generate a BusFault exception, we need to enable it by setting the bit in the System Handler Control and State Register (SHCSR):BUSFAULTENA\nmww 0xe000ed24 0x20000\nThis step is necessary because otherwise priority escalation would take place and the processor would generate a HardFault exception instead of a BusFault.\nMemManageThe MemManage exception is generated whenever a memory protection fault occurs. Among others, this happens when the processor attempts to execute code in a memory region that is marked as eXecute Never (XN).\nIn order to cause a memory protection violation, we configure the processor such that it attempts to execute code on a memory region marked as XN. In our case, we chose the first address of the system memory address space which is at the address .0xe0000000\nreg pc 0xe0000000\nAs for the BusFault exception, the MemManage exception needs to be enabled. We do this by setting the bit in the SHCSR:MEMFAULTENA\nmww 0xe000ed24 0x10000\nUsageFaultUsageFault exceptions can occur for a variety of reasons. One reason is, for example, when an unaligned memory load or store operation is performed.\nHowever, the straightforward way is to execute an undefined instruction such as . We place this instruction in SRAM at address and configure the PC accordingly:0xffff0x20000000\nmwh 0x20000000 0xffffreg pc 0x20000000\nAs for the other exceptions, the UsageFault exception needs to be enabled. This can be done by setting the bit in the SHCSR:USGFAULTENA\nmww 0xe000ed24 0x40000\nHardFaultA HardFault is a generic fault that is generated whenever a fault cannot be handled by any other exception.\nThere are different means to generate a HardFault exception manually. A straightforward way is to generate one of the previously mentioned exceptions without enabling it. As explained before, this causes a priority escalation and the HardFault exception gets generated.\nSVCallA Supervisor Call (SVCall) is used by software to call the operating system. This exception is generated whenever the processor executes an instruction.svc\nWe generate this exception by placing an instruction in SRAM and execute it with a single step.svc #0\nmwh 0x20000000 0xdf00reg pc 0x20000000\nSince we are only interested in generating an SVCall exception, the immediate value is not important and can be arbitrarily chosen. In contrast to the former two exceptions, a supervisor call is permanently enabled.#imm\nExternal InterruptsThe Nested Vectored Interrupt Controller (NVIC) handles all the external interrupts. It provides two set of registers: one to enable external interrupts and a second one to make them pending. In order to trigger an external interrupt, we set the corresponding bits in both registers to enable the interrupt and make it pending. Every bit corresponds to an external interrupt.\nFor example, in case of the STM32F1 series, the first external interrupt is the window watchdog (WWDG) interrupt. In order to trigger this interrupt, we set the first bit in both registers:\nmww 0xe000e100 0x1mww 0xe000e200 0x1\nAll other external interrupts can be generated accordingly.\nThe number of external interrupts varies a lot among the different devices of the STM32F1 family. Additionally, the documentation is sometimes not accurate. For example, according to the STM32F1 reference manual, the external interrupts 43 to 49 of connectivity line devices are reserved. However, we found out that they can be generated like all the other interrupts. The importance of the available external interrupts will be seen in the next section.\nPerformanceThe amount of extractable memory content and the extraction speed are key indicators whether the identified vulnerability undermines the security of the read-out protection in field applications.\nIn order to asses the severity of this vulnerability, we implemented a Python script that generates exceptions in an automated fashion to extract firmware from a read-out protected microcontroller. We evaluated the presented attack on three different devices of the STM32F1 series. In all cases, we aimed to extract 128 KiB of flash memory from the devices. The evaluation results are listed in Table 2.\n\n\n\n\n\nDevice\nExternal interrupts\nExtraction time\n\n\n\nSTM32F100\n55\n48.8 min\n\n\nSTM32F103\n43\n48.2 min\n\n\nSTM32F107\n68\n51.0 min\n\n\nTable 2: Extraction time and coverage for three devices of the STM32F1 series.\n\n\nThe results show that the amount of flash memory that can be extracted correlates with number of external interrupts. The most data can be extracted from the STM32107 microcontroller with its 68 external interrupts. The table also shows that the extraction time slightly increases with the increasing amount of extracted data.\nWe used a SEGGER J-Link debug probe with an adapter speed of 3500 kHz for the performance evaluation. Note that the adapter speed of your debug probe is an important factor for the extraction time and might also be influenced by further factors in your setup, for example, your computer system.\nIn a nutshell, these results show that the attack is indeed practically feasible as it can be executed in reasonable time: in less than one hour.\nConclusionIn this article, we discussed a vulnerability in the flash read-out protection mechanism of the STM32F1 microcontroller series. We showed that the exploitation is non-invasive and requires only access to the microcontroller’s debug interface. Hence, this attack is clearly within the typical attacker models of flash readout protection mechanisms.\nThe presented attack has certain limitations and does not allow an attacker to read out the entire flash memory. However, depending on the device, an attacker is able to read out up to 94.5 percent of the flash memory content in less than an hour. For that reason, we consider this read-out protection mechanism as broken and we do not recommand to rely on this feature anymore. Since the STM32F1 series has no other firmware protection mechanism, the only way known to the authors to avoid exploitation and thus keep the entire flash memory content confidential is to physically prevent an attacker from gaining access to the debug interface.\nAvailabilityIn order to encourage discussions and make our research results comprehensible and replicable, we publish the source code that was developed during our research. The source code is licensed under the GPLv3+ and can be found on https://gitlab.zapb.de/zapb/stm32f1-firmware-extractor.\nCoordinated DisclosureThe publication of our findings was preceded by a coordinated vulnerability disclosure process. We informed STMicroelectronics more than 100 days prior to the publication of this article.\n\n28 November 2019: Technical details about the vulnerability and the disclosure timeline provided to STMicroelectronics.\n08 December 2019: No response from STMicroelectronics so far. Reminder with technical details and disclosure timeline.\n23 December 2019: Still no response from STMicroelectronics. Reminder without technical details.\n06 January 2020: Reminder from CERT Bund and immediate response from STMicroelectronics.\n10 January 2020: Conference call with STMicroelectronics and CERT Bund as mediator.\n15 January to 07 February 2020: Further discussions between STMicroelectronics and CERT Bund.\n01 February 2020: Public announcement of the vulnerability without technical details.\n17 March 2020: Publication of this article and supplementary materials.\n\nAbout the AuthorsMarc Schink and Johannes Obermaier are two embedded system security researchers with a background in computer science and electrical engineering. They focus especially on microcontrollers that both encounter in their everyday live. With their research and publications they aim at improving security by an open discussion about the strength of security features and wish for improvements.\n\nExcept where otherwise noted, content on this site is licensed under a Creative Commons BY-NC-SA 4.0 license.\n"},{"title":"Recommended C style and coding rules","url":"/2021/01/21/Recommended%20C%20style%20and%20coding%20rules/","content":"This document describes C code style used by Tilen MAJERLE in his projects and libraries.\nTable of Contents\nThe single most important rule\nRecommended C style and coding rules\nGeneral rules\nComments\nFunctions\nVariables\nStructures, enumerations, typedefs\nCompound statements\nSwitch statement\n\n\nMacros and preprocessor directives\nDocumentation\nHeader/source files\nArtistic Style configuration\nEclipse formatter\n\nThe single most important ruleLet’s start with the quote from GNOME developer site.\n\nThe single most important rule when writing code is this: check the surrounding code and try to imitate it.\nAs a maintainer it is dismaying to receive a patch that is obviously in a different coding style to the surrounding code. This is disrespectful, like someone tromping into a spotlessly-clean house with muddy shoes.\nSo, whatever this document recommends, if there is already written code and you are patching it, keep its current style consistent even if it is not your favorite style.\n\nGeneral rulesHere are listed most obvious and important general rules. Please check them carefully before you continue with other chapters.\n\nUse C99 standard\n\nDo not use tabs, use spaces instead\n\nUse 4 spaces per indent level\n\nUse 1 space between keyword and opening bracket\n\nDo not use space between function name and opening bracket\nint32_t a = sum(4, 3);              /* OK */int32_t a = sum (4, 3);             /* Wrong */\nNever use __ or _ prefix for variables/functions/macros/types. This is reserved for C language itself\n\nPrefer prv_ name prefix for strictly module-private functions\n\n\nUse only lowercase characters for variables/functions/macros/types with optional underscore _ char\n\nOpening curly bracket is always at the same line as keyword (for, while, do, switch, if, …)\nsize_t i;for (i = 0; i &lt; 5; ++i) &#123;           /* OK */&#125;for (i = 0; i &lt; 5; ++i)&#123;            /* Wrong */&#125;for (i = 0; i &lt; 5; ++i)             /* Wrong */&#123;&#125;\nUse single space before and after comparison and assignment operators\nint32_t a;a = 3 + 4;              /* OK */for (a = 0; a &lt; 5; ++a) /* OK */a=3+4;                  /* Wrong */a = 3+4;                /* Wrong */for (a=0;a&lt;5;++a)       /* Wrong */\nUse single space after every comma\nfunc_name(5, 4);        /* OK */func_name(4,3);         /* Wrong */\nDo not initialize static and global variables to 0 (or NULL), let compiler do it for you\nstatic int32_t a;       /* OK */static int32_t b = 4;   /* OK */static int32_t a = 0;   /* Wrong */voidmy_func(void) &#123;    static int32_t* ptr;/* OK */    static char abc = 0;/* Wrong */&#125;\nDeclare all local variables of the same type in the same line\nvoidmy_func(void) &#123;    char a;             /* OK */    char a, b;          /* OK */    char b;             /* Wrong, variable with char type already exists */&#125;\nDeclare local variables in order\n\nCustom structures and enumerations\nInteger types, wider unsigned type first\nSingle/Double floating pointintmy_func(void) &#123;    /* 1 */    my_struct_t my;     /* First custom structures */    my_struct_ptr_t* p; /* Pointers too */    /* 2 */    uint32_t a;    int32_t b;    uint16_t c;    int16_t g;    char h;    /* ... */    /* 3 */    double d;    float f;&#125;\n\n\nAlways declare local variables at the beginning of the block, before first executable statement\n\nDeclare counter variables in for loop\n/* OK */for (size_t i = 0; i &lt; 10; ++i)/* OK, if you need counter variable later */size_t i;for (i = 0; i &lt; 10; ++i) &#123;    if (...) &#123;        break;    &#125;&#125;if (i == 10) &#123;&#125;/* Wrong */size_t i;for (i = 0; i &lt; 10; ++i) ...\nAvoid variable assignment with function call in declaration, except for single variables\nvoida(void) &#123;    /* Avoid function calls when declaring variable */    int32_t a, b = sum(1, 2);    /* Use this */    int32_t a, b;    b = sum(1, 2);    /* This is ok */    uint8_t a = 3, b = 4;&#125;\nExcept char, float or double, always use types declared in stdint.h library, eg. uint8_t for unsigned 8-bit, etc.\n\nDo not use stdbool.h library. Use 1 or 0 for true or false respectively\n/* OK */uint8_t status;status = 0;/* Wrong */#include &lt;stdbool.h&gt;bool status = true;\nNever compare against true, eg. if (check_func() == 1), use if (check_func()) &#123; ... &#125;\n\nAlways compare pointers against NULL value\nvoid* ptr;/* ... *//* OK, compare against NULL */if (ptr == NULL || ptr != NULL) &#123;&#125;/* Wrong */if (ptr || !ptr) &#123;&#125;\nAlways use pre-increment (and decrement respectively) instead of post-increment (and decrement respectively)\nint32_t a = 0;...a++;            /* Wrong */++a;            /* OK */for (size_t j = 0; j &lt; 10; ++j) &#123;&#125;  /* OK */\nAlways use size_t for length or size variables\n\nAlways use const for pointer if function should not modify memory pointed to by pointer\n\nAlways use const for function parameter or variable, if it should not be modified\n/* When d could be modified, data pointed to by d could not be modified */voidmy_func(const void* d) &#123;&#125;/* When d and data pointed to by d both could not be modified */voidmy_func(const void* const d) &#123;&#125;/* Not required, it is advised */voidmy_func(const size_t len) &#123;&#125;/* When d should not be modified inside function, only data pointed to by d could be modified */voidmy_func(void* const d) &#123;&#125;\nWhen function may accept pointer of any type, always use void *, do not use uint8_t *\n\nFunction must take care of proper casting in implementation/* * To send data, function should not modify memory pointed to by `data` variable * thus `const` keyword is important * * To send generic data (or to write them to file) * any type may be passed for data, * thus use `void *` *//* OK example */voidsend_data(const void* data, size_t len) &#123; /* OK */    /* Do not cast `void *` or `const void *` */    const uint8_t* d = data;/* Function handles proper type for internal usage */&#125;voidsend_data(const void* data, int len) &#123;    /* Wrong, not not use int */&#125;\n\n\nAlways use brackets with sizeof operator\n\nNever use Variable Length Array (VLA). Use dynamic memory allocation instead with standard C malloc and free functions or if library/project provides custom memory allocation, use its implementation\n\nTake a look at LwMEM, custom memory management library/* OK */#include &lt;stdlib.h&gt;voidmy_func(size_t size) &#123;    int32_t* arr;    arr = malloc(sizeof(*arr) * n); /* OK, Allocate memory */    arr = malloc(sizeof *arr * n);  /* Wrong, brackets for sizeof operator are missing */    if (arr == NULL) &#123;        /* FAIL, no memory */    &#125;    free(arr);  /* Free memory after usage */&#125;/* Wrong */voidmy_func(size_t size) &#123;    int32_t arr[size];  /* Wrong, do not use VLA */&#125;\n\n\nAlways compare variable against zero, except if it is treated as boolean type\n\nNever compare boolean-treated variables against zero or one. Use NOT (!) instead\nsize_t length = 5;  /* Counter variable */uint8_t is_ok = 0;  /* Boolean-treated variable */if (length)         /* Wrong, length is not treated as boolean */if (length &gt; 0)     /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (length == 0)    /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (is_ok)          /* OK, variable is treated as boolean */if (!is_ok)         /* OK, -||- */if (is_ok == 1)     /* Wrong, never compare boolean variable against 1! */if (is_ok == 0)     /* Wrong, use ! for negative check */\nAlways use /* comment */ for comments, even for single-line comment\n\nAlways include check for C++ with extern keyword in header file\n\nEvery function must include doxygen-enabled comment, even if function is static\n\nUse English names/text for functions, variables, comments\n\nUse lowercase characters for variables\n\nUse underscore if variable contains multiple names, eg. force_redraw. Do not use forceRedraw\n\nNever cast function returning void *, eg. uint8_t* ptr = (uint8_t *)func_returning_void_ptr(); as void * is safely promoted to any other pointer type\n\nUse uint8_t* ptr = func_returning_void_ptr(); instead\n\n\nAlways use &lt; and &gt; for C Standard Library include files, eg. #include &lt;stdlib.h&gt;\n\nAlways use &quot;&quot; for custom libraries, eg. #include &quot;my_library.h&quot;\n\nWhen casting to pointer type, always align asterisk to type, eg. uint8_t* t = (uint8_t*)var_width_diff_type\n\nAlways respect code style already used in project or library\n\n\nComments\nComments starting with // are not allowed. Always use /* comment */, even for single-line comment\n//This is comment (wrong)/* This is comment (ok) */\nFor multi-line comments use space+asterisk for every line\n/* * This is multi-line comments, * written in 2 lines (ok) *//** * Wrong, use double-asterisk only for doxygen documentation *//** Single line comment without space before asterisk (wrong)*//* * Single line comment in multi-line configuration (wrong) *//* Single line comment (ok) */\nUse 12 indents (12 * 4 spaces) offset when commenting. If statement is larger than 12 indents, make comment 4-spaces aligned (examples below) to next available indent\nvoidmy_func(void) &#123;    char a, b;    a = call_func_returning_char_a(a);          /* This is comment with 12*4 spaces indent from beginning of line */    b = call_func_returning_char_a_but_func_name_is_very_long(a);   /* This is comment, aligned to 4-spaces indent */&#125;\nFunctions\nEvery function which may have access from outside its module, must include function prototype (or declaration)\n\nFunction name must be lowercase, optionally separated with underscore _ character\n/* OK */void my_func(void);void myfunc(void);/* Wrong */void MYFunc(void);void myFunc();\nWhen function returns pointer, align asterisk to return type\n/* OK */const char* my_func(void);my_struct_t* my_func(int32_t a, int32_t b);/* Wrong */const char *my_func(void);my_struct_t * my_func(void);\nAlign all function prototypes (with the same/similar functionality) for better readability\n/* OK, function names aligned */void        set(int32_t a);my_type_t   get(void);my_ptr_t*   get_ptr(void);/* Wrong */void set(int32_t a);const char * get(void);\nFunction implementation must include return type and optional other keywords in separate line\n/* OK */int32_tfoo(void) &#123;    return 0;&#125;/* OK */static const char*get_string(void) &#123;    return &quot;Hello world!\\r\\n&quot;;&#125;/* Wrong */int32_t foo(void) &#123;    return 0;&#125;\nWhen function returns pointer, asterisk character must be aligned to return type (char*)\n/* OK */const char*foo(void) &#123;    return &quot;test&quot;;&#125;/* Wrong */const char*foo(void) &#123;    return &quot;test&quot;;&#125;\nVariables\nMake variable name all lowercase with optional underscore _ character\n/* OK */int32_t a;int32_t my_var;int32_t myvar;/* Wrong */int32_t A;int32_t myVar;int32_t MYVar;\nGroup local variables together by type\nvoidfoo(void) &#123;    int32_t a, b;   /* OK */    char a;    char b;         /* Wrong, char type already exists */&#125;\nDo not declare variable after first executable statement\nvoidfoo(void) &#123;    int32_t a;    a = bar();    int32_t b;      /* Wrong, there is already executable statement */&#125;\nYou may declare new variables inside next indent level\nint32_t a, b;a = foo();if (a) &#123;    int32_t c, d;   /* OK, c and d are in if-statement scope */    c = foo();    int32_t e;      /* Wrong, there was already executable statement inside block */&#125;\nDeclare pointer variables with asterisk aligned to type\n/* OK */char* a;/* Wrong */char *a;char * a;\nWhen declaring multiple pointer variables, you may declare them with asterisk aligned to variable name\n/* OK */char *p, *n;\nStructures, enumerations, typedefs\nStructure or enumeration name must be lowercase with optional underscore _ character between words\n\nStructure or enumeration may contain typedef keyword\n\nAll structure members must be lowercase\n\nAll enumeration members must be uppercase\n\nStructure/enumeration must follow doxygen documentation syntax\n\n\nWhen structure is declared, it may use one of 3 different options:\n\nWhen structure is declared with name only, it must not contain _t suffix after its name.struct struct_name &#123;    char* a;    char b;&#125;;\nWhen structure is declared with typedef only, it has to contain _t suffix after its name.typedef struct &#123;    char* a;    char b;&#125; struct_name_t;\nWhen structure is declared with name and typedef, it must not contain _t for basic name and it has to contain _t suffix after its name for typedef part.typedef struct struct_name &#123;    char* a;    char b;    char c;&#125; struct_name_t;\nExamples of bad declarations and their suggested corrections/* a and b must be separated to 2 lines *//* Name of structure with typedef must include _t suffix */typedef struct &#123;    int32_t a, b;&#125; a;/* Corrected version */typedef struct &#123;    int32_t a;    int32_t b;&#125; a_t;/* Wrong name, it must not include _t suffix */struct name_t &#123;    int32_t a;    int32_t b;&#125;;/* Wrong parameters, must be all uppercase */typedef enum &#123;    MY_ENUM_TESTA,    my_enum_testb,&#125; my_enum_t;\n\n\nWhen initializing structure on declaration, use C99 initialization style\n/* OK */a_t a = &#123;    .a = 4,    .b = 5,&#125;;/* Wrong */a_t a = &#123;1, 2&#125;;\nWhen new typedef is introduced for function handles, use _fn suffix\n/* Function accepts 2 parameters and returns uint8_t *//* Name of typedef has `_fn` suffix */typedef uint8_t (*my_func_typedef_fn)(uint8_t p1, const char* p2);\nCompound statements\nEvery compound statement must include opening and closing curly bracket, even if it includes only 1 nested statement\n\nEvery compound statement must include single indent; when nesting statements, include 1 indent size for each nest\n/* OK */if (c) &#123;    do_a();&#125; else &#123;    do_b();&#125;/* Wrong */if (c)    do_a();else    do_b();/* Wrong */if (c) do_a();else do_b();\nIn case of if or if-else-if statement, else must be in the same line as closing bracket of first statement\n/* OK */if (a) &#123;&#125; else if (b) &#123;&#125; else &#123;&#125;/* Wrong */if (a) &#123;&#125;else &#123;&#125;/* Wrong */if (a) &#123;&#125;else&#123;&#125;\nIn case of do-while statement, while part must be in the same line as closing bracket of do part\n/* OK */do &#123;    int32_t a;    a = do_a();    do_b(a);&#125; while (check());/* Wrong */do&#123;/* ... */&#125; while (check());/* Wrong */do &#123;/* ... */&#125;while (check());\nIndentation is required for every opening bracket\nif (a) &#123;    do_a();&#125; else &#123;    do_b();    if (c) &#123;        do_c();    &#125;&#125;\nNever do compound statement without curly bracket, even in case of single statement. Examples below show bad practices\nif (a) do_b();else do_c();if (a) do_a(); else do_b();\nEmpty while, do-while or for loops must include brackets\n/* OK */while (is_register_bit_set()) &#123;&#125;/* Wrong */while (is_register_bit_set());while (is_register_bit_set()) &#123; &#125;while (is_register_bit_set()) &#123;&#125;\nIf while (or for, do-while, etc) is empty (it can be the case in embedded programming), use empty single-line brackets\n/* Wait for bit to be set in embedded hardware unituint32_t* addr = HW_PERIPH_REGISTER_ADDR;/* Wait bit 13 to be ready */while (*addr &amp; (1 &lt;&lt; 13)) &#123;&#125;        /* OK, empty loop contains no spaces inside curly brackets */while (*addr &amp; (1 &lt;&lt; 13)) &#123; &#125;       /* Wrong */while (*addr &amp; (1 &lt;&lt; 13)) &#123;         /* Wrong */&#125;while (*addr &amp; (1 &lt;&lt; 13));          /* Wrong, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */\nAlways prefer using loops in this order: for, do-while, while\n\nAvoid incrementing variables inside loop block if possible, see examples\n\n\n/* Not recommended */int32_t a = 0;while (a &lt; 10) &#123;    .    ..    ...    ++a;&#125;/* Better */for (size_t a = 0; a &lt; 10; ++a) &#123;&#125;/* Better, if inc may not happen in every cycle */for (size_t a = 0; a &lt; 10; ) &#123;    if (...) &#123;        ++a;    &#125;&#125;\nSwitch statement\nAdd single indent for every case statement\n\nUse additional single indent for break statement in each case or default\n/* OK, every case has single indent *//* OK, every break has additional indent */switch (check()) &#123;    case 0:        do_a();        break;    case 1:        do_b();        break;    default:        break;&#125;/* Wrong, case indent missing */switch (check()) &#123;case 0:    do_a();    break;case 1:    do_b();    break;default:    break;&#125;/* Wrong */switch (check()) &#123;    case 0:        do_a();    break;      /* Wrong, break must have indent as it is under case */    case 1:    do_b();     /* Wrong, indent under case is missing */    break;    default:        break;&#125;\nAlways include default statement\n/* OK */switch (var) &#123;    case 0:        do_job();        break;    default: break;&#125;/* Wrong, default is missing */switch (var) &#123;    case 0:        do_job();        break;&#125;\nIf local variables are required, use curly brackets and put break statement inside.\n\nPut opening curly bracket in the same line as case statementswitch (a) &#123;    /* OK */    case 0: &#123;        int32_t a, b;        char c;        a = 5;        /* ... */        break;    &#125;    /* Wrong */    case 1:    &#123;        int32_t a;        break;    &#125;    /* Wrong, break shall be inside */    case 2: &#123;        int32_t a;    &#125;    break;&#125;\nMacros and preprocessor directives\n\n\nAlways use macros instead of literal constants, specially for numbers\n\nAll macros must be fully uppercase, with optional underscore _ character, except if they are clearly marked as function which may be in the future replaced with regular function syntax\n/* OK */#define MY_MACRO(x)         ((x) * (x))/* Wrong */#define square(x)           ((x) * (x))\nAlways protect input parameters with parentheses\n/* OK */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))/* Wrong */#define MIN(x, y)           x &lt; y ? x : y\nAlways protect final macro evaluation with parenthesis\n/* Wrong */#define MIN(x, y)           (x) &lt; (y) ? (x) : (y)#define SUM(x, y)           (x) + (y)/* Imagine result of this equation using wrong SUM implementation */int32_t x = 5 * SUM(3, 4);  /* Expected result is 5 * 7 = 35 */int32_t x = 5 * (3) + (4);  /* It is evaluated to this, final result = 19 which is not what we expect *//* Correct implementation */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))#define SUM(x, y)           ((x) + (y))\nWhen macro uses multiple statements, protect it using do-while (0) statement\ntypedef struct &#123;    int32_t px, py;&#125; point_t;point_t p;                  /* Define new point *//* Wrong implementation *//* Define macro to set point */#define SET_POINT(p, x, y)  (p)-&gt;px = (x); (p)-&gt;py = (y)    /* 2 statements. Last one should not implement semicolon */SET_POINT(&amp;p, 3, 4);        /* Set point to position 3, 4. This evaluates to... */(&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); /* ... to this. In this example this is not a problem. *//* Consider this ugly code, however it is valid by C standard (not recommended) */if (a)                      /* If a is true */    if (b)                  /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    else        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 *//* Evaluates to code below. Do you see the problem? */if (a)    if (b)        (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6);/* Or if we rewrite it a little */if (a)    if (b)        (&amp;p)-&gt;px = (3);        (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5);        (&amp;p)-&gt;py = (6);/* * Ask yourself a question: To which `if` statement `else` keyword belongs? * * Based on first part of code, answer is straight-forward. To inner `if` statement when we check `b` condition * Actual answer: Compilation error as `else` belongs nowhere *//* Better and correct implementation of macro */#define SET_POINT(p, x, y)  do &#123; (p)-&gt;px = (x); (p)-&gt;py = (y); &#125; while (0)    /* 2 statements. No semicolon after while loop *//* Or even better */#define SET_POINT(p, x, y)  do &#123;    \\   /* Backslash indicates statement continues in new line */    (p)-&gt;px = (x);                  \\    (p)-&gt;py = (y);                  \\&#125; while (0)                             /* 2 statements. No semicolon after while loop *//* Now original code evaluates to */if (a)    if (b)        do &#123; (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); &#125; while (0);    else        do &#123; (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); &#125; while (0);/* Every part of `if` or `else` contains only `1` inner statement (do-while), hence this is valid evaluation *//* To make code perfect, use brackets for every if-ifelse-else statements */if (a) &#123;                    /* If a is true */    if (b) &#123;                /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    &#125; else &#123;        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 */    &#125;&#125;\nAlways write macro documentation as regular function with additional hideinitializer doxygen keyword\n#define MY_MACRO(x)         ((x) * 2)\nAvoid using #ifdef or #ifndef. Use defined() or !defined() instead\n#ifdef XYZ/* do something */#endif /* XYZ */\nAlways document if/elif/else/endif statements\n/* OK */#if defined(XYZ)/* Do if XYZ defined */#else /* defined(XYZ) *//* Do if XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)/* Do if XYZ defined */#else/* Do if XYZ not defined */#endif\nDo not indent sub statements inside #if statement\n/* OK */#if defined(XYZ)#if defined(ABC)/* do when ABC defined */#endif /* defined(ABC) */#else /* defined(XYZ) *//* Do when XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)    #if defined(ABC)        /* do when ABC defined */    #endif /* defined(ABC) */#else /* defined(XYZ) */    /* Do when XYZ not defined */#endif /* !defined(XYZ) */\nDocumentation\n\nDocumented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly.\n\nUse doxygen-enabled documentation style for variables, functions and structures/enumerations\n\nAlways use \\ for doxygen, do not use @\n\nAlways use 5x4 spaces (5 tabs) offset from beginning of line for text\n/** * \\brief           Holds pointer to first entry in linked list *                  Beginning of this text is 5 tabs (20 spaces) from beginning of line */statictype_t* list;\nEvery structure/enumeration member must include documentation\n\nUse 12x4 spaces offset for beginning of comment\n/** * \\brief           This is point struct * \\note            This structure is used to calculate all point *                      related stuff */typedef struct &#123;    int32_t x;                                  /*!&lt; Point X coordinate */    int32_t y;                                  /*!&lt; Point Y coordinate */    int32_t size;                               /*!&lt; Point size.                                                    Since comment is very big,                                                    you may go to next line */&#125; point_t;/** * \\brief           Point color enumeration */typedef enum &#123;    COLOR_RED,                                  /*!&lt; Red color. This comment has 12x4                                                    spaces offset from beginning of line */    COLOR_GREEN,                                /*!&lt; Green color */    COLOR_BLUE,                                 /*!&lt; Blue color */&#125; point_color_t;\nDocumentation for functions must be written in function implementation (source file usually)\n\nFunction must include brief and all parameters documentation\n\nEvery parameter must be noted if it is in or out for input and output respectively\n\nFunction must include return parameter if it returns something. This does not apply for void functions\n\nFunction can include other doxygen keywords, such as note or warning\n\nUse colon : between parameter name and its description\n/** * \\brief           Sum `2` numbers * \\param[in]       a: First number * \\param[in]       b: Second number * \\return          Sum of input values */int32_tsum(int32_t a, int32_t b) &#123;    return a + b;&#125;/** * \\brief           Sum `2` numbers and write it to pointer * \\note            This function does not return value, it stores it to pointer instead * \\param[in]       a: First number * \\param[in]       b: Second number * \\param[out]      result: Output variable used to save result */voidvoid_sum(int32_t a, int32_t b, int32_t* result) &#123;    *result = a + b;&#125;\nIf function returns member of enumeration, use ref keyword to specify which one\n/** * \\brief           My enumeration */typedef enum &#123;    MY_ERR,                                     /*!&lt; Error value */    MY_OK                                       /*!&lt; OK value */&#125; my_enum_t;/** * \\brief           Check some value * \\return          \\ref MY_OK on success, member of \\ref my_enum_t otherwise */my_enum_tcheck_value(void) &#123;    return MY_OK;&#125;\nUse notation (`NULL` =&gt; NULL) for constants or numbers\n/** * \\brief           Get data from input array * \\param[in]       in: Input data * \\return          Pointer to output data on success, `NULL` otherwise */const void *get_data(const void* in) &#123;    return in;&#125;\nDocumentation for macros must include hideinitializer doxygen command\n/** * \\brief           Get minimal value between `x` and `y` * \\param[in]       x: First value * \\param[in]       y: Second value * \\return          Minimal value between `x` and `y` * \\hideinitializer */#define MIN(x, y)       ((x) &lt; (y) ? (x) : (y))\nHeader/source files\nLeave single empty line at the end of file\n\nEvery file must include doxygen annotation for file and brief description followed by empty line (when using doxygen)\n/** * \\file            template.h * \\brief           Template include file */                    /* Here is empty line */\nEvery file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen)\n\nUse the same license as already used by project/library\n/** * \\file            template.h * \\brief           Template include file *//* * Copyright (c) year FirstName LASTNAME * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the &quot;Software&quot;), to deal in the Software without restriction, * including without limitation the rights to use, copy, modify, merge, * publish, distribute, sublicense, and/or sell copies of the Software, * and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. * * This file is part of library_name. * * Author:          FirstName LASTNAME &lt;optional_email@example.com&gt; */\nHeader file must include guard #ifndef\n\nHeader file must include C++ check\n\nInclude external header files outside C++ check\n\nInclude external header files with STL C files first followed by application custom files\n\nHeader file must include only every other header file in order to compile correctly, but not more (.c should include the rest if required)\n\nHeader file must only expose module public variables/types/functions\n\nUse extern for global module variables in header file, define them in source file later\n&#x2F;* file.h ... *&#x2F;#ifndef ...extern int32_t my_variable; &#x2F;* This is global variable declaration in header *&#x2F;#endif&#x2F;* file.c ... *&#x2F;int32_t my_variable;        &#x2F;* Actually defined in source *&#x2F;\nNever include .c files in another .c file\n\n.c file should first include corresponding .h file, later others, unless otherwise explicitly necessary\n\nDo not include module private declarations in header file\n\nHeader file example (no license for sake of an example)\n/* License comes here */#ifndef TEMPLATE_HDR_H#define TEMPLATE_HDR_H/* Include headers */#ifdef __cplusplusextern &quot;C&quot; &#123;#endif /* __cplusplus *//* File content here */#ifdef __cplusplus&#125;#endif /* __cplusplus */#endif /* TEMPLATE_HDR_H */\nArtistic style configuration\n\nAStyle is a great piece of software that canhelp with formatting the code based on input configuration.\nThis repository contains astyle-code-format.cfg file which can be used with AStyle software.\nastyle --options&#x3D;&quot;astyle-code-format.cfg&quot; &quot;input_path&#x2F;*.c,*.h&quot; &quot;input_path2&#x2F;*.c,*.h&quot;\nEclipse formatterRepository contains eclipse-ext-kr-format.xml file that can be used witheclipse-based toolchains to set formatter options.\nIt is based on K&amp;R formatter with modifications to respect above rules.You can import it within eclipse settings, Preferences -&gt; LANGUAGE -&gt; Code Style -&gt; Formatter tab.\n"},{"title":"SVC系统调用的编程使用方法","url":"/2021/11/02/SVC%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"SVC称为系统服务调用(SuperVisorCall)，异常类型为11，通过svc指令可用触发异常，SVC在触发异常后必须立即得到相应(触发异常后在执行异常前不能执行其它代码)，除非有更高优先级的异常在执行。\n对于可靠系统而言，可以使用SVC异常实现资源的特权访问，使系统更加安全。通过SVC系统调用编号能够实现参数传递，从而实现不同功能的系统服务。使用系统服务可以不需要知道具体服务函数的地址，这样能够隐藏更多的细节，降低软件间的耦合性。\n在ARM开发工具链下，有比较优雅的方式直接使用SVC异常，在GCC下需要配合汇编来使用。\n这里不讨论ARM处理器对于异常的处理机制，它在触发SVC指令后响应的异常行为与系统中其它异常是一致的。\nSVC异常处理  .syntax unified  .thumb  .global SVC_Handler  .global SVC_VIRTUAL_CALL_0  .global SVC_VIRTUAL_CALL_1  .global SVC_VIRTUAL_CALL_2  .global SVC_VIRTUAL_CALL_3  .type SVC_Handler, %function  .type SVC_VIRTUAL_CALL_0, %function  .type SVC_VIRTUAL_CALL_1, %function  .type SVC_VIRTUAL_CALL_2, %function  .type SVC_VIRTUAL_CALL_3, %functionSVC_Handler:  tst lr, #4  ite eq  mrseq r0, msp  mrsne r0, psp  push &#123;r6, r7, lr&#125;  mov r7, r0  ldr r0, [r7, #0]     //原始R0  ldr r1, [r7, #4]  ldr r2, [r7, #8]  ldr r3, [r7, #12]  ldr r6, [r7, #24]    //svc指令相关的pc地址  ldr r6, [r6, #-2]  and r6, #0xFF  ldr r12, =g_svc_vector  ldr r6, [r12, r6, lsl #2]  blx r6  str r0, [r7, #0]  pop &#123;r6, r7, pc&#125;Default_SVC_Handler:  bx lr  .align 2g_svc_vector:  .word SVC_HANDLER_0  .word SVC_HANDLER_1  .word SVC_HANDLER_2  .word SVC_HANDLER_3    .weak      SVC_HANDLER_0  .thumb_set SVC_HANDLER_0, Default_SVC_Handler  .weak      SVC_HANDLER_1  .thumb_set SVC_HANDLER_1, Default_SVC_Handler  .weak      SVC_HANDLER_2  .thumb_set SVC_HANDLER_2, Default_SVC_Handler  .weak      SVC_HANDLER_3  .thumb_set SVC_HANDLER_3, Default_SVC_HandlerSVC_VIRTUAL_CALL_0:    svc 0    bx lrSVC_VIRTUAL_CALL_1:    svc 1    bx lrSVC_VIRTUAL_CALL_2:    svc 2    bx lrSVC_VIRTUAL_CALL_3:    svc 3    bx lr\nSVC_Handler函数是异常处理函数，进入函数，判断LR寄存器来分析进入异常前的环境，获取到对应的sp地址。通过sp寄存器就能访问到栈空间，在栈中可以获取到r0-r3，这个就是执行svc时传进来的参数，通常这4个寄存器不会被修改，除非发生了更高优先级的异常。通过在栈中获取到执行svc的pc指针，得到svc指令的二进制码，低8位存储了指令附加的异常id，使用该id在内部通过查表的方式定位具体需要执行的函数入口，执行指定的函数后，我们将r0也就是返回值存储到栈空间中，这样返回到用户态后，用户就能获得执行目标函数后返回结果。\n为了方便定义用户系统调用函数，设计了这样的一个宏。\n#define SVC_CALL_DEF(id, func, ret_t, ...) \\extern ret_t SVC_VIRTUAL_CALL_##id(__VA_ARGS__); \\ret_t SVC_HANDLER_##id(__VA_ARGS__)\n其中id表示该函数绑定到svc的那一个系统调用上，func表示函数名称，ret_t和后面的参数分别表示函数的返回值和形参列表，如果无形参则填入void。通过 SVC_VIRTUAL_CALL_id()来执行系统调用。\n这是一个简单的例子：\nSVC_CALL_DEF(1, test_svc_add, int, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = SVC_VIRTUAL_CALL_1(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n进阶写法前面的定义方法和调用方法与传统的C语言函数定义和函数调用存在区别，所以在使用上存在不方便的地方，按照下面的写法更加合理，且函数调用与C语言是一致的，减低了代码移植上的一致性问题。\n#ifndef __SVC_HANDER_H#define __SVC_HANDER_H#if defined(__GNUC__)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__); \\    __asm__(        \\        &quot;.thumb\\n&quot;  \\        &quot;.global &quot; #name &quot;\\n&quot; \\        &quot;.type &quot; #name &quot;, %function\\n&quot; \\        #name &quot;:\\n&quot; \\        &quot;svc &quot; #id &quot;\\n&quot; \\        &quot;bx lr\\n&quot;); \\    ret_t SVC_HANDLER_##id(__VA_ARGS__)#elif defined(__CC_ARM)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t __svc(id) name(__VA_ARGS__)#else#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__)    // #warning &quot;not support SVC function!&quot;#endif#endif\n有了这个宏定义后，定义一个svc函数以及函数的调用写法将变为：\nDEF_SVC_FUNC(2, int, add_func, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = add_func(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n这样的写法能够兼容不同的编译器，且不用提前定义SVC_VIRTUAL_CALL_0函数。\n"},{"title":"nRF52x运行蓝牙协议栈+FreeRTOS的原理","url":"/2022/05/30/nRF52x%E8%BF%90%E8%A1%8C%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88+FreeRTOS%E7%9A%84%E5%8E%9F%E7%90%86/","content":"\n之前有个研发的产品为了满足蓝牙连接的需求，选择了nRF52840这个芯片，它的蓝牙协议栈是一种类似使用动态库的方式进行调用，官方仅仅给出了协议栈的二进制包(SoftDevice)，并给出了动态调用的方法，其调用的关键就是使用ARM单片机的SVC调用，这是一种比较好的设计，我们开发软件能够非常简单的调用协议栈的程序来实现蓝牙通信相关的功能。后来产品的使用需求发生的变化，蓝牙功能已经不需要的，而是需要更加复杂的通信功能。为了保持业务功能代码的一致性，所以并没有替换芯片，但是由于通信功能更加复杂后，迫不得已需要RTOS的支援。后续就是移植FreeRTOS等一系列操作。因为该单片机是CM4内核，所以这些操作都很简单。\n\nSVC调用冲突的疑惑今天在看这两套基于nRF单片机的设计方案时，我对其中的有个细节产生了疑惑。了解FreeRTOS的开发者应该比较清楚，像CM4内核的单片机启动FreeRTOS的第一个任务时，依赖SVC调用从裸机运行切换为RTOS线程运行。而蓝牙协议栈也使用了SVC调用，那是不是意味着该单片机的蓝牙功能不能和FreeRTOS兼容，结果是否定的。因为从官方的例程中可以看到蓝牙+FreeRTOS的例程(examples\\ble_peripheral\\ble_app_hrs_freertos)。我决定弄清楚Nordic的蓝牙协议栈+FreeRTOS是如何兼容的。\n我起初认为FreeRTOS的port实现中对初始任务调用有区别一般单片机的特殊处理，但是仔细看它的port文件后又发现并没有什么特别的。\n// external\\freertos\\portable\\ARM\\nrf52\\port.c__asm void vPortSVCHandler( void )&#123;    PRESERVE8    /* Get the location of the current TCB. */    ldr r3, =pxCurrentTCB    ldr r1, [r3]    ldr r0, [r1]    /* Pop the core registers. */    ldmia r0!, &#123;r4-r11, r14&#125;    msr psp, r0    isb    mov r0, #0    msr basepri, r0    bx r14&#125;__asm void vPortStartFirstTask( void )&#123;    PRESERVE8    EXTERN __Vectors    /* Use the NVIC offset register to locate the stack. */    ldr r0, =__Vectors    ldr r0, [r0]    /* Set the msp back to the start of the stack. */    msr msp, r0    /* Globally enable interrupts. */    cpsie i    cpsie f    dsb    isb#ifdef SOFTDEVICE_PRESENT    /* Block kernel interrupts only (PendSV) before calling SVC */    mov r0, #(configKERNEL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))    msr basepri, r0#endif    /* Call SVC to start the first task. */    svc 0    ALIGN&#125;\n而在FreeRTOSConfig.h文件中也将该函数映射到了中断向量表中\n// examples\\ble_peripheral\\ble_app_hrs_freertos\\config\\FreeRTOSConfig.h/* Definitions that map the FreeRTOS port interrupt handlers to their CMSISstandard names - or at least those used in the unmodified vector table. */#define vPortSVCHandler                                       SVC_Handler#define xPortPendSVHandler                                    PendSV_Handler\n到这里我转头分析nRF的SDK代码，例如sd_ble_enable()函数就是一个SVC调用在ble.h文件中使用一个SVCALL宏定义扩展为SVC调用代码，到这里我怀疑SVCALL针对有无RTOS有两种不同的设计，后来发现是多虑了。\n检查中断向量表实在不行上代码吧，在调试环境中看看，我运行了一个仅仅包含蓝牙协议栈的程序，运行起来后发现SCB-&gt;VTOR=0\n很奇怪~\n蓝牙协议栈在ROM中的地址范围为0-0x27000，我们编写的APP地址范围为0x27000-END。因为单片机从地址0处开始运行，肯定是运行蓝牙协议栈，在协议栈内跳转到APP中，按照一般BOOT+APP的设计思想，BOOT跳转是应把中断向量表寄存器改为APP的中断向量表。这里为什么还是BOOT的中断向量表呢？难道是Bug。看来需要看看协议栈固件中发生了什么。\n其实到这里我就大概猜到这里面的门道了，我准备逆向分析蓝牙协议栈的二进制包，看看是否符合我的预期。我认为整个系统任然依赖Boot(蓝牙协议栈程序，我把它当作boot的角色)的向量表，而在Boot的中断处理函数中通过适当的判断决定执行Boot中断处理逻辑还是跳转引导到APP中的中断处理函数中来。\n分析SoftDevice固件官方提供的boot为一个HEX文件，我先转为bin文件，方便查看二进制数据，从前面的调试结果能够看到中断向量表在起始位置，那么很容易就找到SVC的入口地址了，在0x2c偏移处得到0x00000AA5，忽略最低bit1，转到0x00000AA4，开始分析SVC的函数处理流程，这里不讨论如何逆向固件，直接看结果，我把其中最关键的部分截取了出来。\n这里分析的固件从nRF5_SDK_17.0.2_d674dde中获得。不同版本的SoftDevice可以在汇编数据上有差别，大体流程应该是一致的。\n0x00000AA4 F01E0F04  TST           lr,#0x04       ;; 解析SVCid的经典代码，很多地方都看过0x00000AA8 BF0C      ITE           EQ0x00000AAA F3EF8108  MRS           r1,MSP0x00000AAE F3EF8109  MRS           r1,PSP0x00000AB2 6988      LDR           r0,[r1,#0x18]  ;; 得到执行SVC指令后的PC指针值. why offset &#x3D; 0x18, see ARM manual0x00000AB4 3802      SUBS          r0,r0,#0x02    ;; 向后回退一个指令的长度，即2字节，就是SVC指令的位置0x00000AB6 7800      LDRB          r0,[r0,#0x00]  ;; 按字节取值，从低位得到SVC的id，id是作为低位包含在二进制编码中的0x00000AB8 2818      CMP           r0,#0x180x00000ABA D103      BNE           0x00000AC4   ;; SVC的ID不等于0x18跳转到0x00000AC4，这就是我们需要流程，FreeRTOS的SVCid为00x00000ABC E000      B             0x00000AC0   ;; SVC的ID等于0x18跳转到0x00000AC40x00000ABE 0000      MOVS          r0,r00x00000AC0 4A07      LDR           r2,[pc,#28]  ; @0x00000AE00x00000AC2 4710      BX            r20x00000AC4 4A07      LDR           r2,[pc,#28]  ; @0x00000AE40x00000AC6 6812      LDR           r2,[r2,#0x00] ;; 检测内存发现@0x20000000的值为0x10000x00000AC8 322C      ADDS          r2,r2,#0x2C   ;; 0x2C? 像是SVC的偏移，推测在RAM的0x1000处有一个新的中断向量表0x00000ACA 6812      LDR           r2,[r2,#0x00] ;; r2&#x3D;0x0002606D0x00000ACC 4710      BX            r20x00000ACE 0000      MOVS          r0,r00x00000AE0: 00000377 .word 0x000003770x00000AE4: 20000000 .word 0x200000000x0002606C 2004      MOVS          r0,#0x04     ;; 这是另一个SVC处理函数0x0002606E 4671      MOV           r1,lr0x00026070 4208      TST           r0,r1        ;; 这是编译器生成的还是手工编写的汇编，太冗余了...0x00026072 D002      BEQ           0x0002607A0x00026074 F3EF8109  MRS           r1,PSP0x00026078 E001      B             0x0002607E0x0002607A F3EF8108  MRS           r1,MSP0x0002607E 6988      LDR           r0,[r1,#0x18]0x00026080 3802      SUBS          r0,r0,#0x020x00026082 7800      LDRB          r0,[r0,#0x00] ;; 到这里，函数重新解析了一遍SVC的ID0x00026084 2810      CMP           r0,#0x100x00026086 DB13      BLT           0x000260B0    ;; 如果ID小于0x10则跳转到 0x000260B00x00026088 2820      CMP           r0,#0x200x0002608A DB0F      BLT           0x000260AC    ;; 如果ID小于0x20则跳转到 0x000260AC0x0002608C 282C      CMP           r0,#0x2C0x0002608E DB0B      BLT           0x000260A8    ;; 如果ID小于0x2c则跳转到 0x000260A80x00026090 4A0A      LDR           r2,[pc,#40]  ; @0x000260BC0x00026092 6812      LDR           r2,[r2,#0x00]0x00026094 4B0A      LDR           r3,[pc,#40]  ; @0x000260C00x00026096 429A      CMP           r2,r30x00026098 D103      BNE           0x000260A20x0002609A 2860      CMP           r0,#0x600x0002609C DB04      BLT           0x000260A80x0002609E 4A09      LDR           r2,[pc,#36]  ; @0x000260C40x000260A0 4710      BX            r20x000260A2 2002      MOVS          r0,#0x020x000260A4 6008      STR           r0,[r1,#0x00]0x000260A6 4770      BX            lr0x000260A8 4A07      LDR           r2,[pc,#28]  ; @0x000260C80x000260AA 4710      BX            r20x000260AC 4A07      LDR           r2,[pc,#28]  ; @0x000260CC0x000260AE 4710      BX            r20x000260B0 4A07      LDR           r2,[pc,#28]  ; @0x000260D00x000260B2 6812      LDR           r2,[r2,#0x00]  ;; 在0x20000004处的值为0x27000,它是app的起始位置0x000260B4 322C      ADDS          r2,r2,#0x2C    ;; 计算出app中SVC的地址0x000260B6 6812      LDR           r2,[r2,#0x00]0x000260B8 4710      BX            r2             ;; 跳转到app中的SVC执行0x000260BC: 2000005C .word 0x2000005C0x000260C0: CAFEBABE .word 0xCAFEBABE0x000260C4: 0000139B .word 0x0000139B0x000260C8: 00024485 .word 0x000244850x000260CC: 00024E9F .word 0x00024E9F0x000260D0: 20000004 .word 0x20000004\n分析执行过程猜测在0x20000000和0x20000004处存放了两个中断向量表的起始地址，一个是内存中的向量表，位于0x1000；另一个就是APP的中断向量表，位于0x27000。\n结论非常明显了，当SVC的id小于0x10时就会跳转到我们编写的APP固件中的SVC处理函数中，这样就实现了FreeRTOS的port所依赖的功能。而id大于等于0x10时就执行协议栈内部的工作流程，实现了蓝牙协议栈+FreeRTOS功能的兼容。\n从这个汇编代码的执行路径来看，从触发BOOT中的SVC到跳转到APP中的SVC处理函数，全程都没有使用栈操作的指令，没有涉及pop、push、bl、bxl等。这样在APP的中断函数中就能直接返回到线程环境代码，这样的设计对APP的中断处理函数来说也更加封闭。\n官方的文档中也说明了0-0xf的id调用分配到了Application，其它的id分配为协议栈。\n类似的像PendSV_Handler中断处理函数，在协议栈内部触发后，经过5条指令就能够跳转到APP内部，还算是比较简洁的，应该不会对FreeRTOS的调度性能产生很大的影响。\n官方的SDK中id是从0x60开始使用的，而协议栈中对小于0x20、0x2c等区间的id有特殊处理，为什么需要这样处理呢？以后再看吧。\n不懂固件中为什么需要两次解析SVC的id，关键是是第二次解析时很不简洁，还多了3条指令，看起来好别扭-_-!\n"},{"title":"内存陷阱，一种内存调试方法","url":"/2022/07/25/%E5%86%85%E5%AD%98%E9%99%B7%E9%98%B1%EF%BC%8C%E4%B8%80%E7%A7%8D%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/","content":"需求场景在一个多任务系统中，当一个全局可访问的数据出现了异常，如何排查问题呢？由于在多任务环境中，各个任务并行运行，一般的单步跟踪调试很难定位问题。逐个屏蔽代码又可能会导致问题无法复现。使用内存断点是比较好的方法，但是大多数集成开发环境对该功能的支持不完美，且使用场景有限。\n下面引入一个问题代码场景，分析该问题的排查方法。\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        delay(1000);    &#125;&#125;void isr_a(void)&#123;    *p = *p + 1;&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n在这段程序中任务A分配了一段内存空间，并打开了一个外部中断，任务A统计中断发生的次数，每秒输出一次数据并清零。如果此时存在一个任务B，由于其它故障导致变量被分配到了同一段内存上，显然任务A统计次数的变量就会出现数据异常的现象。\n由于地址0x2000会被正常的任务A和中断A访问，同时被异常的任务B访问。集成开发环境中的内存断点无法正常区分正常的访问和非法的访问，进而导致无法准确的跟踪到问题代码。\n适时启用内存断点如果能够在代码中实时的启用和关闭内存断点，看这个问题就能解决了。大致看起来是这样的：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        disable_mem_break(0x2000);        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        enable_mem_break(0x2000);        delay(1000);    &#125;&#125;void isr_a(void)&#123;    disable_mem_break(0x2000);    *p = *p + 1;    enable_mem_break(0x2000);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当正常访问数据时就先把内存断点关闭，当数据正常访问完成后再开，这样线程B非法访问数据时就会被内存断点捕获。这样在代码中适时添加、删除断点的行为是可行的。\n内存断点的原理ARM Cortex-M3以上的内核都具有CoreDebug和DWT内核外设模块，它们的一个功能就是实现内存断点机制，通过在DWT的监视表上记录需要监视的内存地址，监视的方式(读、写)等参数，当满足条件时就会触发DebugMon_Handler异常中断。这个过程显然是代码可控制的。\ntypedef struct&#123;  __IOM uint32_t CTRL;      __IOM uint32_t CYCCNT;    __IOM uint32_t CPICNT;    __IOM uint32_t EXCCNT;    __IOM uint32_t SLEEPCNT;  __IOM uint32_t LSUCNT;    __IOM uint32_t FOLDCNT;   __IM  uint32_t PCSR;      __IOM struct&#123;    uint32_t COMP;    uint32_t MASK;    uint32_t FUNCTION;    uint32_t RESERVED;  &#125; W[4];&#125; DWT_Type;\n不同的处理器内核所具有的内存断点数量是不一样的，一般CM3、CM4、CM7只有4个，更高级的内核数量会多一些。同时监视4个地址下的内存能够满足很多分析场景。打开内存监视功能需要写入COMP、MASK、FUNCTION三个寄存器，其中COMP寄存器写入待监视的地址，FUNCTION表示监视的方式(5:read 6:write 7:read&amp;write 0表示关闭监视)，MASK表示监视的数据位宽(0:8位 1:16位 2:32位)。\n此外，还需要打开DebugMon_Handler异常中断，需要向CoreDebug模块的DEMCR寄存器第16位和24位写入1，用来打开DebugMon异常。\n代码mem_trap.h\n#ifndef _CPU_MEM_TRAP_H#define _CPU_MEM_TRAP_Htypedef enum &#123;    MEM_TRAP_DISABLE = 0,    MEM_READ_ONLY  = 5,    MEM_WRITE_ONLY = 6,    MEM_READ_WRITE = 7&#125; mem_trap_mode_t;typedef enum &#123;    MEM_8BIT,    MEM_16BIT,    MEM_32BIT&#125; mem_width_t;void mem0_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem0_watchpoint_reset(void);void mem1_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem1_watchpoint_reset(void);void mem2_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem2_watchpoint_reset(void);void mem3_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width);void mem3_watchpoint_reset(void);void mem_watchpoint_allreset(void);#endif\nmem_trap.c\n#include &quot;mem_trap.h&quot;#include &lt;stdio.h&gt;#if defined(DWT) &amp;&amp; defined(CoreDebug)/* Symbol conflict */#ifdef COMP1#undef COMP1#endif#ifdef COMP2#undef COMP2#endif#define DEF_MEM_WATCHPOINT(i) \\void mem##i##_watchpoint(void *addr, mem_trap_mode_t mode, mem_width_t width)&#123;\\    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk |\\                        CoreDebug_DEMCR_MON_EN_Msk;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\    DWT-&gt;COMP##i = (uint32_t)addr;\\    DWT-&gt;MASK##i = (uint32_t)width;\\    DWT-&gt;FUNCTION##i = (uint32_t)mode;\\&#125;\\void mem##i##_watchpoint_reset(void)&#123;\\    DWT-&gt;FUNCTION##i = MEM_TRAP_DISABLE;\\&#125;void mem_watchpoint_allreset(void)&#123;    DWT-&gt;FUNCTION0 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION1 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION2 = MEM_TRAP_DISABLE;    DWT-&gt;FUNCTION3 = MEM_TRAP_DISABLE;&#125;DEF_MEM_WATCHPOINT(0)DEF_MEM_WATCHPOINT(1)DEF_MEM_WATCHPOINT(2)DEF_MEM_WATCHPOINT(3)__WEAK void mem_trap_log(int idx, uint32_t pc, uint32_t addr, const char *event)&#123;    printf(&quot;[%d]Trigger memory trap near by %#08x, %s at %#08x\\r\\n&quot;, \\        idx, (unsigned int)pc, event, (unsigned int)addr);&#125;void watchpoint_event_handle(uint32_t *args)&#123;    #define EVENT_PC (args[6])    const char* mem_event[4] = &#123;&quot;READ&quot;, &quot;WRITE&quot;, &quot;READ_WRITE&quot;, &quot;ERROR&quot;&#125;;    if((DWT-&gt;FUNCTION0 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(0, EVENT_PC, DWT-&gt;COMP0, mem_event[(DWT-&gt;FUNCTION0 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION1 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(1, EVENT_PC, DWT-&gt;COMP1, mem_event[(DWT-&gt;FUNCTION1 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION2 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(2, EVENT_PC, DWT-&gt;COMP2, mem_event[(DWT-&gt;FUNCTION2 - 5) &amp; 0x3]);    &#125;    if((DWT-&gt;FUNCTION3 &amp; DWT_FUNCTION_MATCHED_Msk) != 0)&#123;        mem_trap_log(3, EVENT_PC, DWT-&gt;COMP3, mem_event[(DWT-&gt;FUNCTION3 - 5) &amp; 0x3]);    &#125;&#125;#if defined(__CC_ARM)__asm void DebugMon_Handler(void)&#123;    extern watchpoint_event_handle        /* *INDENT-OFF* */    PRESERVE8    tst lr, #4    ite eq    mrseq r0, msp    mrsne r0, psp    push &#123;lr&#125;    bl watchpoint_event_handle    pop &#123;pc&#125;&#125;#elif defined(__GNUC__)void DebugMon_Handler(void)&#123;    __asm volatile    (        &quot;tst lr, #4                     \\n&quot;        &quot;ite eq                         \\n&quot;        &quot;mrseq r0, msp                  \\n&quot;        &quot;mrsne r0, psp                  \\n&quot;        &quot;push &#123;lr&#125;                      \\n&quot;        &quot;bl watchpoint_event_handle     \\n&quot;        &quot;pop &#123;pc&#125;                       \\n&quot;    );&#125;#endif#endif\n注：这里引用了CMSIS的内容，可以需要inlcude相关的文件。\nDebugMon异常处理函数使用汇编实现的原因是为了在代码中自动定位到触发内存监视的PC指针位置，也就是代码位置。代码的用法也比较简单，当需要保护某块代码中的数据不被异常访问，我们就使用mem0_watchpoint_reset()和mem0_watchpoint()将代码包起来。\n以最开始的那段代码为例：\nuint32_t *p;void task_A(void)&#123;    p = (uint32_t *)0x2000;    enable_isr_a();    while(1)&#123;        mem0_watchpoint_reset();        printf(&quot;freq :%u\\n&quot;, *p);        *p = 0;        mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);  // 开启保护        delay(1000);    &#125;&#125;void isr_a(void)&#123;    mem0_watchpoint_reset();    *p = *p + 1;    mem0_watchpoint(p, MEM_READ_WRITE, MEM_32BIT);&#125;void task_B(void)&#123;    // ...    uint8_t *a = 0x2000;    *a = 100;&#125;\n当任务C运行时由于内存监视器的存在且打开了对适当内存的保护，访问0x2000地址时就会触发DebugMon异常，该异常函数能够自动分析出任务B中修改数据时的PC指针位置。\n总结在代码中使用这种内存跟踪机制在解决某些内存问题时是很有效的，它对正常的数据访问没有任何影响，但是在正常的数据访问之外，我们在那个数据点上挖了一个陷阱，任何尝试访问数据的代码都会掉入到这个陷阱中并被我们捕获，所有我把这种内存调试方法成为内存陷阱。\n这里对DWT的机制以及寄存器只是一个简单的描述，如果需要了解其中的细节请查阅《ARMv7-M Architecture Reference Manual》，里面有非常详细的描述。\n"},{"title":"在RTOS中如何优雅的处理Fault异常","url":"/2021/11/06/%E5%9C%A8RTOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86Fault%E5%BC%82%E5%B8%B8/","content":"ARM处理器下的Fault异常ARM处理器当发生异常事件后就会暂停当前程序的运行，处理器进入异常模式，响应一个来自处理器内核或者外设的中断请求。\n这里想要处理的Fault异常就是ARM处理器多个异常中的一类，以Cortex-M7内核的ARM处理器为例，主要的Fault异常有HardFault、BusFault、UsageFault、MemManage。当发生这些异常就表示程序出现了比较严重的错误，进而导致“死机”。\n嵌入式实时操作系统下发生Fault异常后会如何处理常见的各种嵌入式实时操作系统(FreeRTOS、UCOSII/III等)都没有特别的对Fault进行处理，基本上都是按照默认处理方式来解决，也就是让处理器进入死循环。\nvoid xxxFault_Handler(void)&#123;    while (1);&#125;\n这种处理方式是无可厚非的，因为程序本身发生了致命的故障，暂停当前程序的运行或许能够避免程序发生更严重的错误。大多数单线程嵌入式软件(NoOS)都是这样处理的，一个地方的错误会导致整个系统崩溃。\n但是在多任务环境下，RTOS提供了多线程运行的机制，线程之间是相对独立的运行。基于此，在RTOS中采用这种暂停处理器的方式来处理异常就不是最佳的解决方案了。例如有两个线程在运行(线程A和线程B)，线程B在正常运行，线程A由于地址访问错误，导致触发HardFault异常，Fault异常会暂停整个处理器的运行，不但使发生错误的A线程停止了运行，线程B也被牵连导致运行停止。所以在RTOS中发生异常时想要将出现Fault异常而带来的损失降低到最小，也就是单独停止错误线程的运行而不结束整个系统的运行。\n发生Fault异常后如何暂停异常线程首先需要知道的是，异常并不总是由线程运行导致的，还有用户中断处理程序(IRQ)、RTOS内核调度等，在这些地方发生的异常目前看起来是比较难处理的，所以后面主要处理的就是在线程中发生的Fault异常。这里以FreeRTOS操作系统为例，对于其他的操作系统都能实现类似的解决方案，可以结合实际的处理器、操作系统平台进行修改移植，因为核心思想是一致的。当发生Fault后不能简单的while(1)处理了，更优雅且安全的的实现要完成两步动作：\n\n暂停错误线程的运行\n将CPU的执行权限切换到正常线程中\n\n清理异常线程这是在FreeRTOS下的一个实现：\n// fault_handle.c#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;#if (INCLUDE_xTaskGetIdleTaskHandle == 0)#warning &quot;Unable to switch to a valid task!&quot;#endifvoid* clean_fault_task(void)&#123;    extern void* pxCurrentTCB;    TaskHandle_t fault_task = pxCurrentTCB;    if(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)&#123;        /* RTOS not running. */        return NULL;    &#125;    /* Switch to Idle task and delete current fault task. */    // log_info(&quot;task(%s) fault.\\n&quot;, pcTaskGetName(task));    #if defined(INCLUDE_xTaskGetIdleTaskHandle) &amp;&amp; (INCLUDE_xTaskGetIdleTaskHandle == 1)    pxCurrentTCB = xTaskGetIdleTaskHandle();    #else    return NULL;    #endif    vTaskDelete(fault_task);    return pxCurrentTCB;&#125;\n简单解释一下这段代码的含义。首先需要判断操作系统的任务调度有没有运行，如果操作系统还没有启动，这就说明异常不是在线程中触发的，这就不在解决范围内。然后找到一个可以切入的线程，而且它是处于就绪态的任务，显然最好的选择就是Idle线程了。通过xTaskGetIdleTaskHandle()获取到Idle线程的句柄，赋值给pxCurrentTCB。最后调用vTaskDelete()删除当前错误的线程，并返回新的当前线程就好了。\n这里为什么需要先获取新的的线程再删除旧的错误线程呢？这就需要理解线程删除中发生了什么。\n// void vTaskDelete( TaskHandle_t xTaskToDelete )if( pxTCB == pxCurrentTCB )&#123;    /* A task is deleting itself.  This cannot complete within the    * task itself, as a context switch to another task is required.    * Place the task in the termination list.  The idle task will    * check the termination list and free up any memory allocated by    * the scheduler for the TCB and stack of the deleted task. */    vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );    /* Increment the ucTasksDeleted variable so the idle task knows    * there is a task that has been deleted and that it should therefore    * check the xTasksWaitingTermination list. */    ++uxDeletedTasksWaitingCleanUp;    /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as    * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */    traceTASK_DELETE( pxTCB );    /* The pre-delete hook is primarily for the Windows simulator,    * in which Windows specific clean up operations are performed,    * after which it is not possible to yield away from this task -    * hence xYieldPending is used to latch that a context switch is    * required. */    portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );&#125;// ...if( pxTCB == pxCurrentTCB )&#123;    configASSERT( uxSchedulerSuspended == 0 );    portYIELD_WITHIN_API();&#125;// ...\n这是FreeRTOS线程删除时是进行的一些操作，当判断为删除当前线程(pxCurrentTCB)是会进行的额外操作。FreeRTOS是不能直接删除线程自身的，它是将自己标记为预删除的状态，然后操作系统切换到Idle线程中时去清理这些需要被删除的线程，此外这里还会进行一次主动的线程调度，这是非常危险的，当线程出现错误后，如果继续进行常规调度流程，这可能会涉及到访问错误线程的栈空间，这是不可靠的(导致更严重的错误)。所以线程清理仅仅是让操作系统不再调度这个错误的线程，与原错误线程相关的操作降低到最少。\n进行一次特别的线程调度有何特别？这里的线程调度操作将没有切出线程，只有切入线程，因为本该切入的线程在刚刚前面那段代码中删除了。所以这里的线程调度就不能直接使用系统的API完成调度，这里需要自己实现一段线程调度的代码。这里以一段ARM汇编来实现这段调度程序。\nbic r3, lr, #7cmn r3, #8beq .endbl clean_fault_taskcmp r0, #0beq .endldr r0, [r0]ldmia r0!, &#123;r4-r11, r14&#125;tst r14, #0x10it eqvldmiaeq r0!, &#123;s16-s31&#125;msr psp, r0isbmov r0, #0msr basepri, r0bx r14.end: b .end\n这段汇编代码分为4个部分，第一段，这里是通过LR寄存器的值来判断触发异常是否是在普通的线程中，如果不是在线程中触发的异常将不能处理，直接跳转到最后的死循环中。第二段，调用前面实现的任务清理函数，清理掉错误线程并选择一个新的可运行线程(这里就是Idle线程)，函数返回后，判断r0，如果无法清理错误线程或者没有可用的线程，仍然跳转到最后的死循环中。第三段，r0就是前面函数返回时传递过来的新的线程句柄，它存储的第一个字段就是该线程的栈，栈里面存储的内容结构涉及到FreeRTOS线程调度相关的内容。这里就简单说一说FreeRTOS的任务调度时的栈内结构，栈里面存储的是r4-r11寄存器，这些寄存器是ARM异常处理无法自动保存的。此外还有保存r14(lr)寄存器，它是用来判断栈内是否存储了浮点寄存器的，LR寄存器的bit4指示了线程是否在使用浮点寄存器。由于s0-s15以及浮点状态寄存器FPSR是直接由ARM异常自动完成存取了，所以这里还需要根据线程是否使用了浮点寄存器来存储s16-s31寄存器。\n将待切入运行的线程相关的寄存器都恢复完毕后，就可以退出异常并转入到新的线程去执行了，也就是第四段代码的内容。\n封装异常处理将前面汇编代码进行封装，这样就能够处理多个Fault异常了。\n// fault_handle.h#ifndef _FAULT_HANDLE_H#define _FAULT_HANDLE_H#if defined(__CC_ARM)#define FAULT_HANDLER()#elif defined(__GNUC__)#define FAULT_HANDLER() \\    (&#123; \\    __asm volatile ( \\        &quot;   push &#123;r0, r1, r2, r3, r12, lr&#125;  \\n&quot; \\        /* Exception not returned to Handle mode */ \\        &quot;   bic r3, lr, #7                  \\n&quot; \\        &quot;   cmn r3, #8                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;                                   \\n&quot; \\        /* Clean fault task and get the pxCurrentTCB address. */ \\        &quot;   bl clean_fault_task             \\n&quot; \\        &quot;   cmp r0, #0                      \\n&quot; \\        &quot;   beq .end&quot; END_LINE &quot;            \\n&quot; \\        &quot;   add sp, #24                     \\n&quot; \\        &quot;                                   \\n&quot; \\        /* The first item in pxCurrentTCB is the task top of stack. */ \\        &quot;   ldr r0, [r0]                    \\n&quot; \\        /* Pop the registers that are not automatically saved on \\           exception entry and the critical nesting count. */ \\        &quot;   ldmia r0!, &#123;r4-r11, r14&#125;        \\n&quot; \\        /* Is the task using the FPU context?  If so, pop the high vfp registers too. */ \\        &quot;   tst r14, #0x10                  \\n&quot; \\        &quot;   it eq                           \\n&quot; \\        &quot;   vldmiaeq r0!, &#123;s16-s31&#125;         \\n&quot; \\        /* Restore the task stack pointer. */   \\        &quot;   msr psp, r0                     \\n&quot; \\        &quot;   isb                             \\n&quot; \\        &quot;   mov r0, #0                      \\n&quot; \\        &quot;   msr basepri, r0                 \\n&quot; \\        &quot;   bx r14                          \\n&quot; \\        &quot;                                   \\n&quot; \\        &quot;.end&quot; END_LINE &quot;:                  \\n&quot; \\        &quot;   pop &#123;r0, r1, r2, r3, r12, lr&#125;   \\n&quot; \\        ); \\    &#125;)#define _STR2(x) #x#define _STR(x) _STR2(x)#define END_LINE _STR(__LINE__)#endif#endif\n这段代码实现比前面的汇编多了一些内容，主要是要考虑堆栈平衡以及异常线程清理失败后的恢复线程的问题。前面处理失败是进入一个死循环中，这里没有进入死循环。处理失败后所有的寄存器会恢复到处理前的状态，这样能够为其它错误分析类的程序提供帮助，比如我前面有篇文章讲解了如何进行栈回溯，那段程序就能够衔接在这段程序前面或者后面，帮助分析异常问题。\n这里需要特别提醒，栈平衡是非常重要的一点，尤其是使用汇编来操作栈空间时。要知道，bx lr后后面的代码是无法继续执行的，所以需要保证进入Fault时到执行bx lr时msp栈是平衡的。如果栈不平衡就会导致栈内存空间异常减小。这段宏定义是内联汇编，当它嵌入到C函数后，函数头是否还有栈操作我不确定。可能不同的编译器情况不一样，但我用GCC时没有发现问题。如果你想要把这段代码移植到你的系统中，最好仔细核对栈平衡相关的内容。\n相比于最开始的while(1)，新的异常处理程序可以写为：\nvoid xxxFault_Handler(void)&#123;    FAULT_HANDLER()；    while (1)    &#123;    &#125;&#125;\n这样当一个线程执行出现异常后能够自动停止并继续进行系统调度，保证了系统的持续运行。\n总结通过这种处理方式能够解决线程错误带来的死机问题，但是在实际的生产运行过程中，还需要其它辅助性质的程序来帮助程序更加稳固的运行，例如可以设计一个基于定时器的守护任务，当它监视到线程崩溃结束后自动重启它。这样才更加具有实际意义。\n这段程序任然有不完美的地方，比如它不能处理非线程Fault异常，还有线程清理时是暂停它还是删除它？删除线程后相关资源是否及时回收？这些问题都需要结合实际项目进一步完善。\n"},{"title":"常见的字符串Hash算法","url":"/2021/04/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E7%AE%97%E6%B3%95/","content":"常见hash算法的碰撞概率统计\n\n\n\n10万\n50万\n100万\n500万\n1000万\n一亿\n1000万次的平均执行时间\n一亿次的平均执行时间\n一亿次的平均长度\n\n\n\nBKDRHash\n0.00002\n0.000112\n0.000251\n0.0011894\n0.0023321\n0.0229439\n0.0064134\n0.00968998\n9\n\n\nAPHash\n0\n0.000052\n0.000122\n0.0005794\n0.0011712\n0.01155826\n0.0061518\n0.01088634\n10\n\n\nDJBHash\n0.00001\n0.00011\n0.000204\n0.0011782\n0.0023154\n0.02294341\n0.0064836\n0.01098645\n9\n\n\nJSHash\n0\n0.000188\n0.00032\n0.001464\n0.0029323\n0.02876141\n0.0063464\n0.00904354\n9\n\n\nRSHash\n0.00001\n0.000122\n0.000245\n0.001154\n0.00233\n0.02290588\n0.0063627\n0.01168532\n9\n\n\nSDBMHash\n0.00002\n0.000132\n0.000235\n0.001175\n0.0023435\n0.02294529\n0.0064155\n0.01201398\n9\n\n\nPJWHash\n0.00312\n0.015032\n0.029957\n0.1386394\n0.251465\n0.83290663\n0.0067549\n0.00601705\n8\n\n\nELFHash\n0.00096\n0.005584\n0.011239\n0.0539746\n0.1028391\n0.52002744\n0.0060441\n0.00704438\n9\n\n\nMurmurHash\n0\n0\n0\n0\n0\n0\n0.0066868\n0.01194736\n19\n\n\nCityHash\n0\n0\n0\n0\n0\n0\n0.0066179\n0.01129171\n19\n\n\nFNVHash\n0.00005\n0.000186\n0.000349\n0.0016688\n0.0033469\n0.03279751\n0.0061614\n0.01018707\n9\n\n\ncrc64\n0\n0\n0\n0\n0\n0\n0.0064459\n0.01242473\n19\n\n\n1.BKDR hash function\nunsigned int bkdr_hash(const char *str)&#123;    unsigned int seed = 131; // the magic number, 31, 131, 1313, 13131, etc.. orz..    unsigned int hash = 0;    unsigned char *p = (unsigned char *)str;    while (*p)        hash = hash * seed + (*p++);    return hash;&#125;\n2.AP hash function\nunsigned int ap_hash(char *str)&#123;    unsigned int hash = 0;    int i;    for (i=0; *str; i++)        if ((i &amp; 1) == 0)            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));        else            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));    return (hash &amp; 0x7FFFFFFF);&#125;\n3.DJB hash function\nunsigned long hash_djbx33a(const char *str, size_t len)&#123;    unsigned long hash = 0U;    for(size_t i = 0;i &lt; len; ++i) &#123;        hash = hash * 33 + (unsigned long)str[i];        /* or, hash = ((hash &lt;&lt; 5) + hash) + (unsigned long)str[i];          * where, hash * 33 = ((hash &lt;&lt; 5) + hash)         */    &#125;    return hash;&#125;long long djb2(char s[])&#123;    long long hash = 5381; /* init value */    int i = 0;    while (s[i] != &#x27;\\0&#x27;)    &#123;        hash = ((hash &lt;&lt; 5) + hash) + s[i];        i++;    &#125;    return hash;&#125;\n4.JS hash function\nunsigned int js_hash(char*str)&#123;    unsigned int hash = 1315423911 ;    while(*str)    &#123;        hash ^=((hash &lt;&lt;5 ) + (*str++) + (hash &gt;&gt;2 ));    &#125;    return hash;&#125;\n5.RS hash function\nunsigned int RSHash( char * str)&#123;    unsigned int b = 378551;    unsigned int a = 63689;    unsigned int hash = 0;    while(*str)    &#123;        hash = hash * a + (*str++);        a *= b;    &#125;    return (hash &amp; 0x7FFFFFFF);&#125;\n6.SDBM hash function\nstatic unsigned long sdbm(unsigned char *str)&#123;    unsigned long hash = 0;    int c;    while (c = *str++)        hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;    return hash;&#125;\nsdbm_hash.c\n/* Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//* * sdbm - ndbm work-alike hashed database library * based on Per-Aake Larson&#x27;s Dynamic Hashing algorithms. BIT 18 (1978). * author: oz@nexus.yorku.ca * status: ex-public domain. keep it that way. * * hashing routine */#include &quot;apr_sdbm.h&quot;#include &quot;sdbm_private.h&quot;/* * polynomial conversion ignoring overflows * [this seems to work remarkably well, in fact better * then the ndbm hash function. Replace at your own risk] * use: 65599  nice. *      65587  even better.  */long sdbm_hash(const char *str, int len)&#123;    register unsigned long n = 0;#define DUFF/* go ahead and use the loop-unrolled version */#ifdef DUFF#define HASHCn = *str++ + 65599 * n    if (len &gt; 0) &#123;        register int loop = (len + 8 - 1) &gt;&gt; 3;        switch(len &amp; (8 - 1)) &#123;        case 0:do &#123;                HASHC;case 7:HASHC;        case 6:HASHC; case 5:HASHC;        case 4:HASHC; case 3:HASHC;        case 2:HASHC;case 1:HASHC;            &#125; while (--loop);        &#125;    &#125;#else    while (len--)        n = *str++ + 65599 * n;#endif    return n;&#125;\n7.PJWHash hash function\n/*  * A generic hash function HashPJW better than ElfHash point,  * but depending on the context. */#include &lt;limits.h&gt;#define BITS_IN_int     ( sizeof(int) * CHAR_BIT )#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))#define HIGH_BITS       ( ~((unsigned int)(~0) &gt;&gt; ONE_EIGHTH ))unsigned int HashPJW ( const char * datum )&#123;    unsigned int hash_value, i;    for ( hash_value = 0; *datum; ++datum )    &#123;        hash_value = ( hash_value &lt;&lt; ONE_EIGHTH ) + *datum;        if (( i = hash_value &amp; HIGH_BITS ) != 0 )            hash_value = ( hash_value ^ ( i &gt;&gt; THREE_QUARTERS )) &amp; ~HIGH_BITS;    &#125;    return ( hash_value );&#125;\n8.ELFHash hash function\n/* *    This function hash the input string &#x27;name&#x27; using the ELF hash *    function for strings. */static unsigned int hash(char* name)&#123;    unsigned int h = 0;    unsigned int g;    while(*name) &#123;        h = (h&lt;&lt;4) + *name++;        if ((g = (h &amp; 0xf0000000)))            h ^= g&gt;&gt;24;        h &amp;=~ g;    &#125;    return h;&#125;\n9.Murmur hash function\nuint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) &#123;    uint32_t h = seed;    if (len &gt; 3) &#123;        const uint32_t* key_x4 = (const uint32_t*) key;        size_t i = len &gt;&gt; 2;        do &#123;            uint32_t k = *key_x4++;            k *= 0xcc9e2d51;            k = (k &lt;&lt; 15) | (k &gt;&gt; 17);            k *= 0x1b873593;            h ^= k;            h = (h &lt;&lt; 13) | (h &gt;&gt; 19);            h = (h * 5) + 0xe6546b64;        &#125; while (--i);        key = (const uint8_t*) key_x4;    &#125;    if (len &amp; 3) &#123;        size_t i = len &amp; 3;        uint32_t k = 0;        key = &amp;key[i - 1];        do &#123;        k &lt;&lt;= 8;        k |= *key--;        &#125; while (--i);        k *= 0xcc9e2d51;        k = (k &lt;&lt; 15) | (k &gt;&gt; 17);        k *= 0x1b873593;        h ^= k;    &#125;    h ^= len;    h ^= h &gt;&gt; 16;    h *= 0x85ebca6b;    h ^= h &gt;&gt; 13;    h *= 0xc2b2ae35;    h ^= h &gt;&gt; 16;    return h;&#125;\n10.City hash function\n/*  * CityHash 的主要优点是大部分步骤包含了至少两步独立的数学运算 * 代码较同类流行算法复杂 */\n11.FNVHashFNV-1 hash\nhash &#x3D; FNV_offset_basisfor each byte_of_data to be hashed    hash &#x3D; hash × FNV_prime    hash &#x3D; hash XOR byte_of_datareturn hash\nFNV-1a hash\nhash &#x3D; FNV_offset_basisfor each byte_of_data to be hashed    hash &#x3D; hash XOR byte_of_data    hash &#x3D; hash × FNV_primereturn hash\n其它的比较\n\n\nHash函数\n数据1\n数据2\n数据3\n数据4\n数据1得分\n数据2得分\n数据3得分\n数据4得分\n平均分\n\n\n\nBKDRHash\n2\n0\n4774\n481\n96.55\n100\n90.95\n82.05\n92.64\n\n\nAPHash\n2\n3\n4754\n493\n96.55\n88.46\n100\n51.28\n86.28\n\n\nDJBHash\n2\n2\n4975\n474\n96.55\n92.31\n0\n100\n83.43\n\n\nJSHash\n1\n4\n4761\n506\n100\n84.62\n96.83\n17.95\n81.94\n\n\nRSHash\n1\n0\n4861\n505\n100\n100\n51.58\n20.51\n75.96\n\n\nSDBMHash\n3\n2\n4849\n504\n93.1\n92.31\n57.01\n23.08\n72.41\n\n\nPJWHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\nELFHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\n其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。\n经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。\n在信息修竞赛中，要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的。\n"},{"title":"统计FreeRTOS中各个线程的处理器利用率","url":"/2021/12/18/%E7%BB%9F%E8%AE%A1FreeRTOS%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E5%88%A9%E7%94%A8%E7%8E%87/","content":"\n大约是在一年前，我在工作中遇到了需要分析嵌入式系统性能的需求，需要查看系统在关键时间点上，部分任务是否存在执行时间过长导致系统实时性能降低的情况。我在基于FreeRTOS的系统中设计了一段非侵入式的代码，能够获取到各个线程实时的处理器利用率，进而分析系统是否设计合理。最近我在整理以前的代码时又看到当时设计的这个功能，我发现当时仅仅是满足了一个基本的功能需求，部分地方还设计的不是足够的合理，所以最近抽空想把这个功能整理完善，以备以后工作之需。\n\n处理器利用率如何理解处理器利用率？这里摘抄了Linux系统中对这个词的理解：\nCPU Usage:The task&#39;s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time.\n翻译过来差不多就是指在一段时间长度T内，线程A的运行时间占用了t，则在这段T时间端内，线程A的处理器利用率为 t/T。如果了解操作系统运作的原理，再来理解处理器利用率是非常简单的。\n统计每个线程的执行时间FreeRTOS操作系统内核本身是支持统计任务执行时间的，但是它是统计从任务开始运行时计算的，这种统计方法无法分析实时的处理器利用率，而且长时间的记录会导致内部时间计数器溢出，所以需要重新设计统计线程执行时间的功能。\n统计一个任务的执行时间长度需要在任务开始运行和结束运行的时间点上计时，这里的开始运行和结束运行是指任务对处理器的占用情况，而不是指任务真正的开始和结束。结合FreeRTOS内核可以利用内核提前设计好的Hook机制找到任务进入和退出的时机，也就是下面两个宏：\n#ifndef traceTASK_SWITCHED_IN/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the selected task. */    #define traceTASK_SWITCHED_IN()#endif#ifndef traceTASK_SWITCHED_OUT/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer * to the task control block of the task being switched out. */    #define traceTASK_SWITCHED_OUT()#endif\n这里的注释非常好理解，根据这两个Hook函数和pxCurrentTCB就能够掌握每个线程的切换情况。这里先说明一点，这个功能对FreeRTOS内核是非侵入的，不会到FreeRTOS内核代码做任何改动。\n接下来就是需要设计一个高精度的定时器，以我的经验来看定时器精度至少要达到微秒级别以上才行，因为有时候线程的切入和切出非常的块，定时器精度不够的话就无法准确的计算执行时间。\n这里我采用的高精度定时器是DWT内核调试模块的计时单元，它的运行频率和处理器一致，所以定时精度是足够的，而且32位的计数器也能够满足一定时间长度的计时需求，这个内核调试模块在ARM Cortex-M处理器中都存在。\n这里是我设计的DWT计时功能代码：\n/* cpu tick timer config. */#define TIME_SEC_TO_US (1000000u)#define CPU_CLK_FREQ() (SystemCoreClock)#if defined(DWT) &amp;&amp; defined(CoreDebug)static unsigned int fclk_pre_us;static inline void cpu_ts_time_init(void)&#123;    fclk_pre_us = CPU_CLK_FREQ() / TIME_SEC_TO_US;    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;    DWT-&gt;CTRL        |= DWT_CTRL_CYCCNTENA_Msk;    DWT-&gt;CYCCNT       = 0;&#125;static inline unsigned int cpu_ts_timrd(void)&#123;    //return us    return (DWT-&gt;CYCCNT / fclk_pre_us);&#125;static inline void cpu_ts_reset(void)&#123;    DWT-&gt;CYCCNT = 0;&#125;\n提供了计数器初始化、复位、记录时间的功能。\n记录FreeRTOS各个任务的运行时间建立一个长度为MAX_TASK_NUMS的数组task_runtime用于存储每个任务的执行时间，数组中的每一项对应一个任务，所以需要为每个任务分配一个唯一的ID，FreeRTOS内核为每个任务分配了独立的ID，但是这些ID是不受控制的，即ID的分配总是递增的，任务删除后不会回收。所以需要为每个任务重新分配ID并在任务删除后做回收的处理。\n#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;\n分配ID的过程是足够简单的，不会对系统的性能产生太多额外的影响。同样的利用Hook机制，把它嵌入到FreeRTOS内核中。\n// FreeRTOSConfig.h#define traceTASK_CREATE(pxTCB)  alloc_task_id(pxTCB)#define traceTASK_DELETE(pxTCB)  release_task_id(pxTCB)\n通过task_runtime[(TASK_ID(pxCurrentTCB))]就能记录和访问线程的运行时间。\n接下来就是最关键的traceTASK_SWITCHED_IN()和traceTASK_SWITCHED_OUT()，它们看起来还是比较简单的，一个最基础的逻辑如下：\nstatic uint32_t switch_in_time = 0;static uint32_t task_runtime[MAX_TASK_NUMS] = &#123;0&#125;;void task_switched_out(void)&#123;    task_runtime[(TASK_ID(pxCurrentTCB))] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();&#125;\n到此就实现了记录任务的运行时间，但是这和FreeRTOS内部的实现是类似的，我们需要在适当的时候清空所有的任务运行时间并重置计数器，保证系统总是记录任务最新的处理器利用率。\n记录任务实时的处理器利用率如果只有一个缓存记录处理器的运行时间，就会存在一个这样的情况，当运行时间情况的时候，正好需要查看处理器的利用率，那此时就看不到准确的数据。所以设计两个缓存，一个用于记录当前的数据，另一个用于缓存上一次的数据并给予用户访问。\n最终完整的设计实现如下：\nextern void* pxCurrentTCB;#define STAT_PERIOD (3000000u)#define TASK_ID(task) (((StaticTask_t*)(task))-&gt;uxDummy10[0])#define CURRENT_TASK_ID (TASK_ID(pxCurrentTCB))#define MAX_TASK_NUMS (32)static uint32_t switch_in_time = 0;static uint32_t task_runtime_buf1[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_runtime_buf2[MAX_TASK_NUMS] = &#123;0&#125;;static uint32_t task_total_runtime = 0;static uint32_t *task_current_runtime = task_runtime_buf1;void task_switched_out(void)&#123;    task_current_runtime[CURRENT_TASK_ID] += cpu_ts_timrd() - switch_in_time;&#125;void task_switched_in(void)&#123;    switch_in_time = cpu_ts_timrd();    if(switch_in_time == 0)&#123;        cpu_ts_time_init();        switch_in_time = cpu_ts_timrd();    &#125;    if(switch_in_time &gt; STAT_PERIOD)&#123;        cpu_ts_reset();        task_total_runtime = switch_in_time;        switch_in_time = 0;        if(task_current_runtime == task_runtime_buf1)            task_current_runtime = task_runtime_buf2;        else            task_current_runtime = task_runtime_buf1;        for(int i = 0; i &lt; MAX_TASK_NUMS; i++) task_current_runtime[i] = 0;    &#125;&#125;/*  * bit0 used for other task(id &gt;= 32) * other bit used for every task. */static uint32_t id_pool = 1u; /* hook to task create. */void alloc_task_id(void* task)&#123;    if(!task)        return ;    if(id_pool == 0xffffffff)&#123;        /* The task pool is full. */        TASK_ID(task) = 0;        return ;    &#125;    uint32_t new_pool = id_pool | (id_pool + 1u);    TASK_ID(task) = 31u - __CLZ(id_pool ^ new_pool);    id_pool = new_pool;&#125;/* hook to task delete. */void release_task_id(void* task)&#123;    if(!task)        return ;    uint8_t id = TASK_ID(task);    if(id == 0)&#123;        return ;    &#125;    id_pool &amp;= ~(1u &lt;&lt; id);&#125;static int task_id_exist(int id)&#123;    return (id_pool &amp; (1 &lt;&lt; id));&#125;static const uint32_t *get_task_runtime(void)&#123;    if(task_current_runtime == task_runtime_buf1)        return task_runtime_buf2;    else        return task_runtime_buf1;&#125;int show_cpu_usage(int argc, char **argv)&#123;    char buf[1024] = &#123;0&#125;;    int buf_len = 0;    // os_enter_critical();    const uint32_t *tick_buf = get_task_runtime();    float r = 0;    uint32_t irq_runtime = task_total_runtime;    for(int i = 0; i &lt; MAX_TASK_NUMS; i++)&#123;        if(!task_id_exist(i))&#123;            continue;        &#125;        if(i == 0)&#123;            if(tick_buf[i] &gt; 0)                buf_len += sprintf(buf + buf_len, &quot;&gt;32 --  &quot;);            else                continue;        &#125;else&#123;            buf_len += sprintf(buf + buf_len, &quot;%2d  --  &quot;, i);        &#125;        if(tick_buf[i] == 0)&#123;            buf_len += sprintf(buf + buf_len, &quot;0\\n&quot;);        &#125;else&#123;            r = 100.0f * (float)tick_buf[i] / task_total_runtime;            if(r &lt; 0.01f)                buf_len += sprintf(buf + buf_len, &quot;&lt;0.01%%\\n&quot;);            else                buf_len += sprintf(buf + buf_len, &quot;%.2f%%\\n&quot;, r);        &#125;        irq_runtime -= tick_buf[i];    &#125;    r = 100.0f * (float)irq_runtime / task_total_runtime;    buf_len += sprintf(buf + buf_len, &quot;IS  --  %.2f%%\\n&quot;, r);    // os_exit_critical(0);    puts(buf);    return 0;&#125;\n记录周期为3000ms，这个时间需要结合定时器的溢出时间、系统性能要求做调整，时间太短会影响系统调度性能，太长会导致处理器利用率统计的实时性降低，且计数器存在溢出的风险。\n最后这里写了一段简单的代码来输出各个任务的CPU利用率，经过我的测试，它能够很好的工作。访问数据时建议进入到临界区处理，这样更加安全。在实际使用时，每个线程使用ID表示的，ID和任务名称的关系可以通过FreeRTOS内核函数vTaskList()得到，一一对应即可。\n总结内容我写的比较仓促，其中部分细节我没有太多的说明，但我认为这些都是比较好理解。关于任务ID的分配，还有些细节没有说明，我将超过31个任务后面的任务ID统一分配为0，它们的处理器利用率将一并计算，这是我的ID分配器决定的，它只能分配31个ID。\n当时我实现这个功能时忽略了FreeRTOS内核对任务ID的分配策略，当时我直接引用系统分配的ID，如果不对任务进行删除操作，他还是能够可靠的工作。但是如果需要进行任务删除，那么就会出现一些奇怪的问题。我也是最近才发现这个问题。主要是当时对FreeRTOS内核内的一些细节还是不够了解。\n关于中断的执行时间，我这里只是粗略的估算了一个irq_runtime ，它包含了大部分任务调度的时间，并不能够保证把所有的中断时间统计在内。\n这里涉及到了高精度定时器、快速ID的分配、双缓冲机制、内核调度、非侵入式设计等待内容，每个都能够拿出来细讲，限于时间和篇幅就点到为止。如果你有幸看到这篇文章，对其中的内容有疑问或者建议，欢迎一起沟通学习。\n"},{"title":"Macro returning the number of arguments it is given in C?","url":"/2021/03/22/Macro%20returning%20the%20number%20of%20arguments%20it%20is%20given%20in%20C/","content":"一个简单的实现能否使用一个简单的宏在C语言中计算不定参数的数量，例如这样:\nfoo(1) -&gt; 1foo(cat, dog) -&gt; 2foo(red, green, blue) -&gt; 3\n一个比较简单的实现是这样的：\n#define PP_NARG(...) (sizeof((const void*[])&#123;__VA_ARGS__&#125;)/sizeof(void*))\n当参数为空时可能在某些编译器下不能正常的工作，但是稍微修改一下就行了。\n#define PP_NARG(...) (sizeof((int[])&#123;0, ##__VA_ARGS__&#125;)/sizeof(int) - 1)#pragma GCC diagnostic ignored &quot;-Wint-conversion&quot; /* Ignore warning */\n这里需要知道使用sizeof()关键字，这意味着它不是在预处理阶段计算不定参数的长度。同时要求参数必须为有意义的符号。这就限制了它的使用场景，比如说将不定参数的个数作为数组定义时的长度。\n另外一种有趣的写法这是我从网上找到的一种写法，它能够处理1~64个不定产生的情况，它没有依赖于编译器的关键字，仅仅靠预处理就完成了参数的计数。\n#ifndef JLSS_ID_NARG_H#define JLSS_ID_NARG_H/*** http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5?pli=1****    Newsgroups: comp.std.c**    From: Laurent Deniau &lt;laurent.deniau@cern.ch&gt;**    Date: Mon, 16 Jan 2006 18:43:40 +0100**    Subject: __VA_NARG__****    A year ago, I was asking here for an equivalent of __VA_NARG__ which**    would return the number of arguments contained in __VA_ARGS__ before its**    expansion. In fact my problem at that time (detecting for a third**    argument) was solved by the solution of P. Mensonides. But I was still**    thinking that the standard should have provided such a facilities rather**    easy to compute for cpp.****    This morning I had to face again the same problem, that is knowing the**    number of arguments contained in __VA_ARGS__ before its expansion (after**    its expansion can always be achieved if you can do it before). I found a**    simple non-iterative solution which may be of interest here as an answer**    to who will ask in the future for a kind of __VA_NARG__ in the standard**    and I post it for archiving. May be some more elegant-efficient solution**    exists?****    Returns NARG, the number of arguments contained in __VA_ARGS__ before**    expansion as far as NARG is &gt;0 and &lt;64 (cpp limits):****    #define PP_NARG( ...) PP_NARG_(__VA_ARGS__,PP_RSEQ_N())**    #define PP_NARG_(...) PP_ARG_N(__VA_ARGS__)**    #define PP_ARG_N(_1,_2,_3,_4,_5,_6,_7,_8,_9,[..],_61,_62,_63,N,...) N**    #define PP_RSEQ_N() 63,62,61,60,[..],9,8,7,6,5,4,3,2,1,0****    [..] stands for the continuation of the sequence omitted here for**    lisibility.****    PP_NARG(A) -&gt; 1**    PP_NARG(A,B) -&gt; 2**    PP_NARG(A,B,C) -&gt; 3**    PP_NARG(A,B,C,D) -&gt; 4**    PP_NARG(A,B,C,D,E) -&gt; 5**    PP_NARG(A1,A2,[..],A62,A63) -&gt; 63**** ======****    Newsgroups: comp.std.c**    From: Roland Illig &lt;roland.il...@gmx.de&gt;**    Date: Fri, 20 Jan 2006 12:58:41 +0100**    Subject: Re: __VA_NARG__****    Laurent Deniau wrote:**    &gt; This morning I had to face again the same problem, that is knowing the**    &gt; number of arguments contained in __VA_ARGS__ before its expansion (after**    &gt; its expansion can always be achieved if you can do it before). I found a**    &gt; simple non-iterative solution which may be of interest here as an answer**    &gt; to who will ask in the future for a kind of __VA_NARG__ in the standard**    &gt; and I post it for archiving. May be some more elegant-efficient solution**    &gt; exists?****    Thanks for this idea. I really like it.****    For those that only want to copy and paste it, here is the expanded version:**** // Some test cases** PP_NARG(A) -&gt; 1** PP_NARG(A,B) -&gt; 2** PP_NARG(A,B,C) -&gt; 3** PP_NARG(A,B,C,D) -&gt; 4** PP_NARG(A,B,C,D,E) -&gt; 5** PP_NARG(1,2,3,4,5,6,7,8,9,0,    //  1..10**         1,2,3,4,5,6,7,8,9,0,    // 11..20**         1,2,3,4,5,6,7,8,9,0,    // 21..30**         1,2,3,4,5,6,7,8,9,0,    // 31..40**         1,2,3,4,5,6,7,8,9,0,    // 41..50**         1,2,3,4,5,6,7,8,9,0,    // 51..60**         1,2,3) -&gt; 63****Note: using PP_NARG() without arguments would violate 6.10.3p4 of ISO C99.*//* The PP_NARG macro returns the number of arguments that have been** passed to it.*/#define PP_NARG(...) \\    PP_NARG_(__VA_ARGS__,PP_RSEQ_N())#define PP_NARG_(...) \\    PP_ARG_N(__VA_ARGS__)#define PP_ARG_N( \\     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\    _61,_62,_63,  N, ...) N#define PP_RSEQ_N() \\    63,62,61,60,                   \\    59,58,57,56,55,54,53,52,51,50, \\    49,48,47,46,45,44,43,42,41,40, \\    39,38,37,36,35,34,33,32,31,30, \\    29,28,27,26,25,24,23,22,21,20, \\    19,18,17,16,15,14,13,12,11,10, \\     9, 8, 7, 6, 5, 4, 3, 2, 1, 0#endif /* JLSS_ID_NARG_H */\n注释中也提到，当参数为空时需要编译器的特殊支持。但是我发现做适当的修改就能够避免这种尴尬的局面。\n#define PP_NARG(...)   (PP_NARG_(0, ##__VA_ARGS__, PP_RSEQ_N()) - 1)\n只要参数不超过64个，它都能很好的工作，而且在预处理阶段就能计算出参数的个数。\n总结我参考了大量其他人的写法，其中的基本原理大都是基于这两种思想。在C++中我还看到其它的解法，但是我目前还没有想到在C++中需要统计不定参数个数的地方。\n#include &lt;tuple&gt;#define MACRO(...) \\    std::cout &lt;&lt;&quot;num args:&quot; \\    &lt;&lt; std::tuple_size&lt;decltype(std::make_tuple(__VA_ARGS__))&gt;::value \\    &lt;&lt; std::endl;/* Another way */#define VA_COUNT(...) detail::va_count(__VA_ARGS__)namespace detail&#123;    template&lt;typename ...Args&gt;    constexpr std::size_t va_count(Args&amp;&amp;...) &#123; return sizeof...(Args); &#125;&#125;\n应用能够计算不定参数个数对于实现函数静态优化有一定意义，在代码中判断参数个数调用不同的函数实现，相当于实现了函数多态的一种特性。\n"},{"title":"FreeRTOS中协程支持低功耗吗","url":"/2022/09/06/FreeRTOS%E4%B8%AD%E5%8D%8F%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BD%8E%E5%8A%9F%E8%80%97%E5%90%97/","content":"FreeRTOS协程FreeRTOS除了支持多线程外，还支持另外一种多任务机制-协程(coroutine)。它和线程不一样，每个协程不需要独立的运行空间，它依靠编程语法技巧在逻辑上实现了多任务的机制。它避免的一般RTOS带来的栈切换开销，仅仅依靠极小的开销就能保存任务的中间状态并在适当的时刻快速恢复任务。简单来说就是任务需要切换时先记录当前执行的位置并返回，重新进入该任务时根据保存的位置恢复任务执行，所以它不支持任务间抢占，所以任务的实时性也比较有限，但是它多任务时的低开销特性在许多场景下具有比较明显的优势。\nFreeRTOS使用C语言提供的switch-case语法作为实现协程的关键，switch-case能够进行非常灵活的跳转，这个真的超乎一般人对switch用法的理解(点名达夫设备)。此外由于多个协程任务共享同一个栈空间，所以协程中无法使用生命周期比较长的局部变量，即定义的局部变量在使用的整个生命周期内不能进行协程的任务调度，一旦发生任务调度，则局部变量的数据就有可能丢失，所以在设计协程时通常使用全局变量来避免使用栈空间内的局部变量数据。\n在设计协程任务时需要根据一定的代码模板来设计，因为协程的核心是由语法来实现的，所以代码无法设计的足够的灵活，存在许多的设计和用法限制。\n低功耗特性协程意味着任务过程简单，在现实应用场景下，简单任务和低功耗特性通常一起出现，那使用FreeRTOS的协程支持低功耗吗？根据FreeRTOS的参考文档来看，官方并没有提及协程+低功耗的用法，但是这两个特性正好是FreeRTOS都支持的，这两个特性能够独立正常工作。那合并到一起呢？\n冲突官方推荐的协程调度方案是这样的：\nvoid vApplicationIdleHook( void )&#123;    for( ;; )    &#123;        vCoRoutineSchedule();    &#125;&#125;\n使用IDLE任务的hook来进行协程的调度。那进一步看看该hook在Idle任务中的执行位置：\n// ...#if ( configUSE_IDLE_HOOK == 1 )&#123;    extern void vApplicationIdleHook( void );    /* Call the user defined function from within the idle task.  This     * allows the application designer to add background functionality     * without the overhead of a separate task.     * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,     * CALL A FUNCTION THAT MIGHT BLOCK. */    vApplicationIdleHook();&#125;#endif /* configUSE_IDLE_HOOK *//* This conditional compilation should use inequality to 0, not equality * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when * user defined low power mode  implementations require * configUSE_TICKLESS_IDLE to be set to a value other than 1. */#if ( configUSE_TICKLESS_IDLE != 0 )&#123;    TickType_t xExpectedIdleTime;    /* It is not desirable to suspend then resume the scheduler on     * each iteration of the idle task.  Therefore, a preliminary     * test of the expected idle time is performed without the     * scheduler suspended.  The result here is not necessarily     * valid. */    xExpectedIdleTime = prvGetExpectedIdleTime();    // ...&#125;#endif /* configUSE_TICKLESS_IDLE */\n到这里应该发现问题了吧。vApplicationIdleHook比TICKLESS处理要先执行，而协程的调度实现是一个死循环，这意味着idle任务没有时机来进行TICKLESS处理，导致系统无法进入低功耗状态。\n这里解释一下vCoRoutineSchedule()为什么需要放到一个无限循环中，这是该协程框架决定的，该调度函数需要一直执行，该函数并不返回一些调度状态，导致我们无法决定协程调度的时机，为了协程的正常运行，所以协程就必须要一直进行调度。而最终的结果就是使用协程后，FreeRTOS的低功耗特性就失效了。\n曙光分析到这里的时候，我突然有一个疑惑，FreeRTOS已经设计了非常完善的配置机制，为什么它没有考虑到这两个功能的用法冲突，进而在配置上进行处理呢。比如说开启协程后就禁止使用低功耗特性。这是不是意味着有什么方法能够突破这个限制，所以官方故意在配置上留下了同时启用两种功能的可能性。\n我重新开始梳理了FreeRTOS的协程和低功耗实现方案，发现现有的设计是无法实现的。将协程调度放入到单独的线程中是最接近的一个实现方案：\nvoid CoRoutineTask(void *p)&#123;    for(;;)&#123;        vCoRoutineSchedule();        // vTaskDelay(?);    &#125;&#125;\n该任务的优先级如何确定呢？协程中的延时是否需要？延时多长？只要优先级比idle任务高且存在任意时间的延时，低功耗的tickless就可执行。但是难点是无法确定延时时间。\n协程没有实现计算下一次协程调度的时机函数。对于任务来说，prvGetExpectedIdleTime()函数能够计算出下一次进行任务调度的期望时间。所以我们也需要一个这样的函数，计算下一次进行协程调度的期望时间。实现了这个函数将是在协程下实现低功耗的希望。\n下一次协程调度到底需要多长时间检索这些数据就能知道答案：\n\n1.等待任务列表(pxDelayedCoRoutineList)\n2.就绪任务列表(pxReadyCoRoutineLists)\n3.即将就绪任务列表(xPendingReadyCoRoutineList)\n\n最后一个是很容易忽视的，在进行协程间通信时，任务并不是直接切换到就绪任务列表中，而是添加到了待就绪任务列表(这是为了保证就绪任务列表不在中断中进行修改)。所以在检索任务时该列表中的任务可以看作时任务已经就绪了。\n当就绪任务列表非空或者即将就绪任务列表非空意味着协程需要立即调度。当等待任务列表中的任务已经超时了也要立即调度。否则就根据等待任务列表中等待时间最少的任务来计算下一次协程调度的时间。此外，还需要注意所有列表为空的情况，这可以认为下一次调度的时间为无限长。\nTickType_t xGetExpectedIdleTime( void )&#123;    CRCB_t * pxCRCB;    UBaseType_t uxPriority;    TickType_t xIdleTime;    if( listLIST_IS_EMPTY( &amp;xPendingReadyCoRoutineList ) == pdFALSE )    &#123;        xIdleTime = 0u;    &#125;    else    &#123;        xIdleTime = portMAX_DELAY;        for( uxPriority = 0; uxPriority &lt; configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )        &#123;            if( listLIST_IS_EMPTY( &amp;( pxReadyCoRoutineLists[ uxPriority ] ) ) == pdFALSE )            &#123;                xIdleTime = 0u;                break;            &#125;        &#125;        if(xIdleTime &gt; 0u)        &#123;            if( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )            &#123;                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );                if(xCoRoutineTickCount &lt; listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )))                &#123;                    xIdleTime = listGET_LIST_ITEM_VALUE( &amp;( pxCRCB-&gt;xGenericListItem )) - xCoRoutineTickCount;                &#125;                else                &#123;                    xIdleTime = 0u;                &#125;            &#125;            else            &#123;                mtCOVERAGE_TEST_MARKER();            &#125;        &#125;    &#125;    return xIdleTime;&#125;\n在代码风格上参考了FreeRTOS相类似的代码风格。这里检查了所有优先级的就绪任务列表(从高优先级到低优先级应该会更快)，可以考虑仅仅检查uxTopCoRoutineReadyPriority优先级的列表，这样在优先级较多的时候可以执行的更快。\n协程运行在可休眠的线程中能够计算协程的调度时机后，我们就能将协程放入到一个可休眠的线程中，而不是在阻塞的无限循环中执行。\nvoid vCoScheduleTask( void )&#123;    // ...    for( ;; )    &#123;        vCoRoutineSchedule();        uint32_t idle_time = xGetExpectedIdleTime();        if(idle_time &gt; 0)        &#123;            vTaskDelay(idle_time);        &#125;    &#125;&#125;\n该线程的优先级比Idle线程略高。这样在保证正常的协程调度的情况下，系统也能够正常的运行idle线程，保证tickless中的prvGetExpectedIdleTime()函数能够计算出合理的系统线程调度休眠时间，进而实现了协程和低功耗特性的共存。\n最后xGetExpectedIdleTime()函数需要直接实现在croutine.c和.h文件中，所以会对FreeRTOS代码源文件进行修改，但是这没有对现存的代码进行进行逻辑上的更改，所以这样的修改是可控的。\n上面还有一点未提及，如果在中断中同协程进行通信，协程还能够响应吗？需要如何修改才能实现在中断中同协程通信且不影响现有的低功耗特性？其实只需要做简单的修改即可，欢迎讨论。\n"}]
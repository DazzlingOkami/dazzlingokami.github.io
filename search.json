[{"title":"ARM嵌入式开发中的栈回溯机制","url":"/2021/07/25/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%A0%88%E5%9B%9E%E6%BA%AF%E6%9C%BA%E5%88%B6/","content":"两种ABI规范根据编译器的实现不同，存在两种ABI机制，分别为APCS(ARM Procedure Call Standard)和AAPCS(ARM Archtecture Procedure Call Standard)。两种机制存在明显的区别，且单独APCS和AAPCS又有很多变种，这里就不详细展开叙述其本质。本文主要讨论分析栈帧相关的内容，所以这里仅仅介绍这两种ABI机制下栈帧的区别。\nAPCS规范下函数调用和栈帧相关寄存器APCS中规定了几个别名寄存器，分别是fp、ip、sp、lr、pc寄存器，它们实际对应的寄存器及含有有下表：\n\n\n\nAPCS\nReg\n意义\n\n\n\nfp\nr11\n栈帧指针寄存器\n\n\nip\nr12\n临时变量寄存器\n\n\nsp\nr13\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧函数调用入口处将pc、lr、sp、fp寄存器依次入栈。入栈前先将sp保存到ip，入栈后再将ip的值给fp，这样fp的值就是当前栈帧的起始位置。后续如果需要使用局部变量，就将sp减一个值实现在栈空间上开辟局部变量的空间。函数退出前将sp寄存器处理到堆栈平衡状态，再通过fp寄存器找到当前函数的栈帧位置，通过栈帧找到返回函数的fp寄存器和sp寄存器、lr寄存器。简要的代码如下：\n&lt;func1&gt;:mov ip, sppush &#123;fp, ip, lr, pc&#125;sub fp, ip, #4sub sp, sp, #8      ;8 字节局部变量空间;...sub sp, fp, #12ldm sp, &#123;fp, sp, pc&#125;\n通过分析栈帧格式我们能够知道在函数任意位置，都能够通过fp寄存器找到当前栈帧位置，而不必考虑当前使用了多少局部变量空间，栈帧中能够得到当前函数的返回地址(lr)，当前运行地址(pc)，栈地址(sp)，同时根据栈帧中上一个函数的fp寄存器再找到上一层函数的栈帧数据，这样层层回溯就实现了栈的回溯。\n如何使用APCSgcc手册上对使用APCS有相关的描述和控制选项，-mapcs-frame选项编译出来的代码就是使用APCS规范，默认情况是-mno-apcs-frame，关于这个选项的描述GCC手册原文是：\nGenerate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying -fomit-frame-pointer with this option causes the stack frames not to be generated for leaf functions. The default is -mno-apcs-frame. This option is deprecated.\n这里说明了使用相关选项可以保证APCS的栈帧格式，如果不适用这个选项则不保证。APCS为1993年推出的标准，在后续推出AAPCS相关版本后它已经显得太旧了。在gcc5.0之后，该选项已经被遗弃，所以新版本的编译器已经不能使用APCS调用方式进行栈回溯。\nAAPCS下函数的调用相关寄存器AAPCS相比于APCS少了几个别名寄存器。它有sp、lr、pc寄存器，对应表如下：\n\n\n\nAPCS\nReg\n意义\n\n\n\nsp\nr13(ARM)/r7(THUMB)\n栈指针寄存器\n\n\nlr\nr14\n链接寄存器\n\n\npc\nr15\n程序位置寄存器\n\n\n函数调用时的栈帧在这种调用规范下，栈的回溯要比APCS下要复杂的多，函数的调用过程中不保存栈帧的指针，而且栈帧中也没有固定的格式，所以不能通过当前的栈帧层层返回数据。所以仅仅通过堆栈数据是不能进行栈回溯的。那么这种模式下如何保证堆栈平衡，能不能通过汇编代码的堆栈平衡实现栈回溯呢？通过前面我们知道APCS模式下函数进入到退出时的堆栈平衡时通过保存sp寄存器和恢复sp寄存器实现的。而AAPCS模式下堆栈平衡是直接依靠pop和push平衡实现的，即不会直接修改sp来实现堆栈平衡。通过前面的分析，如果我们能够准确知道每个函数关于栈的操作，这样也能够实现栈的跟踪。通过适当的编译选项，我们能够将这部信息收集到一起，这就是arm exception handler index，简称ARM.exidx，这段数据就能指导我们实现栈回溯，把这种栈回溯方式称为unwind。\nARM.exidx位置和结构不同的编译器如何编译出exidx表具有不同的方式，但是如果可执行文件中包括exidx表，那么使用readelf -S file.elf 能够看到可执行文件中存在一个名为.ARM.exidx，类型为ARM_EXIDX的段。这就表示编译器已经生产的exidx段。关于exidx的结构及其含义这里做一个简单介绍，详细信息可以参考ARM官方网站。exidx是一个由多个相同单元组成的表，每个单元由两个uint32_t的数据构成，结构类似于：\nstruct &#123;    uint32_t offset;    uint32_t world;&#125;\n其中offset表示目标函数到当前位置的偏移，它的最高位固定为0。而world中存放了编码数据，它表示了对栈的不同操作，通过操作它就能够知道目标函数上关于栈的操作。\nLinux中的栈回溯Linux中关于ARM架构的栈回溯就是使用的exidx表实现的，这里以linux5.3版本内核中关于unwind frame的代码进行演示。涉及的主要代码文件有arch/arm/kernel/unwind.c arch/arm/include/asm/unwind.h arch/arm/include/asm/ptrace.h stacktrace.h等。主要将unwind.c移植到我们的嵌入式平台就能够使用unwind栈回溯了。\n代码移植由于linux中存在内核空间和用户空间，两种空间下存在各种的exidx表，而通常我们的代码没有所谓的两个地址空间。所以需要将涉及到地址空间判断的全部判断为是否为代码空间段，linux对于用户空间段的exidx表是通过链表由用户手动添加的，内核段的exidx表是直接由编译符号完成的。其他的代码修改主要是涉及到Linux平台特性的。下面介绍的相关修改都是基于gcc编译器(ver&gt;5.0)实现的。\n\n1.实现两个关键的函数： #define core_kernel_text(addr)    ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)#define kernel_text_address(addr) ((addr) &gt; 0x08000000 &amp;&amp; (addr) &lt;= 0x08100000)\n2.添加日志输出的相关接口，主要就是两个，其中pr_debug日志可以选择不输出。 #define pr_debug(...) printf(__VA_ARGS__)#define pr_warn(...)  printf(__VA_ARGS__)\n3.关于分支预测的代码，可能在某些arm平台下不支持分支预测，所以这里的移植就把这个特性关闭掉。 #define likely(c)   (c)#define unlikely(c) (c)\n4.字节对齐函数，用于把某个数据按多少字节对齐。 #define ALIGN(x,a) (((x)+(a)-1)&amp;~(a-1))\n5.内存操作的相关接口，这里其实并不会使用到内存相关申请，它只是在添加用户空间exidx表时才使用，而我们的嵌入式平台上是显然是用不到的。 #define kmalloc(size, flag)  malloc(size)#define kfree(ptr)           free(ptr)\n6.exidx表的位置，不同的编译器在链接脚本中关于exidx表的起始终止位置的描述可能不一样，这里需要重新定义一下。 #define __start_unwind_idx __exidx_start#define __stop_unwind_idx  __exidx_end\n7.实现获取关键寄存器的操作，主要是获取sp寄存器，如果不是在gcc编译器中，还需要实现获取lr寄存器和sp寄存器 register char * stack_ptr asm(&quot;sp&quot;);#define current_stack_pointer ((unsigned long) stack_ptr)\n8.linux中针对部分代码使用了spinlock进行保护，在我们的嵌入式平台上通常是不需要的，当然如果有必要可以进行选择性的实现类似spinlock的操作。\n9.关于代码是arm模式还是thumb模式，如果代码是thumb模式，还需要定义一个宏，他将决定fp寄存器是r7还是r11 #define CONFIG_THUMB2_KERNEL\n10.对于.h文件，主要是是保留unwind.h文件，删除其中不相干的代码，其他头文件中可能只是会引用部分数据和数据结构可以直接拷贝到unwind.h文件中。\n11.可以选择是否保留关于添加unwind_table的相关函数，这些函数通常不会使用。\n\n除了上述代码的移植外，编译时需要开启-funwind-tables选项，使编译器能够正常生产exidx段。在连接时要保证链接脚本中有存放exidx段的位置，以及预留出索引exidx段的起止符号，类似这样的链接脚本：\n.ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH.ARM : &#123;  __exidx_start &#x3D; .;  *(.ARM.exidx*)  __exidx_end &#x3D; .;&#125; &gt;FLASH\n将代码移植到ARMCC编译器中keil作为一个应用在嵌入式开发领域的一个重要软件，如果能够将这个功能应用到ARMCC编译器环境下，那这个功能将显得更加具有现实意义。前面的移植主要是在gcc编译平台下完成的，下面介绍如何将这段代码和功能移植到ARMCC编译平台下。\n\n1.编译环境相关的设置 要使编译器能够正常编译出代码exidx数据段的代码需要开启特别的选项 –exceptions –exceptions-unwind，它的意义是开启异常处理机制，因为最初exidx段设计来就是用于处理类型c++中的异常机制的。在开启了这些选项后编译出的代码就会包含exidx段，可以使用指令进行检验查看，如readelf -S main.o，其中就能够看到相关的数据段。当然不同的文件中的exidx段还没有链接到一起，要把它们链接到一起还比较麻烦。 由于ARMCC的优化策略，未使用的数据段都会在链接阶段被优化掉，而我们由不能直接使用到exidx中的数据(没有相关的符号指向这里)，所以正常情况下，即使开启的前面的编译选项，最终编译出来的文件也没有任何区别。在链接阶段添加选项–keep *(.ARM.exidx)，这个选项的意思就是在链接时保留exidx段(注意.ARM.exidx是exidx段的标准名称，前面没有提到，不同的编译器编译出来都是这个段名，且段类型都是未ARM_EXIDX)，这样链接出来的文件可以发现会比未加这个选项的文件大了些，这就新增的exidx段数据导致的。 但是这时候还是存在一个问题，编译出的文件包含了exidx段的数据，但是却没在我们想要的地方，或者说没没办法确定这段数据在哪儿。readelf -S能够看到段的结构没有增加，而ER_IROM1段的数据变多了，这就说明exidx段的数据与代码数据放入了同一个段，这显然不是我们想要的。 修改分散加载文件，在链接选项中指定使用自定义分散加载文件。我们起始可以看到原sct文件的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address &#x3D; execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n 我们在这里添加exidx段的声明后的结构为： LR_IROM1 0x08000000 0x00120000  &#123;    ; load region size_region    ER_IROM1 0x08000000 0x00100000  &#123;  ; load address &#x3D; execution address        *.o (RESET, +First)        *(InRoot$$Sections)        .ANY (+RO)        .ANY (+XO)    &#125;    ER_EXIDX +0 0x00020000 &#123;        .ANY (.ARM.exidx)    &#125;    RW_IRAM1 0x20000100 0x00030000  &#123;  ; RW data        .ANY (+RW +ZI)    &#125;&#125;\n 经过对编译器链接器的设置，我们终于将exidx段的数据放到了期望的地方，在编译器中使用符号Image$$ER_EXIDX$$Base和Image$$ER_EXIDX$$Limit就能访问到exidx段的数据(编译器特性)。\n2.处理完成了编译器的相关内容，还需要修改源代码以适应ARMCC编译器，需要修改的地方主要体现在使用到了gcc内建函数的地方，以及gcc支持的一些拓展语法上，具体如何修改这里不做详细的介绍了。以上包括gcc和keil平台下的移植都经过测试，能够非常准确的回溯函数的调用链，包括在使用函数指针的地方都能进行准确的回溯，对于分析软件bug具有一定的帮助。\n\n技术参考本文中所设计到的内容主要来自于ARM官方的技术文档库，GCC编译手册，Linux内核源码等。可自行检索参考。\n"},{"title":"Macro returning the number of arguments it is given in C?","url":"/2021/07/25/Macro%20returning%20the%20number%20of%20arguments%20it%20is%20given%20in%20C/","content":"一个简单的实现能否使用一个简单的宏在C语言中计算不定参数的数量，例如这样:\nfoo(1) -&gt; 1foo(cat, dog) -&gt; 2foo(red, green, blue) -&gt; 3\n一个比较简单的实现是这样的：\n#define PP_NARG(...) (sizeof((const void*[])&#123;__VA_ARGS__&#125;)/sizeof(void*))\n当参数为空时可能在某些编译器下不能正常的工作，但是稍微修改一下就行了。\n#define PP_NARG(...) (sizeof((int[])&#123;0, ##__VA_ARGS__&#125;)/sizeof(int) - 1)#pragma GCC diagnostic ignored &quot;-Wint-conversion&quot; /* Ignore warning */\n这里需要知道使用sizeof()关键字，这意味着它不是在预处理阶段计算不定参数的长度。同时要求参数必须为有意义的符号。这就限制了它的使用场景，比如说将不定参数的个数作为数组定义时的长度。\n另外一种有趣的写法这是我从网上找到的一种写法，它能够处理1~64个不定产生的情况，它没有依赖于编译器的关键字，仅仅靠预处理就完成了参数的计数。\n#ifndef JLSS_ID_NARG_H#define JLSS_ID_NARG_H/*** http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5?pli=1****    Newsgroups: comp.std.c**    From: Laurent Deniau &lt;laurent.deniau@cern.ch&gt;**    Date: Mon, 16 Jan 2006 18:43:40 +0100**    Subject: __VA_NARG__****    A year ago, I was asking here for an equivalent of __VA_NARG__ which**    would return the number of arguments contained in __VA_ARGS__ before its**    expansion. In fact my problem at that time (detecting for a third**    argument) was solved by the solution of P. Mensonides. But I was still**    thinking that the standard should have provided such a facilities rather**    easy to compute for cpp.****    This morning I had to face again the same problem, that is knowing the**    number of arguments contained in __VA_ARGS__ before its expansion (after**    its expansion can always be achieved if you can do it before). I found a**    simple non-iterative solution which may be of interest here as an answer**    to who will ask in the future for a kind of __VA_NARG__ in the standard**    and I post it for archiving. May be some more elegant-efficient solution**    exists?****    Returns NARG, the number of arguments contained in __VA_ARGS__ before**    expansion as far as NARG is &gt;0 and &lt;64 (cpp limits):****    #define PP_NARG( ...) PP_NARG_(__VA_ARGS__,PP_RSEQ_N())**    #define PP_NARG_(...) PP_ARG_N(__VA_ARGS__)**    #define PP_ARG_N(_1,_2,_3,_4,_5,_6,_7,_8,_9,[..],_61,_62,_63,N,...) N**    #define PP_RSEQ_N() 63,62,61,60,[..],9,8,7,6,5,4,3,2,1,0****    [..] stands for the continuation of the sequence omitted here for**    lisibility.****    PP_NARG(A) -&gt; 1**    PP_NARG(A,B) -&gt; 2**    PP_NARG(A,B,C) -&gt; 3**    PP_NARG(A,B,C,D) -&gt; 4**    PP_NARG(A,B,C,D,E) -&gt; 5**    PP_NARG(A1,A2,[..],A62,A63) -&gt; 63**** ======****    Newsgroups: comp.std.c**    From: Roland Illig &lt;roland.il...@gmx.de&gt;**    Date: Fri, 20 Jan 2006 12:58:41 +0100**    Subject: Re: __VA_NARG__****    Laurent Deniau wrote:**    &gt; This morning I had to face again the same problem, that is knowing the**    &gt; number of arguments contained in __VA_ARGS__ before its expansion (after**    &gt; its expansion can always be achieved if you can do it before). I found a**    &gt; simple non-iterative solution which may be of interest here as an answer**    &gt; to who will ask in the future for a kind of __VA_NARG__ in the standard**    &gt; and I post it for archiving. May be some more elegant-efficient solution**    &gt; exists?****    Thanks for this idea. I really like it.****    For those that only want to copy and paste it, here is the expanded version:**** // Some test cases** PP_NARG(A) -&gt; 1** PP_NARG(A,B) -&gt; 2** PP_NARG(A,B,C) -&gt; 3** PP_NARG(A,B,C,D) -&gt; 4** PP_NARG(A,B,C,D,E) -&gt; 5** PP_NARG(1,2,3,4,5,6,7,8,9,0,    //  1..10**         1,2,3,4,5,6,7,8,9,0,    // 11..20**         1,2,3,4,5,6,7,8,9,0,    // 21..30**         1,2,3,4,5,6,7,8,9,0,    // 31..40**         1,2,3,4,5,6,7,8,9,0,    // 41..50**         1,2,3,4,5,6,7,8,9,0,    // 51..60**         1,2,3) -&gt; 63****Note: using PP_NARG() without arguments would violate 6.10.3p4 of ISO C99.*//* The PP_NARG macro returns the number of arguments that have been** passed to it.*/#define PP_NARG(...) \\    PP_NARG_(__VA_ARGS__,PP_RSEQ_N())#define PP_NARG_(...) \\    PP_ARG_N(__VA_ARGS__)#define PP_ARG_N( \\     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\    _61,_62,_63,  N, ...) N#define PP_RSEQ_N() \\    63,62,61,60,                   \\    59,58,57,56,55,54,53,52,51,50, \\    49,48,47,46,45,44,43,42,41,40, \\    39,38,37,36,35,34,33,32,31,30, \\    29,28,27,26,25,24,23,22,21,20, \\    19,18,17,16,15,14,13,12,11,10, \\     9, 8, 7, 6, 5, 4, 3, 2, 1, 0#endif /* JLSS_ID_NARG_H */\n注释中也提到，当参数为空时需要编译器的特殊支持。但是我发现做适当的修改就能够避免这种尴尬的局面。\n#define PP_NARG(...)   (PP_NARG_(0, ##__VA_ARGS__, PP_RSEQ_N()) - 1)\n只要参数不超过64个，它都能很好的工作，而且在预处理阶段就能计算出参数的个数。\n总结我参考了大量其他人的写法，其中的基本原理大都是基于这两种思想。在C++中我还看到其它的解法，但是我目前还没有想到在C++中需要统计不定参数个数的地方。\n#include &lt;tuple&gt;#define MACRO(...) \\    std::cout &lt;&lt;&quot;num args:&quot; \\    &lt;&lt; std::tuple_size&lt;decltype(std::make_tuple(__VA_ARGS__))&gt;::value \\    &lt;&lt; std::endl;/* Another way */#define VA_COUNT(...) detail::va_count(__VA_ARGS__)namespace detail&#123;    template&lt;typename ...Args&gt;    constexpr std::size_t va_count(Args&amp;&amp;...) &#123; return sizeof...(Args); &#125;&#125;\n应用能够计算不定参数个数对于实现函数静态优化有一定意义，在代码中判断参数个数调用不同的函数实现，相当于实现了函数多态的一种特性。\n"},{"title":"Recommended C style and coding rules","url":"/2021/07/25/Recommended%20C%20style%20and%20coding%20rules/","content":"This document describes C code style used by Tilen MAJERLE in his projects and libraries.\nTable of Contents\nThe single most important rule\nRecommended C style and coding rules\nGeneral rules\nComments\nFunctions\nVariables\nStructures, enumerations, typedefs\nCompound statements\nSwitch statement\n\n\nMacros and preprocessor directives\nDocumentation\nHeader/source files\nArtistic Style configuration\nEclipse formatter\n\nThe single most important ruleLet’s start with the quote from GNOME developer site.\n\nThe single most important rule when writing code is this: check the surrounding code and try to imitate it.\nAs a maintainer it is dismaying to receive a patch that is obviously in a different coding style to the surrounding code. This is disrespectful, like someone tromping into a spotlessly-clean house with muddy shoes.\nSo, whatever this document recommends, if there is already written code and you are patching it, keep its current style consistent even if it is not your favorite style.\n\nGeneral rulesHere are listed most obvious and important general rules. Please check them carefully before you continue with other chapters.\n\nUse C99 standard\n\nDo not use tabs, use spaces instead\n\nUse 4 spaces per indent level\n\nUse 1 space between keyword and opening bracket\n\nDo not use space between function name and opening bracket\nint32_t a = sum(4, 3);              /* OK */int32_t a = sum (4, 3);             /* Wrong */\nNever use __ or _ prefix for variables/functions/macros/types. This is reserved for C language itself\n\nPrefer prv_ name prefix for strictly module-private functions\n\n\nUse only lowercase characters for variables/functions/macros/types with optional underscore _ char\n\nOpening curly bracket is always at the same line as keyword (for, while, do, switch, if, …)\nsize_t i;for (i = 0; i &lt; 5; ++i) &#123;           /* OK */&#125;for (i = 0; i &lt; 5; ++i)&#123;            /* Wrong */&#125;for (i = 0; i &lt; 5; ++i)             /* Wrong */&#123;&#125;\nUse single space before and after comparison and assignment operators\nint32_t a;a = 3 + 4;              /* OK */for (a = 0; a &lt; 5; ++a) /* OK */a=3+4;                  /* Wrong */a = 3+4;                /* Wrong */for (a=0;a&lt;5;++a)       /* Wrong */\nUse single space after every comma\nfunc_name(5, 4);        /* OK */func_name(4,3);         /* Wrong */\nDo not initialize static and global variables to 0 (or NULL), let compiler do it for you\nstatic int32_t a;       /* OK */static int32_t b = 4;   /* OK */static int32_t a = 0;   /* Wrong */voidmy_func(void) &#123;    static int32_t* ptr;/* OK */    static char abc = 0;/* Wrong */&#125;\nDeclare all local variables of the same type in the same line\nvoidmy_func(void) &#123;    char a;             /* OK */    char a, b;          /* OK */    char b;             /* Wrong, variable with char type already exists */&#125;\nDeclare local variables in order\n\nCustom structures and enumerations\nInteger types, wider unsigned type first\nSingle/Double floating pointintmy_func(void) &#123;    /* 1 */    my_struct_t my;     /* First custom structures */    my_struct_ptr_t* p; /* Pointers too */    /* 2 */    uint32_t a;    int32_t b;    uint16_t c;    int16_t g;    char h;    /* ... */    /* 3 */    double d;    float f;&#125;\n\n\nAlways declare local variables at the beginning of the block, before first executable statement\n\nDeclare counter variables in for loop\n/* OK */for (size_t i = 0; i &lt; 10; ++i)/* OK, if you need counter variable later */size_t i;for (i = 0; i &lt; 10; ++i) &#123;    if (...) &#123;        break;    &#125;&#125;if (i == 10) &#123;&#125;/* Wrong */size_t i;for (i = 0; i &lt; 10; ++i) ...\nAvoid variable assignment with function call in declaration, except for single variables\nvoida(void) &#123;    /* Avoid function calls when declaring variable */    int32_t a, b = sum(1, 2);    /* Use this */    int32_t a, b;    b = sum(1, 2);    /* This is ok */    uint8_t a = 3, b = 4;&#125;\nExcept char, float or double, always use types declared in stdint.h library, eg. uint8_t for unsigned 8-bit, etc.\n\nDo not use stdbool.h library. Use 1 or 0 for true or false respectively\n/* OK */uint8_t status;status = 0;/* Wrong */#include &lt;stdbool.h&gt;bool status = true;\nNever compare against true, eg. if (check_func() == 1), use if (check_func()) &#123; ... &#125;\n\nAlways compare pointers against NULL value\nvoid* ptr;/* ... *//* OK, compare against NULL */if (ptr == NULL || ptr != NULL) &#123;&#125;/* Wrong */if (ptr || !ptr) &#123;&#125;\nAlways use pre-increment (and decrement respectively) instead of post-increment (and decrement respectively)\nint32_t a = 0;...a++;            /* Wrong */++a;            /* OK */for (size_t j = 0; j &lt; 10; ++j) &#123;&#125;  /* OK */\nAlways use size_t for length or size variables\n\nAlways use const for pointer if function should not modify memory pointed to by pointer\n\nAlways use const for function parameter or variable, if it should not be modified\n/* When d could be modified, data pointed to by d could not be modified */voidmy_func(const void* d) &#123;&#125;/* When d and data pointed to by d both could not be modified */voidmy_func(const void* const d) &#123;&#125;/* Not required, it is advised */voidmy_func(const size_t len) &#123;&#125;/* When d should not be modified inside function, only data pointed to by d could be modified */voidmy_func(void* const d) &#123;&#125;\nWhen function may accept pointer of any type, always use void *, do not use uint8_t *\n\nFunction must take care of proper casting in implementation/* * To send data, function should not modify memory pointed to by `data` variable * thus `const` keyword is important * * To send generic data (or to write them to file) * any type may be passed for data, * thus use `void *` *//* OK example */voidsend_data(const void* data, size_t len) &#123; /* OK */    /* Do not cast `void *` or `const void *` */    const uint8_t* d = data;/* Function handles proper type for internal usage */&#125;voidsend_data(const void* data, int len) &#123;    /* Wrong, not not use int */&#125;\n\n\nAlways use brackets with sizeof operator\n\nNever use Variable Length Array (VLA). Use dynamic memory allocation instead with standard C malloc and free functions or if library/project provides custom memory allocation, use its implementation\n\nTake a look at LwMEM, custom memory management library/* OK */#include &lt;stdlib.h&gt;voidmy_func(size_t size) &#123;    int32_t* arr;    arr = malloc(sizeof(*arr) * n); /* OK, Allocate memory */    arr = malloc(sizeof *arr * n);  /* Wrong, brackets for sizeof operator are missing */    if (arr == NULL) &#123;        /* FAIL, no memory */    &#125;    free(arr);  /* Free memory after usage */&#125;/* Wrong */voidmy_func(size_t size) &#123;    int32_t arr[size];  /* Wrong, do not use VLA */&#125;\n\n\nAlways compare variable against zero, except if it is treated as boolean type\n\nNever compare boolean-treated variables against zero or one. Use NOT (!) instead\nsize_t length = 5;  /* Counter variable */uint8_t is_ok = 0;  /* Boolean-treated variable */if (length)         /* Wrong, length is not treated as boolean */if (length &gt; 0)     /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (length == 0)    /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */if (is_ok)          /* OK, variable is treated as boolean */if (!is_ok)         /* OK, -||- */if (is_ok == 1)     /* Wrong, never compare boolean variable against 1! */if (is_ok == 0)     /* Wrong, use ! for negative check */\nAlways use /* comment */ for comments, even for single-line comment\n\nAlways include check for C++ with extern keyword in header file\n\nEvery function must include doxygen-enabled comment, even if function is static\n\nUse English names/text for functions, variables, comments\n\nUse lowercase characters for variables\n\nUse underscore if variable contains multiple names, eg. force_redraw. Do not use forceRedraw\n\nNever cast function returning void *, eg. uint8_t* ptr = (uint8_t *)func_returning_void_ptr(); as void * is safely promoted to any other pointer type\n\nUse uint8_t* ptr = func_returning_void_ptr(); instead\n\n\nAlways use &lt; and &gt; for C Standard Library include files, eg. #include &lt;stdlib.h&gt;\n\nAlways use &quot;&quot; for custom libraries, eg. #include &quot;my_library.h&quot;\n\nWhen casting to pointer type, always align asterisk to type, eg. uint8_t* t = (uint8_t*)var_width_diff_type\n\nAlways respect code style already used in project or library\n\n\nComments\nComments starting with // are not allowed. Always use /* comment */, even for single-line comment\n//This is comment (wrong)/* This is comment (ok) */\nFor multi-line comments use space+asterisk for every line\n/* * This is multi-line comments, * written in 2 lines (ok) *//** * Wrong, use double-asterisk only for doxygen documentation *//** Single line comment without space before asterisk (wrong)*//* * Single line comment in multi-line configuration (wrong) *//* Single line comment (ok) */\nUse 12 indents (12 * 4 spaces) offset when commenting. If statement is larger than 12 indents, make comment 4-spaces aligned (examples below) to next available indent\nvoidmy_func(void) &#123;    char a, b;    a = call_func_returning_char_a(a);          /* This is comment with 12*4 spaces indent from beginning of line */    b = call_func_returning_char_a_but_func_name_is_very_long(a);   /* This is comment, aligned to 4-spaces indent */&#125;\nFunctions\nEvery function which may have access from outside its module, must include function prototype (or declaration)\n\nFunction name must be lowercase, optionally separated with underscore _ character\n/* OK */void my_func(void);void myfunc(void);/* Wrong */void MYFunc(void);void myFunc();\nWhen function returns pointer, align asterisk to return type\n/* OK */const char* my_func(void);my_struct_t* my_func(int32_t a, int32_t b);/* Wrong */const char *my_func(void);my_struct_t * my_func(void);\nAlign all function prototypes (with the same/similar functionality) for better readability\n/* OK, function names aligned */void        set(int32_t a);my_type_t   get(void);my_ptr_t*   get_ptr(void);/* Wrong */void set(int32_t a);const char * get(void);\nFunction implementation must include return type and optional other keywords in separate line\n/* OK */int32_tfoo(void) &#123;    return 0;&#125;/* OK */static const char*get_string(void) &#123;    return &quot;Hello world!\\r\\n&quot;;&#125;/* Wrong */int32_t foo(void) &#123;    return 0;&#125;\nWhen function returns pointer, asterisk character must be aligned to return type (char*)\n/* OK */const char*foo(void) &#123;    return &quot;test&quot;;&#125;/* Wrong */const char*foo(void) &#123;    return &quot;test&quot;;&#125;\nVariables\nMake variable name all lowercase with optional underscore _ character\n/* OK */int32_t a;int32_t my_var;int32_t myvar;/* Wrong */int32_t A;int32_t myVar;int32_t MYVar;\nGroup local variables together by type\nvoidfoo(void) &#123;    int32_t a, b;   /* OK */    char a;    char b;         /* Wrong, char type already exists */&#125;\nDo not declare variable after first executable statement\nvoidfoo(void) &#123;    int32_t a;    a = bar();    int32_t b;      /* Wrong, there is already executable statement */&#125;\nYou may declare new variables inside next indent level\nint32_t a, b;a = foo();if (a) &#123;    int32_t c, d;   /* OK, c and d are in if-statement scope */    c = foo();    int32_t e;      /* Wrong, there was already executable statement inside block */&#125;\nDeclare pointer variables with asterisk aligned to type\n/* OK */char* a;/* Wrong */char *a;char * a;\nWhen declaring multiple pointer variables, you may declare them with asterisk aligned to variable name\n/* OK */char *p, *n;\nStructures, enumerations, typedefs\nStructure or enumeration name must be lowercase with optional underscore _ character between words\n\nStructure or enumeration may contain typedef keyword\n\nAll structure members must be lowercase\n\nAll enumeration members must be uppercase\n\nStructure/enumeration must follow doxygen documentation syntax\n\n\nWhen structure is declared, it may use one of 3 different options:\n\nWhen structure is declared with name only, it must not contain _t suffix after its name.struct struct_name &#123;    char* a;    char b;&#125;;\nWhen structure is declared with typedef only, it has to contain _t suffix after its name.typedef struct &#123;    char* a;    char b;&#125; struct_name_t;\nWhen structure is declared with name and typedef, it must not contain _t for basic name and it has to contain _t suffix after its name for typedef part.typedef struct struct_name &#123;    char* a;    char b;    char c;&#125; struct_name_t;\nExamples of bad declarations and their suggested corrections/* a and b must be separated to 2 lines *//* Name of structure with typedef must include _t suffix */typedef struct &#123;    int32_t a, b;&#125; a;/* Corrected version */typedef struct &#123;    int32_t a;    int32_t b;&#125; a_t;/* Wrong name, it must not include _t suffix */struct name_t &#123;    int32_t a;    int32_t b;&#125;;/* Wrong parameters, must be all uppercase */typedef enum &#123;    MY_ENUM_TESTA,    my_enum_testb,&#125; my_enum_t;\n\n\nWhen initializing structure on declaration, use C99 initialization style\n/* OK */a_t a = &#123;    .a = 4,    .b = 5,&#125;;/* Wrong */a_t a = &#123;1, 2&#125;;\nWhen new typedef is introduced for function handles, use _fn suffix\n/* Function accepts 2 parameters and returns uint8_t *//* Name of typedef has `_fn` suffix */typedef uint8_t (*my_func_typedef_fn)(uint8_t p1, const char* p2);\nCompound statements\nEvery compound statement must include opening and closing curly bracket, even if it includes only 1 nested statement\n\nEvery compound statement must include single indent; when nesting statements, include 1 indent size for each nest\n/* OK */if (c) &#123;    do_a();&#125; else &#123;    do_b();&#125;/* Wrong */if (c)    do_a();else    do_b();/* Wrong */if (c) do_a();else do_b();\nIn case of if or if-else-if statement, else must be in the same line as closing bracket of first statement\n/* OK */if (a) &#123;&#125; else if (b) &#123;&#125; else &#123;&#125;/* Wrong */if (a) &#123;&#125;else &#123;&#125;/* Wrong */if (a) &#123;&#125;else&#123;&#125;\nIn case of do-while statement, while part must be in the same line as closing bracket of do part\n/* OK */do &#123;    int32_t a;    a = do_a();    do_b(a);&#125; while (check());/* Wrong */do&#123;/* ... */&#125; while (check());/* Wrong */do &#123;/* ... */&#125;while (check());\nIndentation is required for every opening bracket\nif (a) &#123;    do_a();&#125; else &#123;    do_b();    if (c) &#123;        do_c();    &#125;&#125;\nNever do compound statement without curly bracket, even in case of single statement. Examples below show bad practices\nif (a) do_b();else do_c();if (a) do_a(); else do_b();\nEmpty while, do-while or for loops must include brackets\n/* OK */while (is_register_bit_set()) &#123;&#125;/* Wrong */while (is_register_bit_set());while (is_register_bit_set()) &#123; &#125;while (is_register_bit_set()) &#123;&#125;\nIf while (or for, do-while, etc) is empty (it can be the case in embedded programming), use empty single-line brackets\n/* Wait for bit to be set in embedded hardware unituint32_t* addr = HW_PERIPH_REGISTER_ADDR;/* Wait bit 13 to be ready */while (*addr &amp; (1 &lt;&lt; 13)) &#123;&#125;        /* OK, empty loop contains no spaces inside curly brackets */while (*addr &amp; (1 &lt;&lt; 13)) &#123; &#125;       /* Wrong */while (*addr &amp; (1 &lt;&lt; 13)) &#123;         /* Wrong */&#125;while (*addr &amp; (1 &lt;&lt; 13));          /* Wrong, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */\nAlways prefer using loops in this order: for, do-while, while\n\nAvoid incrementing variables inside loop block if possible, see examples\n\n\n/* Not recommended */int32_t a = 0;while (a &lt; 10) &#123;    .    ..    ...    ++a;&#125;/* Better */for (size_t a = 0; a &lt; 10; ++a) &#123;&#125;/* Better, if inc may not happen in every cycle */for (size_t a = 0; a &lt; 10; ) &#123;    if (...) &#123;        ++a;    &#125;&#125;\nSwitch statement\nAdd single indent for every case statement\n\nUse additional single indent for break statement in each case or default\n/* OK, every case has single indent *//* OK, every break has additional indent */switch (check()) &#123;    case 0:        do_a();        break;    case 1:        do_b();        break;    default:        break;&#125;/* Wrong, case indent missing */switch (check()) &#123;case 0:    do_a();    break;case 1:    do_b();    break;default:    break;&#125;/* Wrong */switch (check()) &#123;    case 0:        do_a();    break;      /* Wrong, break must have indent as it is under case */    case 1:    do_b();     /* Wrong, indent under case is missing */    break;    default:        break;&#125;\nAlways include default statement\n/* OK */switch (var) &#123;    case 0:        do_job();        break;    default: break;&#125;/* Wrong, default is missing */switch (var) &#123;    case 0:        do_job();        break;&#125;\nIf local variables are required, use curly brackets and put break statement inside.\n\nPut opening curly bracket in the same line as case statementswitch (a) &#123;    /* OK */    case 0: &#123;        int32_t a, b;        char c;        a = 5;        /* ... */        break;    &#125;    /* Wrong */    case 1:    &#123;        int32_t a;        break;    &#125;    /* Wrong, break shall be inside */    case 2: &#123;        int32_t a;    &#125;    break;&#125;\nMacros and preprocessor directives\n\n\nAlways use macros instead of literal constants, specially for numbers\n\nAll macros must be fully uppercase, with optional underscore _ character, except if they are clearly marked as function which may be in the future replaced with regular function syntax\n/* OK */#define MY_MACRO(x)         ((x) * (x))/* Wrong */#define square(x)           ((x) * (x))\nAlways protect input parameters with parentheses\n/* OK */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))/* Wrong */#define MIN(x, y)           x &lt; y ? x : y\nAlways protect final macro evaluation with parenthesis\n/* Wrong */#define MIN(x, y)           (x) &lt; (y) ? (x) : (y)#define SUM(x, y)           (x) + (y)/* Imagine result of this equation using wrong SUM implementation */int32_t x = 5 * SUM(3, 4);  /* Expected result is 5 * 7 = 35 */int32_t x = 5 * (3) + (4);  /* It is evaluated to this, final result = 19 which is not what we expect *//* Correct implementation */#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))#define SUM(x, y)           ((x) + (y))\nWhen macro uses multiple statements, protect it using do-while (0) statement\ntypedef struct &#123;    int32_t px, py;&#125; point_t;point_t p;                  /* Define new point *//* Wrong implementation *//* Define macro to set point */#define SET_POINT(p, x, y)  (p)-&gt;px = (x); (p)-&gt;py = (y)    /* 2 statements. Last one should not implement semicolon */SET_POINT(&amp;p, 3, 4);        /* Set point to position 3, 4. This evaluates to... */(&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); /* ... to this. In this example this is not a problem. *//* Consider this ugly code, however it is valid by C standard (not recommended) */if (a)                      /* If a is true */    if (b)                  /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    else        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 *//* Evaluates to code below. Do you see the problem? */if (a)    if (b)        (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6);/* Or if we rewrite it a little */if (a)    if (b)        (&amp;p)-&gt;px = (3);        (&amp;p)-&gt;py = (4);    else        (&amp;p)-&gt;px = (5);        (&amp;p)-&gt;py = (6);/* * Ask yourself a question: To which `if` statement `else` keyword belongs? * * Based on first part of code, answer is straight-forward. To inner `if` statement when we check `b` condition * Actual answer: Compilation error as `else` belongs nowhere *//* Better and correct implementation of macro */#define SET_POINT(p, x, y)  do &#123; (p)-&gt;px = (x); (p)-&gt;py = (y); &#125; while (0)    /* 2 statements. No semicolon after while loop *//* Or even better */#define SET_POINT(p, x, y)  do &#123;    \\   /* Backslash indicates statement continues in new line */    (p)-&gt;px = (x);                  \\    (p)-&gt;py = (y);                  \\&#125; while (0)                             /* 2 statements. No semicolon after while loop *//* Now original code evaluates to */if (a)    if (b)        do &#123; (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); &#125; while (0);    else        do &#123; (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); &#125; while (0);/* Every part of `if` or `else` contains only `1` inner statement (do-while), hence this is valid evaluation *//* To make code perfect, use brackets for every if-ifelse-else statements */if (a) &#123;                    /* If a is true */    if (b) &#123;                /* If b is true */        SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */    &#125; else &#123;        SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 */    &#125;&#125;\nAlways write macro documentation as regular function with additional hideinitializer doxygen keyword\n#define MY_MACRO(x)         ((x) * 2)\nAvoid using #ifdef or #ifndef. Use defined() or !defined() instead\n#ifdef XYZ/* do something */#endif /* XYZ */\nAlways document if/elif/else/endif statements\n/* OK */#if defined(XYZ)/* Do if XYZ defined */#else /* defined(XYZ) *//* Do if XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)/* Do if XYZ defined */#else/* Do if XYZ not defined */#endif\nDo not indent sub statements inside #if statement\n/* OK */#if defined(XYZ)#if defined(ABC)/* do when ABC defined */#endif /* defined(ABC) */#else /* defined(XYZ) *//* Do when XYZ not defined */#endif /* !defined(XYZ) *//* Wrong */#if defined(XYZ)    #if defined(ABC)        /* do when ABC defined */    #endif /* defined(ABC) */#else /* defined(XYZ) */    /* Do when XYZ not defined */#endif /* !defined(XYZ) */\nDocumentation\n\nDocumented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly.\n\nUse doxygen-enabled documentation style for variables, functions and structures/enumerations\n\nAlways use \\ for doxygen, do not use @\n\nAlways use 5x4 spaces (5 tabs) offset from beginning of line for text\n/** * \\brief           Holds pointer to first entry in linked list *                  Beginning of this text is 5 tabs (20 spaces) from beginning of line */statictype_t* list;\nEvery structure/enumeration member must include documentation\n\nUse 12x4 spaces offset for beginning of comment\n/** * \\brief           This is point struct * \\note            This structure is used to calculate all point *                      related stuff */typedef struct &#123;    int32_t x;                                  /*!&lt; Point X coordinate */    int32_t y;                                  /*!&lt; Point Y coordinate */    int32_t size;                               /*!&lt; Point size.                                                    Since comment is very big,                                                    you may go to next line */&#125; point_t;/** * \\brief           Point color enumeration */typedef enum &#123;    COLOR_RED,                                  /*!&lt; Red color. This comment has 12x4                                                    spaces offset from beginning of line */    COLOR_GREEN,                                /*!&lt; Green color */    COLOR_BLUE,                                 /*!&lt; Blue color */&#125; point_color_t;\nDocumentation for functions must be written in function implementation (source file usually)\n\nFunction must include brief and all parameters documentation\n\nEvery parameter must be noted if it is in or out for input and output respectively\n\nFunction must include return parameter if it returns something. This does not apply for void functions\n\nFunction can include other doxygen keywords, such as note or warning\n\nUse colon : between parameter name and its description\n/** * \\brief           Sum `2` numbers * \\param[in]       a: First number * \\param[in]       b: Second number * \\return          Sum of input values */int32_tsum(int32_t a, int32_t b) &#123;    return a + b;&#125;/** * \\brief           Sum `2` numbers and write it to pointer * \\note            This function does not return value, it stores it to pointer instead * \\param[in]       a: First number * \\param[in]       b: Second number * \\param[out]      result: Output variable used to save result */voidvoid_sum(int32_t a, int32_t b, int32_t* result) &#123;    *result = a + b;&#125;\nIf function returns member of enumeration, use ref keyword to specify which one\n/** * \\brief           My enumeration */typedef enum &#123;    MY_ERR,                                     /*!&lt; Error value */    MY_OK                                       /*!&lt; OK value */&#125; my_enum_t;/** * \\brief           Check some value * \\return          \\ref MY_OK on success, member of \\ref my_enum_t otherwise */my_enum_tcheck_value(void) &#123;    return MY_OK;&#125;\nUse notation (`NULL` =&gt; NULL) for constants or numbers\n/** * \\brief           Get data from input array * \\param[in]       in: Input data * \\return          Pointer to output data on success, `NULL` otherwise */const void *get_data(const void* in) &#123;    return in;&#125;\nDocumentation for macros must include hideinitializer doxygen command\n/** * \\brief           Get minimal value between `x` and `y` * \\param[in]       x: First value * \\param[in]       y: Second value * \\return          Minimal value between `x` and `y` * \\hideinitializer */#define MIN(x, y)       ((x) &lt; (y) ? (x) : (y))\nHeader/source files\nLeave single empty line at the end of file\n\nEvery file must include doxygen annotation for file and brief description followed by empty line (when using doxygen)\n/** * \\file            template.h * \\brief           Template include file */                    /* Here is empty line */\nEvery file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen)\n\nUse the same license as already used by project/library\n/** * \\file            template.h * \\brief           Template include file *//* * Copyright (c) year FirstName LASTNAME * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the &quot;Software&quot;), to deal in the Software without restriction, * including without limitation the rights to use, copy, modify, merge, * publish, distribute, sublicense, and/or sell copies of the Software, * and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. * * This file is part of library_name. * * Author:          FirstName LASTNAME &lt;optional_email@example.com&gt; */\nHeader file must include guard #ifndef\n\nHeader file must include C++ check\n\nInclude external header files outside C++ check\n\nInclude external header files with STL C files first followed by application custom files\n\nHeader file must include only every other header file in order to compile correctly, but not more (.c should include the rest if required)\n\nHeader file must only expose module public variables/types/functions\n\nUse extern for global module variables in header file, define them in source file later\n&#x2F;* file.h ... *&#x2F;#ifndef ...extern int32_t my_variable; &#x2F;* This is global variable declaration in header *&#x2F;#endif&#x2F;* file.c ... *&#x2F;int32_t my_variable;        &#x2F;* Actually defined in source *&#x2F;\nNever include .c files in another .c file\n\n.c file should first include corresponding .h file, later others, unless otherwise explicitly necessary\n\nDo not include module private declarations in header file\n\nHeader file example (no license for sake of an example)\n/* License comes here */#ifndef TEMPLATE_HDR_H#define TEMPLATE_HDR_H/* Include headers */#ifdef __cplusplusextern &quot;C&quot; &#123;#endif /* __cplusplus *//* File content here */#ifdef __cplusplus&#125;#endif /* __cplusplus */#endif /* TEMPLATE_HDR_H */\nArtistic style configuration\n\nAStyle is a great piece of software that canhelp with formatting the code based on input configuration.\nThis repository contains astyle-code-format.cfg file which can be used with AStyle software.\nastyle --options&#x3D;&quot;astyle-code-format.cfg&quot; &quot;input_path&#x2F;*.c,*.h&quot; &quot;input_path2&#x2F;*.c,*.h&quot;\nEclipse formatterRepository contains eclipse-ext-kr-format.xml file that can be used witheclipse-based toolchains to set formatter options.\nIt is based on K&amp;R formatter with modifications to respect above rules.You can import it within eclipse settings, Preferences -&gt; LANGUAGE -&gt; Code Style -&gt; Formatter tab.\n"},{"title":"常见的字符串Hash算法","url":"/2021/07/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2Hash%E7%AE%97%E6%B3%95/","content":"常见hash算法的碰撞概率统计\n\n\n\n10万\n50万\n100万\n500万\n1000万\n一亿\n1000万次的平均执行时间\n一亿次的平均执行时间\n一亿次的平均长度\n\n\n\nBKDRHash\n0.00002\n0.000112\n0.000251\n0.0011894\n0.0023321\n0.0229439\n0.0064134\n0.00968998\n9\n\n\nAPHash\n0\n0.000052\n0.000122\n0.0005794\n0.0011712\n0.01155826\n0.0061518\n0.01088634\n10\n\n\nDJBHash\n0.00001\n0.00011\n0.000204\n0.0011782\n0.0023154\n0.02294341\n0.0064836\n0.01098645\n9\n\n\nJSHash\n0\n0.000188\n0.00032\n0.001464\n0.0029323\n0.02876141\n0.0063464\n0.00904354\n9\n\n\nRSHash\n0.00001\n0.000122\n0.000245\n0.001154\n0.00233\n0.02290588\n0.0063627\n0.01168532\n9\n\n\nSDBMHash\n0.00002\n0.000132\n0.000235\n0.001175\n0.0023435\n0.02294529\n0.0064155\n0.01201398\n9\n\n\nPJWHash\n0.00312\n0.015032\n0.029957\n0.1386394\n0.251465\n0.83290663\n0.0067549\n0.00601705\n8\n\n\nELFHash\n0.00096\n0.005584\n0.011239\n0.0539746\n0.1028391\n0.52002744\n0.0060441\n0.00704438\n9\n\n\nMurmurHash\n0\n0\n0\n0\n0\n0\n0.0066868\n0.01194736\n19\n\n\nCityHash\n0\n0\n0\n0\n0\n0\n0.0066179\n0.01129171\n19\n\n\nFNVHash\n0.00005\n0.000186\n0.000349\n0.0016688\n0.0033469\n0.03279751\n0.0061614\n0.01018707\n9\n\n\ncrc64\n0\n0\n0\n0\n0\n0\n0.0064459\n0.01242473\n19\n\n\n1.BKDR hash function\nunsigned int bkdr_hash(const char *str)&#123;    unsigned int seed = 131; // the magic number, 31, 131, 1313, 13131, etc.. orz..    unsigned int hash = 0;    unsigned char *p = (unsigned char *)str;    while (*p)        hash = hash * seed + (*p++);    return hash;&#125;\n2.AP hash function\nunsigned int ap_hash(char *str)&#123;    unsigned int hash = 0;    int i;    for (i=0; *str; i++)        if ((i &amp; 1) == 0)            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));        else            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));    return (hash &amp; 0x7FFFFFFF);&#125;\n3.DJB hash function\nunsigned long hash_djbx33a(const char *str, size_t len)&#123;    unsigned long hash = 0U;    for(size_t i = 0;i &lt; len; ++i) &#123;        hash = hash * 33 + (unsigned long)str[i];        /* or, hash = ((hash &lt;&lt; 5) + hash) + (unsigned long)str[i];          * where, hash * 33 = ((hash &lt;&lt; 5) + hash)         */    &#125;    return hash;&#125;long long djb2(char s[])&#123;    long long hash = 5381; /* init value */    int i = 0;    while (s[i] != &#x27;\\0&#x27;)    &#123;        hash = ((hash &lt;&lt; 5) + hash) + s[i];        i++;    &#125;    return hash;&#125;\n4.JS hash function\nunsigned int js_hash(char*str)&#123;    unsigned int hash = 1315423911 ;    while(*str)    &#123;        hash ^=((hash &lt;&lt;5 ) + (*str++) + (hash &gt;&gt;2 ));    &#125;    return hash;&#125;\n5.RS hash function\nunsigned int RSHash( char * str)&#123;    unsigned int b = 378551;    unsigned int a = 63689;    unsigned int hash = 0;    while(*str)    &#123;        hash = hash * a + (*str++);        a *= b;    &#125;    return (hash &amp; 0x7FFFFFFF);&#125;\n6.SDBM hash function\nstatic unsigned long sdbm(unsigned char *str)&#123;    unsigned long hash = 0;    int c;    while (c = *str++)        hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;    return hash;&#125;\nsdbm_hash.c\n/* Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//* * sdbm - ndbm work-alike hashed database library * based on Per-Aake Larson&#x27;s Dynamic Hashing algorithms. BIT 18 (1978). * author: oz@nexus.yorku.ca * status: ex-public domain. keep it that way. * * hashing routine */#include &quot;apr_sdbm.h&quot;#include &quot;sdbm_private.h&quot;/* * polynomial conversion ignoring overflows * [this seems to work remarkably well, in fact better * then the ndbm hash function. Replace at your own risk] * use: 65599  nice. *      65587  even better.  */long sdbm_hash(const char *str, int len)&#123;    register unsigned long n = 0;#define DUFF/* go ahead and use the loop-unrolled version */#ifdef DUFF#define HASHCn = *str++ + 65599 * n    if (len &gt; 0) &#123;        register int loop = (len + 8 - 1) &gt;&gt; 3;        switch(len &amp; (8 - 1)) &#123;        case 0:do &#123;                HASHC;case 7:HASHC;        case 6:HASHC; case 5:HASHC;        case 4:HASHC; case 3:HASHC;        case 2:HASHC;case 1:HASHC;            &#125; while (--loop);        &#125;    &#125;#else    while (len--)        n = *str++ + 65599 * n;#endif    return n;&#125;\n7.PJWHash hash function\n/*  * A generic hash function HashPJW better than ElfHash point,  * but depending on the context. */#include &lt;limits.h&gt;#define BITS_IN_int     ( sizeof(int) * CHAR_BIT )#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))#define HIGH_BITS       ( ~((unsigned int)(~0) &gt;&gt; ONE_EIGHTH ))unsigned int HashPJW ( const char * datum )&#123;    unsigned int hash_value, i;    for ( hash_value = 0; *datum; ++datum )    &#123;        hash_value = ( hash_value &lt;&lt; ONE_EIGHTH ) + *datum;        if (( i = hash_value &amp; HIGH_BITS ) != 0 )            hash_value = ( hash_value ^ ( i &gt;&gt; THREE_QUARTERS )) &amp; ~HIGH_BITS;    &#125;    return ( hash_value );&#125;\n8.ELFHash hash function\n/* *    This function hash the input string &#x27;name&#x27; using the ELF hash *    function for strings. */static unsigned int hash(char* name)&#123;    unsigned int h = 0;    unsigned int g;    while(*name) &#123;        h = (h&lt;&lt;4) + *name++;        if ((g = (h &amp; 0xf0000000)))            h ^= g&gt;&gt;24;        h &amp;=~ g;    &#125;    return h;&#125;\n9.Murmur hash function\nuint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) &#123;    uint32_t h = seed;    if (len &gt; 3) &#123;        const uint32_t* key_x4 = (const uint32_t*) key;        size_t i = len &gt;&gt; 2;        do &#123;            uint32_t k = *key_x4++;            k *= 0xcc9e2d51;            k = (k &lt;&lt; 15) | (k &gt;&gt; 17);            k *= 0x1b873593;            h ^= k;            h = (h &lt;&lt; 13) | (h &gt;&gt; 19);            h = (h * 5) + 0xe6546b64;        &#125; while (--i);        key = (const uint8_t*) key_x4;    &#125;    if (len &amp; 3) &#123;        size_t i = len &amp; 3;        uint32_t k = 0;        key = &amp;key[i - 1];        do &#123;        k &lt;&lt;= 8;        k |= *key--;        &#125; while (--i);        k *= 0xcc9e2d51;        k = (k &lt;&lt; 15) | (k &gt;&gt; 17);        k *= 0x1b873593;        h ^= k;    &#125;    h ^= len;    h ^= h &gt;&gt; 16;    h *= 0x85ebca6b;    h ^= h &gt;&gt; 13;    h *= 0xc2b2ae35;    h ^= h &gt;&gt; 16;    return h;&#125;\n10.City hash function\n/*  * CityHash 的主要优点是大部分步骤包含了至少两步独立的数学运算 * 代码较同类流行算法复杂 */\n11.FNVHashFNV-1 hash\nhash &#x3D; FNV_offset_basisfor each byte_of_data to be hashed    hash &#x3D; hash × FNV_prime    hash &#x3D; hash XOR byte_of_datareturn hash\nFNV-1a hash\nhash &#x3D; FNV_offset_basisfor each byte_of_data to be hashed    hash &#x3D; hash XOR byte_of_data    hash &#x3D; hash × FNV_primereturn hash\n其它的比较\n\n\nHash函数\n数据1\n数据2\n数据3\n数据4\n数据1得分\n数据2得分\n数据3得分\n数据4得分\n平均分\n\n\n\nBKDRHash\n2\n0\n4774\n481\n96.55\n100\n90.95\n82.05\n92.64\n\n\nAPHash\n2\n3\n4754\n493\n96.55\n88.46\n100\n51.28\n86.28\n\n\nDJBHash\n2\n2\n4975\n474\n96.55\n92.31\n0\n100\n83.43\n\n\nJSHash\n1\n4\n4761\n506\n100\n84.62\n96.83\n17.95\n81.94\n\n\nRSHash\n1\n0\n4861\n505\n100\n100\n51.58\n20.51\n75.96\n\n\nSDBMHash\n3\n2\n4849\n504\n93.1\n92.31\n57.01\n23.08\n72.41\n\n\nPJWHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\nELFHash\n30\n26\n4878\n513\n0\n0\n43.89\n0\n21.95\n\n\n其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。\n经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。\n在信息修竞赛中，要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的。\n"},{"title":"SVC系统调用的编程使用方法","url":"/2021/11/02/SVC%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"SVC称为系统服务调用(SuperVisorCall)，异常类型为11，通过svc指令可用触发异常，SVC在触发异常后必须立即得到相应(触发异常后在执行异常前不能执行其它代码)，除非有更高优先级的异常在执行。\n对于可靠系统而言，可用使用SVC异常实现资源的特权访问，使系统更加安全。它通过SVC系统调用编号能够实现参数传递，从而实现不同功能的系统服务。使用系统服务可用不需要知道具体服务函数的地址，这样可用隐藏更多的细节。\n在ARM开发工具链下，有比较优雅的方式直接使用SVC异常，在GCC下需要配合汇编来使用。\n这里不讨论ARM处理器对于异常的处理机制，它在触发SVC指令后响应的异常行为与系统其它异常一致。\nSVC异常处理  .syntax unified  .thumb  .global SVC_Handler  .global SVC_VIRTUAL_CALL_0  .global SVC_VIRTUAL_CALL_1  .global SVC_VIRTUAL_CALL_2  .global SVC_VIRTUAL_CALL_3  .type SVC_Handler, %function  .type SVC_VIRTUAL_CALL_0, %function  .type SVC_VIRTUAL_CALL_1, %function  .type SVC_VIRTUAL_CALL_2, %function  .type SVC_VIRTUAL_CALL_3, %functionSVC_Handler:  tst lr, #4  ite eq  mrseq r0, msp  mrsne r0, psp  push &#123;r6, r7, lr&#125;  mov r7, r0  ldr r0, [r7, #0]     //原始R0  ldr r1, [r7, #4]  ldr r2, [r7, #8]  ldr r3, [r7, #12]  ldr r6, [r7, #24]  ldr r6, [r6, #-2]  and r6, #0xFF  ldr r12, =g_svc_vector  ldr r6, [r12, r6, lsl #2]  blx r6  str r0, [r7, #0]  pop &#123;r6, r7, pc&#125;Default_SVC_Handler:  bx lr  .align 2g_svc_vector:  .word SVC_HANDLER_0  .word SVC_HANDLER_1  .word SVC_HANDLER_2  .word SVC_HANDLER_3    .weak      SVC_HANDLER_0  .thumb_set SVC_HANDLER_0, Default_SVC_Handler  .weak      SVC_HANDLER_1  .thumb_set SVC_HANDLER_1, Default_SVC_Handler  .weak      SVC_HANDLER_2  .thumb_set SVC_HANDLER_2, Default_SVC_Handler  .weak      SVC_HANDLER_3  .thumb_set SVC_HANDLER_3, Default_SVC_HandlerSVC_VIRTUAL_CALL_0:    svc 0    bx lrSVC_VIRTUAL_CALL_1:    svc 1    bx lrSVC_VIRTUAL_CALL_2:    svc 2    bx lrSVC_VIRTUAL_CALL_3:    svc 3    bx lr\nSVC_Handler函数是异常处理函数，进入函数，判断LR寄存器来分析进入异常前的环境，获取到对应的sp地址。通过sp寄存器就能访问到栈空间，在栈中可以获取到r0-r3，这个就是执行svc时传进来的参数，通常这4个寄存器不会被修改，除非发生了更高优先级的异常。通过在栈中获取到执行svc的pc指针，得到svc指令的二进制码，低8位存储了指令的异常id，我们使用该id在内部通过查表得方式定位具体应该执行的函数入口，执行函数后，我们将r0也就是返回值存储到栈空间中，这样返回到用户态后，用户就能获得执行的返回结果。\n为了方便定义用户系统调用函数，设计了这样的一个宏。\n#define SVC_CALL_DEF(id, func, ret_t, ...) \\extern ret_t SVC_VIRTUAL_CALL_##id(__VA_ARGS__); \\ret_t SVC_HANDLER_##id(__VA_ARGS__)\n其中id表示该函数绑定到svc的那一个系统调用上，func表示函数名称，ret_t和后面的参数分别表示函数的返回值和形参列表，如果无形参则填入void。通过 SVC_VIRTUAL_CALL_id()来执行系统调用。\n这是一个简单的例子：\nSVC_CALL_DEF(1, test_svc_add, int, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = SVC_VIRTUAL_CALL_1(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n进阶写法前面的定义方法和调用方法与传统的C语言函数定义和函数调用存在区别，所以在使用上存在不方便的地方，按照下面的写法更加合理，且函数的定义与调用与C语言类似，减低了代码移植上的一致性问题。\n#ifndef __SVC_HANDER_H#define __SVC_HANDER_H#if defined(__GNUC__)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__); \\    __asm__(        \\        &quot;.thumb\\n&quot;  \\        &quot;.global &quot; #name &quot;\\n&quot; \\        &quot;.type &quot; #name &quot;, %function\\n&quot; \\        #name &quot;:\\n&quot; \\        &quot;svc &quot; #id &quot;\\n&quot; \\        &quot;bx lr\\n&quot;); \\    ret_t SVC_HANDLER_##id(__VA_ARGS__)#elif defined(__CC_ARM)#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t __svc(id) name(__VA_ARGS__)#else#define DEF_SVC_FUNC(id, ret_t, name, ...) \\    ret_t name(__VA_ARGS__)    // #warning &quot;not support SVC function!&quot;#endif#endif\n有了这个新的头文件后，定义一个svc函数以及函数的写法将变为：\nDEF_SVC_FUNC(2, int, add_func, int a, int b)&#123;    return a + b;&#125;int main(void)&#123;    int ret = 0;    ret = add_func(2, 3);    printf(&quot;2+3 = %d\\r\\n&quot;, ret);    return 0;&#125;\n这样的写法能够兼容不同的编译器，且不用提前定义SVC_VIRTUAL_CALL_0函数。\n"}]